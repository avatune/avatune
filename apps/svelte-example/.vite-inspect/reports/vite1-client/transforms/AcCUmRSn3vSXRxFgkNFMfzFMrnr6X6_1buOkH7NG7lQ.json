{
  "resolvedId": "/Users/teimurgasanov/Projects/avatune/node_modules/storybook/dist/instrumenter/index.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import {\n  CallStates,\n  EVENTS\n} from \"../_browser-chunks/chunk-SN4J4IQ3.js\";\nimport {\n  processError\n} from \"../_browser-chunks/chunk-JVSKG4YS.js\";\nimport {\n  __name\n} from \"../_browser-chunks/chunk-MM7DTO55.js\";\n\n// src/instrumenter/instrumenter.ts\nimport { once } from \"storybook/internal/client-logger\";\nimport {\n  FORCE_REMOUNT,\n  SET_CURRENT_STORY,\n  STORY_RENDER_PHASE_CHANGED\n} from \"storybook/internal/core-events\";\nimport { global } from \"@storybook/global\";\n\n// src/instrumenter/preview-api.ts\nvar addons = globalThis.__STORYBOOK_ADDONS_PREVIEW;\n\n// src/instrumenter/instrumenter.ts\nvar alreadyCompletedException = new Error(\n  `This function ran after the play function completed. Did you forget to \\`await\\` it?`\n);\nvar isObject = /* @__PURE__ */ __name((o) => Object.prototype.toString.call(o) === \"[object Object]\", \"isObject\");\nvar isModule = /* @__PURE__ */ __name((o) => Object.prototype.toString.call(o) === \"[object Module]\", \"isModule\");\nvar isInstrumentable = /* @__PURE__ */ __name((o) => {\n  if (!isObject(o) && !isModule(o)) {\n    return false;\n  }\n  if (o.constructor === void 0) {\n    return true;\n  }\n  const proto = o.constructor.prototype;\n  if (!isObject(proto)) {\n    return false;\n  }\n  return true;\n}, \"isInstrumentable\");\nvar construct = /* @__PURE__ */ __name((obj) => {\n  try {\n    return new obj.constructor();\n  } catch {\n    return {};\n  }\n}, \"construct\");\nvar getInitialState = /* @__PURE__ */ __name(() => ({\n  renderPhase: \"preparing\",\n  isDebugging: false,\n  isPlaying: false,\n  isLocked: false,\n  cursor: 0,\n  calls: [],\n  shadowCalls: [],\n  callRefsByResult: /* @__PURE__ */ new Map(),\n  chainedCallIds: /* @__PURE__ */ new Set(),\n  ancestors: [],\n  playUntil: void 0,\n  resolvers: {},\n  syncTimeout: void 0\n}), \"getInitialState\");\nvar getRetainedState = /* @__PURE__ */ __name((state, isDebugging = false) => {\n  const calls = (isDebugging ? state.shadowCalls : state.calls).filter((call) => call.retain);\n  if (!calls.length) {\n    return void 0;\n  }\n  const callRefsByResult = new Map(\n    Array.from(state.callRefsByResult.entries()).filter(([, ref]) => ref.retain)\n  );\n  return { cursor: calls.length, calls, callRefsByResult };\n}, \"getRetainedState\");\nvar _Instrumenter = class _Instrumenter {\n  constructor() {\n    this.detached = false;\n    this.initialized = false;\n    // State is tracked per story to deal with multiple stories on the same canvas (i.e. docs mode)\n    this.state = {};\n    this.loadParentWindowState = /* @__PURE__ */ __name(() => {\n      try {\n        this.state = global.window?.parent?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ || {};\n      } catch {\n        this.detached = true;\n      }\n    }, \"loadParentWindowState\");\n    this.updateParentWindowState = /* @__PURE__ */ __name(() => {\n      try {\n        global.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ = this.state;\n      } catch {\n        this.detached = true;\n      }\n    }, \"updateParentWindowState\");\n    this.loadParentWindowState();\n    const resetState = /* @__PURE__ */ __name(({\n      storyId,\n      renderPhase,\n      isPlaying = true,\n      isDebugging = false\n    }) => {\n      const state = this.getState(storyId);\n      this.setState(storyId, {\n        ...getInitialState(),\n        ...getRetainedState(state, isDebugging),\n        renderPhase: renderPhase || state.renderPhase,\n        shadowCalls: isDebugging ? state.shadowCalls : [],\n        chainedCallIds: isDebugging ? state.chainedCallIds : /* @__PURE__ */ new Set(),\n        playUntil: isDebugging ? state.playUntil : void 0,\n        isPlaying,\n        isDebugging\n      });\n      this.sync(storyId);\n    }, \"resetState\");\n    const start = /* @__PURE__ */ __name((channel) => ({ storyId, playUntil }) => {\n      if (!this.getState(storyId).isDebugging) {\n        this.setState(storyId, ({ calls }) => ({\n          calls: [],\n          shadowCalls: calls.map((call) => ({ ...call, status: \"waiting\" /* WAITING */ })),\n          isDebugging: true\n        }));\n      }\n      const log = this.getLog(storyId);\n      this.setState(storyId, ({ shadowCalls }) => {\n        if (playUntil || !log.length) {\n          return { playUntil };\n        }\n        const firstRowIndex = shadowCalls.findIndex((call) => call.id === log[0].callId);\n        return {\n          playUntil: shadowCalls.slice(0, firstRowIndex).filter((call) => call.interceptable && !call.ancestors?.length).slice(-1)[0]?.id\n        };\n      });\n      channel.emit(FORCE_REMOUNT, { storyId, isDebugging: true });\n    }, \"start\");\n    const back = /* @__PURE__ */ __name((channel) => ({ storyId }) => {\n      const log = this.getLog(storyId).filter((call) => !call.ancestors?.length);\n      const last = log.reduceRight((res, item, index) => {\n        if (res >= 0 || item.status === \"waiting\" /* WAITING */) {\n          return res;\n        }\n        return index;\n      }, -1);\n      start(channel)({ storyId, playUntil: log[last - 1]?.callId });\n    }, \"back\");\n    const goto = /* @__PURE__ */ __name((channel) => ({ storyId, callId }) => {\n      const { calls, shadowCalls, resolvers } = this.getState(storyId);\n      const call = calls.find(({ id }) => id === callId);\n      const shadowCall = shadowCalls.find(({ id }) => id === callId);\n      if (!call && shadowCall && Object.values(resolvers).length > 0) {\n        const nextId = this.getLog(storyId).find((c) => c.status === \"waiting\" /* WAITING */)?.callId;\n        if (shadowCall.id !== nextId) {\n          this.setState(storyId, { playUntil: shadowCall.id });\n        }\n        Object.values(resolvers).forEach((resolve) => resolve());\n      } else {\n        start(channel)({ storyId, playUntil: callId });\n      }\n    }, \"goto\");\n    const next = /* @__PURE__ */ __name((channel) => ({ storyId }) => {\n      const { resolvers } = this.getState(storyId);\n      if (Object.values(resolvers).length > 0) {\n        Object.values(resolvers).forEach((resolve) => resolve());\n      } else {\n        const nextId = this.getLog(storyId).find((c) => c.status === \"waiting\" /* WAITING */)?.callId;\n        if (nextId) {\n          start(channel)({ storyId, playUntil: nextId });\n        } else {\n          end({ storyId });\n        }\n      }\n    }, \"next\");\n    const end = /* @__PURE__ */ __name(({ storyId }) => {\n      this.setState(storyId, { playUntil: void 0, isDebugging: false });\n      Object.values(this.getState(storyId).resolvers).forEach((resolve) => resolve());\n    }, \"end\");\n    const renderPhaseChanged = /* @__PURE__ */ __name(({\n      storyId,\n      newPhase\n    }) => {\n      const { isDebugging } = this.getState(storyId);\n      if (newPhase === \"preparing\" && isDebugging) {\n        return resetState({ storyId, renderPhase: newPhase, isDebugging });\n      } else if (newPhase === \"playing\") {\n        return resetState({ storyId, renderPhase: newPhase, isDebugging });\n      }\n      if (newPhase === \"played\") {\n        this.setState(storyId, {\n          renderPhase: newPhase,\n          isLocked: false,\n          isPlaying: false,\n          isDebugging: false\n        });\n      } else if (newPhase === \"errored\") {\n        this.setState(storyId, {\n          renderPhase: newPhase,\n          isLocked: false,\n          isPlaying: false\n        });\n      } else if (newPhase === \"aborted\") {\n        this.setState(storyId, {\n          renderPhase: newPhase,\n          isLocked: true,\n          isPlaying: false\n        });\n      } else {\n        this.setState(storyId, {\n          renderPhase: newPhase\n        });\n      }\n      this.sync(storyId);\n    }, \"renderPhaseChanged\");\n    if (addons) {\n      addons.ready().then(() => {\n        this.channel = addons.getChannel();\n        this.channel.on(FORCE_REMOUNT, resetState);\n        this.channel.on(STORY_RENDER_PHASE_CHANGED, renderPhaseChanged);\n        this.channel.on(SET_CURRENT_STORY, () => {\n          if (this.initialized) {\n            this.cleanup();\n          } else {\n            this.initialized = true;\n          }\n        });\n        this.channel.on(EVENTS.START, start(this.channel));\n        this.channel.on(EVENTS.BACK, back(this.channel));\n        this.channel.on(EVENTS.GOTO, goto(this.channel));\n        this.channel.on(EVENTS.NEXT, next(this.channel));\n        this.channel.on(EVENTS.END, end);\n      });\n    }\n  }\n  getState(storyId) {\n    return this.state[storyId] || getInitialState();\n  }\n  setState(storyId, update) {\n    if (storyId) {\n      const state = this.getState(storyId);\n      const patch = typeof update === \"function\" ? update(state) : update;\n      this.state = { ...this.state, [storyId]: { ...state, ...patch } };\n      this.updateParentWindowState();\n    }\n  }\n  cleanup() {\n    this.state = Object.entries(this.state).reduce(\n      (acc, [storyId, state]) => {\n        const retainedState = getRetainedState(state);\n        if (!retainedState) {\n          return acc;\n        }\n        acc[storyId] = Object.assign(getInitialState(), retainedState);\n        return acc;\n      },\n      {}\n    );\n    const controlStates = {\n      detached: this.detached,\n      start: false,\n      back: false,\n      goto: false,\n      next: false,\n      end: false\n    };\n    const payload = { controlStates, logItems: [] };\n    this.channel?.emit(EVENTS.SYNC, payload);\n    this.updateParentWindowState();\n  }\n  getLog(storyId) {\n    const { calls, shadowCalls } = this.getState(storyId);\n    const merged = [...shadowCalls];\n    calls.forEach((call, index) => {\n      merged[index] = call;\n    });\n    const seen = /* @__PURE__ */ new Set();\n    return merged.reduceRight((acc, call) => {\n      call.args.forEach((arg) => {\n        if (arg?.__callId__) {\n          seen.add(arg.__callId__);\n        }\n      });\n      call.path.forEach((node) => {\n        if (node.__callId__) {\n          seen.add(node.__callId__);\n        }\n      });\n      if ((call.interceptable || call.exception) && !seen.has(call.id)) {\n        acc.unshift({ callId: call.id, status: call.status, ancestors: call.ancestors });\n        seen.add(call.id);\n      }\n      return acc;\n    }, []);\n  }\n  // Traverses the object structure to recursively patch all function properties.\n  // Returns the original object, or a new object with the same constructor,\n  // depending on whether it should mutate.\n  instrument(obj, options, depth = 0) {\n    if (!isInstrumentable(obj)) {\n      return obj;\n    }\n    const { mutate = false, path = [] } = options;\n    const keys = options.getKeys ? options.getKeys(obj, depth) : Object.keys(obj);\n    depth += 1;\n    return keys.reduce(\n      (acc, key) => {\n        const descriptor = getPropertyDescriptor(obj, key);\n        if (typeof descriptor?.get === \"function\") {\n          if (descriptor.configurable) {\n            const getter = /* @__PURE__ */ __name(() => descriptor?.get?.bind(obj)?.(), \"getter\");\n            Object.defineProperty(acc, key, {\n              get: /* @__PURE__ */ __name(() => {\n                return this.instrument(getter(), { ...options, path: path.concat(key) }, depth);\n              }, \"get\")\n            });\n          }\n          return acc;\n        }\n        const value = obj[key];\n        if (typeof value !== \"function\") {\n          acc[key] = this.instrument(value, { ...options, path: path.concat(key) }, depth);\n          return acc;\n        }\n        if (\"__originalFn__\" in value && typeof value.__originalFn__ === \"function\") {\n          acc[key] = value;\n          return acc;\n        }\n        acc[key] = (...args) => this.track(key, value, obj, args, options);\n        acc[key].__originalFn__ = value;\n        Object.defineProperty(acc[key], \"name\", { value: key, writable: false });\n        if (Object.keys(value).length > 0) {\n          Object.assign(\n            acc[key],\n            this.instrument({ ...value }, { ...options, path: path.concat(key) }, depth)\n          );\n        }\n        return acc;\n      },\n      mutate ? obj : construct(obj)\n    );\n  }\n  // Monkey patch an object method to record calls.\n  // Returns a function that invokes the original function, records the invocation (\"call\") and\n  // returns the original result.\n  track(method, fn, object, args, options) {\n    const storyId = args?.[0]?.__storyId__ || global.__STORYBOOK_PREVIEW__?.selectionStore?.selection?.storyId;\n    const { cursor, ancestors } = this.getState(storyId);\n    this.setState(storyId, { cursor: cursor + 1 });\n    const id = `${ancestors.slice(-1)[0] || storyId} [${cursor}] ${method}`;\n    const { path = [], intercept = false, retain = false } = options;\n    const interceptable = typeof intercept === \"function\" ? intercept(method, path) : intercept;\n    const call = { id, cursor, storyId, ancestors, path, method, args, interceptable, retain };\n    const interceptOrInvoke = interceptable && !ancestors.length ? this.intercept : this.invoke;\n    const result = interceptOrInvoke.call(this, fn, object, call, options);\n    return this.instrument(result, { ...options, mutate: true, path: [{ __callId__: call.id }] });\n  }\n  intercept(fn, object, call, options) {\n    const { chainedCallIds, isDebugging, playUntil } = this.getState(call.storyId);\n    const isChainedUpon = chainedCallIds.has(call.id);\n    if (!isDebugging || isChainedUpon || playUntil) {\n      if (playUntil === call.id) {\n        this.setState(call.storyId, { playUntil: void 0 });\n      }\n      return this.invoke(fn, object, call, options);\n    }\n    return new Promise((resolve) => {\n      this.setState(call.storyId, ({ resolvers }) => ({\n        isLocked: false,\n        resolvers: { ...resolvers, [call.id]: resolve }\n      }));\n    }).then(() => {\n      this.setState(call.storyId, (state) => {\n        const { [call.id]: _, ...resolvers } = state.resolvers;\n        return { isLocked: true, resolvers };\n      });\n      return this.invoke(fn, object, call, options);\n    });\n  }\n  invoke(fn, object, call, options) {\n    const { callRefsByResult, renderPhase } = this.getState(call.storyId);\n    const maximumDepth = 25;\n    const serializeValues = /* @__PURE__ */ __name((value, depth, seen) => {\n      if (seen.includes(value)) {\n        return \"[Circular]\";\n      }\n      seen = [...seen, value];\n      if (depth > maximumDepth) {\n        return \"...\";\n      }\n      if (callRefsByResult.has(value)) {\n        return callRefsByResult.get(value);\n      }\n      if (value instanceof Array) {\n        return value.map((it) => serializeValues(it, ++depth, seen));\n      }\n      if (value instanceof Date) {\n        return { __date__: { value: value.toISOString() } };\n      }\n      if (value instanceof Error) {\n        const { name, message, stack } = value;\n        return { __error__: { name, message, stack } };\n      }\n      if (value instanceof RegExp) {\n        const { flags, source } = value;\n        return { __regexp__: { flags, source } };\n      }\n      if (value instanceof global.window?.HTMLElement) {\n        const { prefix, localName, id, classList, innerText } = value;\n        const classNames = Array.from(classList);\n        return { __element__: { prefix, localName, id, classNames, innerText } };\n      }\n      if (typeof value === \"function\") {\n        return {\n          __function__: { name: \"getMockName\" in value ? value.getMockName() : value.name }\n        };\n      }\n      if (typeof value === \"symbol\") {\n        return { __symbol__: { description: value.description } };\n      }\n      if (typeof value === \"object\" && value?.constructor?.name && value?.constructor?.name !== \"Object\") {\n        return { __class__: { name: value.constructor.name } };\n      }\n      if (Object.prototype.toString.call(value) === \"[object Object]\") {\n        return Object.fromEntries(\n          Object.entries(value).map(([key, val]) => [key, serializeValues(val, ++depth, seen)])\n        );\n      }\n      return value;\n    }, \"serializeValues\");\n    const info = {\n      ...call,\n      args: call.args.map((arg) => serializeValues(arg, 0, []))\n    };\n    call.path.forEach((ref) => {\n      if (ref?.__callId__) {\n        this.setState(call.storyId, ({ chainedCallIds }) => ({\n          chainedCallIds: new Set(Array.from(chainedCallIds).concat(ref.__callId__))\n        }));\n      }\n    });\n    const handleException = /* @__PURE__ */ __name((e) => {\n      if (e instanceof Error) {\n        const { name, message, stack, callId = call.id } = e;\n        const {\n          showDiff = void 0,\n          diff = void 0,\n          actual = void 0,\n          expected = void 0\n        } = e.name === \"AssertionError\" ? processError(e) : e;\n        const exception = { name, message, stack, callId, showDiff, diff, actual, expected };\n        this.update({ ...info, status: \"error\" /* ERROR */, exception });\n        this.setState(call.storyId, (state) => ({\n          callRefsByResult: new Map([\n            ...Array.from(state.callRefsByResult.entries()),\n            [e, { __callId__: call.id, retain: call.retain }]\n          ])\n        }));\n        if (call.ancestors?.length) {\n          if (!Object.prototype.hasOwnProperty.call(e, \"callId\")) {\n            Object.defineProperty(e, \"callId\", { value: call.id });\n          }\n          throw e;\n        }\n      }\n      throw e;\n    }, \"handleException\");\n    try {\n      if (renderPhase === \"played\" && !call.retain) {\n        throw alreadyCompletedException;\n      }\n      const actualArgs = options.getArgs ? options.getArgs(call, this.getState(call.storyId)) : call.args;\n      const finalArgs = actualArgs.map((arg) => {\n        if (typeof arg !== \"function\" || isClass(arg) || Object.keys(arg).length) {\n          return arg;\n        }\n        return (...args) => {\n          const { cursor, ancestors } = this.getState(call.storyId);\n          this.setState(call.storyId, { cursor: 0, ancestors: [...ancestors, call.id] });\n          const restore = /* @__PURE__ */ __name(() => this.setState(call.storyId, { cursor, ancestors }), \"restore\");\n          let willRestore = false;\n          try {\n            const res = arg(...args);\n            if (res instanceof Promise) {\n              willRestore = true;\n              return res.finally(restore);\n            }\n            return res;\n          } finally {\n            if (!willRestore) {\n              restore();\n            }\n          }\n        };\n      });\n      const result = fn.apply(object, finalArgs);\n      if (result && [\"object\", \"function\", \"symbol\"].includes(typeof result)) {\n        this.setState(call.storyId, (state) => ({\n          callRefsByResult: new Map([\n            ...Array.from(state.callRefsByResult.entries()),\n            [result, { __callId__: call.id, retain: call.retain }]\n          ])\n        }));\n      }\n      this.update({\n        ...info,\n        status: result instanceof Promise ? \"active\" /* ACTIVE */ : \"done\" /* DONE */\n      });\n      if (result instanceof Promise) {\n        return result.then((value) => {\n          this.update({ ...info, status: \"done\" /* DONE */ });\n          return value;\n        }, handleException);\n      }\n      return result;\n    } catch (e) {\n      return handleException(e);\n    }\n  }\n  // Sends the call info to the manager and synchronizes the log.\n  update(call) {\n    this.channel?.emit(EVENTS.CALL, call);\n    this.setState(call.storyId, ({ calls }) => {\n      const callsById = calls.concat(call).reduce((a, c) => Object.assign(a, { [c.id]: c }), {});\n      return {\n        // Calls are sorted to ensure parent calls always come before calls in their callback.\n        calls: Object.values(callsById).sort(\n          (a, b) => a.id.localeCompare(b.id, void 0, { numeric: true })\n        )\n      };\n    });\n    this.sync(call.storyId);\n  }\n  // Builds a log of interceptable calls and control states and sends it to the manager.\n  // Uses a 0ms debounce because this might get called many times in one tick.\n  sync(storyId) {\n    const synchronize = /* @__PURE__ */ __name(() => {\n      const { isLocked, isPlaying } = this.getState(storyId);\n      const logItems = this.getLog(storyId);\n      const pausedAt = logItems.filter(({ ancestors }) => !ancestors.length).find((item) => item.status === \"waiting\" /* WAITING */)?.callId;\n      const hasActive = logItems.some((item) => item.status === \"active\" /* ACTIVE */);\n      if (this.detached || isLocked || hasActive || logItems.length === 0) {\n        const controlStates2 = {\n          detached: this.detached,\n          start: false,\n          back: false,\n          goto: false,\n          next: false,\n          end: false\n        };\n        const payload2 = { controlStates: controlStates2, logItems };\n        this.channel?.emit(EVENTS.SYNC, payload2);\n        return;\n      }\n      const hasPrevious = logItems.some(\n        (item) => item.status === \"done\" /* DONE */ || item.status === \"error\" /* ERROR */\n      );\n      const controlStates = {\n        detached: this.detached,\n        start: hasPrevious,\n        back: hasPrevious,\n        goto: true,\n        next: isPlaying,\n        end: isPlaying\n      };\n      const payload = { controlStates, logItems, pausedAt };\n      this.channel?.emit(EVENTS.SYNC, payload);\n    }, \"synchronize\");\n    this.setState(storyId, ({ syncTimeout }) => {\n      clearTimeout(syncTimeout);\n      return { syncTimeout: setTimeout(synchronize, 0) };\n    });\n  }\n};\n__name(_Instrumenter, \"Instrumenter\");\nvar Instrumenter = _Instrumenter;\nfunction instrument(obj, options = {}) {\n  try {\n    let forceInstrument = false;\n    let skipInstrument = false;\n    if (global.window?.location?.search?.includes(\"instrument=true\")) {\n      forceInstrument = true;\n    } else if (global.window?.location?.search?.includes(\"instrument=false\")) {\n      skipInstrument = true;\n    }\n    if (global.window?.parent === global.window && !forceInstrument || skipInstrument) {\n      return obj;\n    }\n    if (global.window && !global.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__) {\n      global.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ = new Instrumenter();\n    }\n    const instrumenter = global.window?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__;\n    return instrumenter.instrument(obj, options);\n  } catch (e) {\n    once.warn(e);\n    return obj;\n  }\n}\n__name(instrument, \"instrument\");\nfunction getPropertyDescriptor(obj, propName) {\n  let target = obj;\n  while (target != null) {\n    const descriptor = Object.getOwnPropertyDescriptor(target, propName);\n    if (descriptor) {\n      return descriptor;\n    }\n    target = Object.getPrototypeOf(target);\n  }\n  return void 0;\n}\n__name(getPropertyDescriptor, \"getPropertyDescriptor\");\nfunction isClass(obj) {\n  if (typeof obj !== \"function\") {\n    return false;\n  }\n  const descriptor = Object.getOwnPropertyDescriptor(obj, \"prototype\");\n  if (!descriptor) {\n    return false;\n  }\n  return !descriptor.writable;\n}\n__name(isClass, \"isClass\");\nexport {\n  CallStates,\n  EVENTS,\n  instrument\n};\n",
      "start": 1762256767098,
      "end": 1762256767138,
      "sourcemaps": null
    },
    {
      "name": "storybook:mock-loader",
      "start": 1762256767138,
      "end": 1762256767138,
      "order": "normal-pre"
    },
    {
      "name": "vite-plugin-svelte",
      "start": 1762256767138,
      "end": 1762256767138,
      "order": "pre"
    },
    {
      "name": "plugin-csf",
      "start": 1762256767138,
      "end": 1762256767138,
      "order": "pre"
    },
    {
      "name": "vite:esbuild",
      "start": 1762256767138,
      "end": 1762256767138,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1762256767138,
      "end": 1762256767138,
      "order": "normal-normal"
    },
    {
      "name": "storybook:mock-loader-preview",
      "start": 1762256767138,
      "end": 1762256767138,
      "order": "normal"
    },
    {
      "name": "storybook:svelte-docgen-plugin",
      "start": 1762256767138,
      "end": 1762256767138,
      "order": "normal"
    },
    {
      "name": "storybook:addon-svelte-csf",
      "start": 1762256767138,
      "end": 1762256767138,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1762256767138,
      "end": 1762256767139,
      "order": "normal-normal"
    },
    {
      "name": "vite:build-html",
      "start": 1762256767139,
      "end": 1762256767139,
      "order": "normal-normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1762256767139,
      "end": 1762256767139,
      "order": "normal-normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1762256767139,
      "end": 1762256767139,
      "order": "normal-normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1762256767139,
      "end": 1762256767139,
      "order": "normal-normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1762256767139,
      "end": 1762256767139,
      "order": "normal-normal"
    },
    {
      "name": "vite-plugin-svelte-module",
      "start": 1762256767139,
      "end": 1762256767139,
      "order": "post"
    },
    {
      "name": "storybook:inject-export-order-plugin",
      "start": 1762256767139,
      "end": 1762256767139,
      "order": "post"
    },
    {
      "name": "storybook:strip-hmr-boundary-plugin",
      "start": 1762256767139,
      "end": 1762256767139,
      "order": "post"
    },
    {
      "name": "storybook:external-globals-plugin",
      "result": "import {\n  CallStates,\n  EVENTS\n} from \"../_browser-chunks/chunk-SN4J4IQ3.js\";\nimport {\n  processError\n} from \"../_browser-chunks/chunk-JVSKG4YS.js\";\nimport {\n  __name\n} from \"../_browser-chunks/chunk-MM7DTO55.js\";\n\n// src/instrumenter/instrumenter.ts\nconst { once } = __STORYBOOK_MODULE_CLIENT_LOGGER__;\nconst {\n  FORCE_REMOUNT,\n  SET_CURRENT_STORY,\n  STORY_RENDER_PHASE_CHANGED\n} = __STORYBOOK_MODULE_CORE_EVENTS__;\nconst { global } = __STORYBOOK_MODULE_GLOBAL__;\n\n// src/instrumenter/preview-api.ts\nvar addons = globalThis.__STORYBOOK_ADDONS_PREVIEW;\n\n// src/instrumenter/instrumenter.ts\nvar alreadyCompletedException = new Error(\n  `This function ran after the play function completed. Did you forget to \\`await\\` it?`\n);\nvar isObject = /* @__PURE__ */ __name((o) => Object.prototype.toString.call(o) === \"[object Object]\", \"isObject\");\nvar isModule = /* @__PURE__ */ __name((o) => Object.prototype.toString.call(o) === \"[object Module]\", \"isModule\");\nvar isInstrumentable = /* @__PURE__ */ __name((o) => {\n  if (!isObject(o) && !isModule(o)) {\n    return false;\n  }\n  if (o.constructor === void 0) {\n    return true;\n  }\n  const proto = o.constructor.prototype;\n  if (!isObject(proto)) {\n    return false;\n  }\n  return true;\n}, \"isInstrumentable\");\nvar construct = /* @__PURE__ */ __name((obj) => {\n  try {\n    return new obj.constructor();\n  } catch {\n    return {};\n  }\n}, \"construct\");\nvar getInitialState = /* @__PURE__ */ __name(() => ({\n  renderPhase: \"preparing\",\n  isDebugging: false,\n  isPlaying: false,\n  isLocked: false,\n  cursor: 0,\n  calls: [],\n  shadowCalls: [],\n  callRefsByResult: /* @__PURE__ */ new Map(),\n  chainedCallIds: /* @__PURE__ */ new Set(),\n  ancestors: [],\n  playUntil: void 0,\n  resolvers: {},\n  syncTimeout: void 0\n}), \"getInitialState\");\nvar getRetainedState = /* @__PURE__ */ __name((state, isDebugging = false) => {\n  const calls = (isDebugging ? state.shadowCalls : state.calls).filter((call) => call.retain);\n  if (!calls.length) {\n    return void 0;\n  }\n  const callRefsByResult = new Map(\n    Array.from(state.callRefsByResult.entries()).filter(([, ref]) => ref.retain)\n  );\n  return { cursor: calls.length, calls, callRefsByResult };\n}, \"getRetainedState\");\nvar _Instrumenter = class _Instrumenter {\n  constructor() {\n    this.detached = false;\n    this.initialized = false;\n    // State is tracked per story to deal with multiple stories on the same canvas (i.e. docs mode)\n    this.state = {};\n    this.loadParentWindowState = /* @__PURE__ */ __name(() => {\n      try {\n        this.state = global.window?.parent?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ || {};\n      } catch {\n        this.detached = true;\n      }\n    }, \"loadParentWindowState\");\n    this.updateParentWindowState = /* @__PURE__ */ __name(() => {\n      try {\n        global.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ = this.state;\n      } catch {\n        this.detached = true;\n      }\n    }, \"updateParentWindowState\");\n    this.loadParentWindowState();\n    const resetState = /* @__PURE__ */ __name(({\n      storyId,\n      renderPhase,\n      isPlaying = true,\n      isDebugging = false\n    }) => {\n      const state = this.getState(storyId);\n      this.setState(storyId, {\n        ...getInitialState(),\n        ...getRetainedState(state, isDebugging),\n        renderPhase: renderPhase || state.renderPhase,\n        shadowCalls: isDebugging ? state.shadowCalls : [],\n        chainedCallIds: isDebugging ? state.chainedCallIds : /* @__PURE__ */ new Set(),\n        playUntil: isDebugging ? state.playUntil : void 0,\n        isPlaying,\n        isDebugging\n      });\n      this.sync(storyId);\n    }, \"resetState\");\n    const start = /* @__PURE__ */ __name((channel) => ({ storyId, playUntil }) => {\n      if (!this.getState(storyId).isDebugging) {\n        this.setState(storyId, ({ calls }) => ({\n          calls: [],\n          shadowCalls: calls.map((call) => ({ ...call, status: \"waiting\" /* WAITING */ })),\n          isDebugging: true\n        }));\n      }\n      const log = this.getLog(storyId);\n      this.setState(storyId, ({ shadowCalls }) => {\n        if (playUntil || !log.length) {\n          return { playUntil };\n        }\n        const firstRowIndex = shadowCalls.findIndex((call) => call.id === log[0].callId);\n        return {\n          playUntil: shadowCalls.slice(0, firstRowIndex).filter((call) => call.interceptable && !call.ancestors?.length).slice(-1)[0]?.id\n        };\n      });\n      channel.emit(FORCE_REMOUNT, { storyId, isDebugging: true });\n    }, \"start\");\n    const back = /* @__PURE__ */ __name((channel) => ({ storyId }) => {\n      const log = this.getLog(storyId).filter((call) => !call.ancestors?.length);\n      const last = log.reduceRight((res, item, index) => {\n        if (res >= 0 || item.status === \"waiting\" /* WAITING */) {\n          return res;\n        }\n        return index;\n      }, -1);\n      start(channel)({ storyId, playUntil: log[last - 1]?.callId });\n    }, \"back\");\n    const goto = /* @__PURE__ */ __name((channel) => ({ storyId, callId }) => {\n      const { calls, shadowCalls, resolvers } = this.getState(storyId);\n      const call = calls.find(({ id }) => id === callId);\n      const shadowCall = shadowCalls.find(({ id }) => id === callId);\n      if (!call && shadowCall && Object.values(resolvers).length > 0) {\n        const nextId = this.getLog(storyId).find((c) => c.status === \"waiting\" /* WAITING */)?.callId;\n        if (shadowCall.id !== nextId) {\n          this.setState(storyId, { playUntil: shadowCall.id });\n        }\n        Object.values(resolvers).forEach((resolve) => resolve());\n      } else {\n        start(channel)({ storyId, playUntil: callId });\n      }\n    }, \"goto\");\n    const next = /* @__PURE__ */ __name((channel) => ({ storyId }) => {\n      const { resolvers } = this.getState(storyId);\n      if (Object.values(resolvers).length > 0) {\n        Object.values(resolvers).forEach((resolve) => resolve());\n      } else {\n        const nextId = this.getLog(storyId).find((c) => c.status === \"waiting\" /* WAITING */)?.callId;\n        if (nextId) {\n          start(channel)({ storyId, playUntil: nextId });\n        } else {\n          end({ storyId });\n        }\n      }\n    }, \"next\");\n    const end = /* @__PURE__ */ __name(({ storyId }) => {\n      this.setState(storyId, { playUntil: void 0, isDebugging: false });\n      Object.values(this.getState(storyId).resolvers).forEach((resolve) => resolve());\n    }, \"end\");\n    const renderPhaseChanged = /* @__PURE__ */ __name(({\n      storyId,\n      newPhase\n    }) => {\n      const { isDebugging } = this.getState(storyId);\n      if (newPhase === \"preparing\" && isDebugging) {\n        return resetState({ storyId, renderPhase: newPhase, isDebugging });\n      } else if (newPhase === \"playing\") {\n        return resetState({ storyId, renderPhase: newPhase, isDebugging });\n      }\n      if (newPhase === \"played\") {\n        this.setState(storyId, {\n          renderPhase: newPhase,\n          isLocked: false,\n          isPlaying: false,\n          isDebugging: false\n        });\n      } else if (newPhase === \"errored\") {\n        this.setState(storyId, {\n          renderPhase: newPhase,\n          isLocked: false,\n          isPlaying: false\n        });\n      } else if (newPhase === \"aborted\") {\n        this.setState(storyId, {\n          renderPhase: newPhase,\n          isLocked: true,\n          isPlaying: false\n        });\n      } else {\n        this.setState(storyId, {\n          renderPhase: newPhase\n        });\n      }\n      this.sync(storyId);\n    }, \"renderPhaseChanged\");\n    if (addons) {\n      addons.ready().then(() => {\n        this.channel = addons.getChannel();\n        this.channel.on(FORCE_REMOUNT, resetState);\n        this.channel.on(STORY_RENDER_PHASE_CHANGED, renderPhaseChanged);\n        this.channel.on(SET_CURRENT_STORY, () => {\n          if (this.initialized) {\n            this.cleanup();\n          } else {\n            this.initialized = true;\n          }\n        });\n        this.channel.on(EVENTS.START, start(this.channel));\n        this.channel.on(EVENTS.BACK, back(this.channel));\n        this.channel.on(EVENTS.GOTO, goto(this.channel));\n        this.channel.on(EVENTS.NEXT, next(this.channel));\n        this.channel.on(EVENTS.END, end);\n      });\n    }\n  }\n  getState(storyId) {\n    return this.state[storyId] || getInitialState();\n  }\n  setState(storyId, update) {\n    if (storyId) {\n      const state = this.getState(storyId);\n      const patch = typeof update === \"function\" ? update(state) : update;\n      this.state = { ...this.state, [storyId]: { ...state, ...patch } };\n      this.updateParentWindowState();\n    }\n  }\n  cleanup() {\n    this.state = Object.entries(this.state).reduce(\n      (acc, [storyId, state]) => {\n        const retainedState = getRetainedState(state);\n        if (!retainedState) {\n          return acc;\n        }\n        acc[storyId] = Object.assign(getInitialState(), retainedState);\n        return acc;\n      },\n      {}\n    );\n    const controlStates = {\n      detached: this.detached,\n      start: false,\n      back: false,\n      goto: false,\n      next: false,\n      end: false\n    };\n    const payload = { controlStates, logItems: [] };\n    this.channel?.emit(EVENTS.SYNC, payload);\n    this.updateParentWindowState();\n  }\n  getLog(storyId) {\n    const { calls, shadowCalls } = this.getState(storyId);\n    const merged = [...shadowCalls];\n    calls.forEach((call, index) => {\n      merged[index] = call;\n    });\n    const seen = /* @__PURE__ */ new Set();\n    return merged.reduceRight((acc, call) => {\n      call.args.forEach((arg) => {\n        if (arg?.__callId__) {\n          seen.add(arg.__callId__);\n        }\n      });\n      call.path.forEach((node) => {\n        if (node.__callId__) {\n          seen.add(node.__callId__);\n        }\n      });\n      if ((call.interceptable || call.exception) && !seen.has(call.id)) {\n        acc.unshift({ callId: call.id, status: call.status, ancestors: call.ancestors });\n        seen.add(call.id);\n      }\n      return acc;\n    }, []);\n  }\n  // Traverses the object structure to recursively patch all function properties.\n  // Returns the original object, or a new object with the same constructor,\n  // depending on whether it should mutate.\n  instrument(obj, options, depth = 0) {\n    if (!isInstrumentable(obj)) {\n      return obj;\n    }\n    const { mutate = false, path = [] } = options;\n    const keys = options.getKeys ? options.getKeys(obj, depth) : Object.keys(obj);\n    depth += 1;\n    return keys.reduce(\n      (acc, key) => {\n        const descriptor = getPropertyDescriptor(obj, key);\n        if (typeof descriptor?.get === \"function\") {\n          if (descriptor.configurable) {\n            const getter = /* @__PURE__ */ __name(() => descriptor?.get?.bind(obj)?.(), \"getter\");\n            Object.defineProperty(acc, key, {\n              get: /* @__PURE__ */ __name(() => {\n                return this.instrument(getter(), { ...options, path: path.concat(key) }, depth);\n              }, \"get\")\n            });\n          }\n          return acc;\n        }\n        const value = obj[key];\n        if (typeof value !== \"function\") {\n          acc[key] = this.instrument(value, { ...options, path: path.concat(key) }, depth);\n          return acc;\n        }\n        if (\"__originalFn__\" in value && typeof value.__originalFn__ === \"function\") {\n          acc[key] = value;\n          return acc;\n        }\n        acc[key] = (...args) => this.track(key, value, obj, args, options);\n        acc[key].__originalFn__ = value;\n        Object.defineProperty(acc[key], \"name\", { value: key, writable: false });\n        if (Object.keys(value).length > 0) {\n          Object.assign(\n            acc[key],\n            this.instrument({ ...value }, { ...options, path: path.concat(key) }, depth)\n          );\n        }\n        return acc;\n      },\n      mutate ? obj : construct(obj)\n    );\n  }\n  // Monkey patch an object method to record calls.\n  // Returns a function that invokes the original function, records the invocation (\"call\") and\n  // returns the original result.\n  track(method, fn, object, args, options) {\n    const storyId = args?.[0]?.__storyId__ || global.__STORYBOOK_PREVIEW__?.selectionStore?.selection?.storyId;\n    const { cursor, ancestors } = this.getState(storyId);\n    this.setState(storyId, { cursor: cursor + 1 });\n    const id = `${ancestors.slice(-1)[0] || storyId} [${cursor}] ${method}`;\n    const { path = [], intercept = false, retain = false } = options;\n    const interceptable = typeof intercept === \"function\" ? intercept(method, path) : intercept;\n    const call = { id, cursor, storyId, ancestors, path, method, args, interceptable, retain };\n    const interceptOrInvoke = interceptable && !ancestors.length ? this.intercept : this.invoke;\n    const result = interceptOrInvoke.call(this, fn, object, call, options);\n    return this.instrument(result, { ...options, mutate: true, path: [{ __callId__: call.id }] });\n  }\n  intercept(fn, object, call, options) {\n    const { chainedCallIds, isDebugging, playUntil } = this.getState(call.storyId);\n    const isChainedUpon = chainedCallIds.has(call.id);\n    if (!isDebugging || isChainedUpon || playUntil) {\n      if (playUntil === call.id) {\n        this.setState(call.storyId, { playUntil: void 0 });\n      }\n      return this.invoke(fn, object, call, options);\n    }\n    return new Promise((resolve) => {\n      this.setState(call.storyId, ({ resolvers }) => ({\n        isLocked: false,\n        resolvers: { ...resolvers, [call.id]: resolve }\n      }));\n    }).then(() => {\n      this.setState(call.storyId, (state) => {\n        const { [call.id]: _, ...resolvers } = state.resolvers;\n        return { isLocked: true, resolvers };\n      });\n      return this.invoke(fn, object, call, options);\n    });\n  }\n  invoke(fn, object, call, options) {\n    const { callRefsByResult, renderPhase } = this.getState(call.storyId);\n    const maximumDepth = 25;\n    const serializeValues = /* @__PURE__ */ __name((value, depth, seen) => {\n      if (seen.includes(value)) {\n        return \"[Circular]\";\n      }\n      seen = [...seen, value];\n      if (depth > maximumDepth) {\n        return \"...\";\n      }\n      if (callRefsByResult.has(value)) {\n        return callRefsByResult.get(value);\n      }\n      if (value instanceof Array) {\n        return value.map((it) => serializeValues(it, ++depth, seen));\n      }\n      if (value instanceof Date) {\n        return { __date__: { value: value.toISOString() } };\n      }\n      if (value instanceof Error) {\n        const { name, message, stack } = value;\n        return { __error__: { name, message, stack } };\n      }\n      if (value instanceof RegExp) {\n        const { flags, source } = value;\n        return { __regexp__: { flags, source } };\n      }\n      if (value instanceof global.window?.HTMLElement) {\n        const { prefix, localName, id, classList, innerText } = value;\n        const classNames = Array.from(classList);\n        return { __element__: { prefix, localName, id, classNames, innerText } };\n      }\n      if (typeof value === \"function\") {\n        return {\n          __function__: { name: \"getMockName\" in value ? value.getMockName() : value.name }\n        };\n      }\n      if (typeof value === \"symbol\") {\n        return { __symbol__: { description: value.description } };\n      }\n      if (typeof value === \"object\" && value?.constructor?.name && value?.constructor?.name !== \"Object\") {\n        return { __class__: { name: value.constructor.name } };\n      }\n      if (Object.prototype.toString.call(value) === \"[object Object]\") {\n        return Object.fromEntries(\n          Object.entries(value).map(([key, val]) => [key, serializeValues(val, ++depth, seen)])\n        );\n      }\n      return value;\n    }, \"serializeValues\");\n    const info = {\n      ...call,\n      args: call.args.map((arg) => serializeValues(arg, 0, []))\n    };\n    call.path.forEach((ref) => {\n      if (ref?.__callId__) {\n        this.setState(call.storyId, ({ chainedCallIds }) => ({\n          chainedCallIds: new Set(Array.from(chainedCallIds).concat(ref.__callId__))\n        }));\n      }\n    });\n    const handleException = /* @__PURE__ */ __name((e) => {\n      if (e instanceof Error) {\n        const { name, message, stack, callId = call.id } = e;\n        const {\n          showDiff = void 0,\n          diff = void 0,\n          actual = void 0,\n          expected = void 0\n        } = e.name === \"AssertionError\" ? processError(e) : e;\n        const exception = { name, message, stack, callId, showDiff, diff, actual, expected };\n        this.update({ ...info, status: \"error\" /* ERROR */, exception });\n        this.setState(call.storyId, (state) => ({\n          callRefsByResult: new Map([\n            ...Array.from(state.callRefsByResult.entries()),\n            [e, { __callId__: call.id, retain: call.retain }]\n          ])\n        }));\n        if (call.ancestors?.length) {\n          if (!Object.prototype.hasOwnProperty.call(e, \"callId\")) {\n            Object.defineProperty(e, \"callId\", { value: call.id });\n          }\n          throw e;\n        }\n      }\n      throw e;\n    }, \"handleException\");\n    try {\n      if (renderPhase === \"played\" && !call.retain) {\n        throw alreadyCompletedException;\n      }\n      const actualArgs = options.getArgs ? options.getArgs(call, this.getState(call.storyId)) : call.args;\n      const finalArgs = actualArgs.map((arg) => {\n        if (typeof arg !== \"function\" || isClass(arg) || Object.keys(arg).length) {\n          return arg;\n        }\n        return (...args) => {\n          const { cursor, ancestors } = this.getState(call.storyId);\n          this.setState(call.storyId, { cursor: 0, ancestors: [...ancestors, call.id] });\n          const restore = /* @__PURE__ */ __name(() => this.setState(call.storyId, { cursor, ancestors }), \"restore\");\n          let willRestore = false;\n          try {\n            const res = arg(...args);\n            if (res instanceof Promise) {\n              willRestore = true;\n              return res.finally(restore);\n            }\n            return res;\n          } finally {\n            if (!willRestore) {\n              restore();\n            }\n          }\n        };\n      });\n      const result = fn.apply(object, finalArgs);\n      if (result && [\"object\", \"function\", \"symbol\"].includes(typeof result)) {\n        this.setState(call.storyId, (state) => ({\n          callRefsByResult: new Map([\n            ...Array.from(state.callRefsByResult.entries()),\n            [result, { __callId__: call.id, retain: call.retain }]\n          ])\n        }));\n      }\n      this.update({\n        ...info,\n        status: result instanceof Promise ? \"active\" /* ACTIVE */ : \"done\" /* DONE */\n      });\n      if (result instanceof Promise) {\n        return result.then((value) => {\n          this.update({ ...info, status: \"done\" /* DONE */ });\n          return value;\n        }, handleException);\n      }\n      return result;\n    } catch (e) {\n      return handleException(e);\n    }\n  }\n  // Sends the call info to the manager and synchronizes the log.\n  update(call) {\n    this.channel?.emit(EVENTS.CALL, call);\n    this.setState(call.storyId, ({ calls }) => {\n      const callsById = calls.concat(call).reduce((a, c) => Object.assign(a, { [c.id]: c }), {});\n      return {\n        // Calls are sorted to ensure parent calls always come before calls in their callback.\n        calls: Object.values(callsById).sort(\n          (a, b) => a.id.localeCompare(b.id, void 0, { numeric: true })\n        )\n      };\n    });\n    this.sync(call.storyId);\n  }\n  // Builds a log of interceptable calls and control states and sends it to the manager.\n  // Uses a 0ms debounce because this might get called many times in one tick.\n  sync(storyId) {\n    const synchronize = /* @__PURE__ */ __name(() => {\n      const { isLocked, isPlaying } = this.getState(storyId);\n      const logItems = this.getLog(storyId);\n      const pausedAt = logItems.filter(({ ancestors }) => !ancestors.length).find((item) => item.status === \"waiting\" /* WAITING */)?.callId;\n      const hasActive = logItems.some((item) => item.status === \"active\" /* ACTIVE */);\n      if (this.detached || isLocked || hasActive || logItems.length === 0) {\n        const controlStates2 = {\n          detached: this.detached,\n          start: false,\n          back: false,\n          goto: false,\n          next: false,\n          end: false\n        };\n        const payload2 = { controlStates: controlStates2, logItems };\n        this.channel?.emit(EVENTS.SYNC, payload2);\n        return;\n      }\n      const hasPrevious = logItems.some(\n        (item) => item.status === \"done\" /* DONE */ || item.status === \"error\" /* ERROR */\n      );\n      const controlStates = {\n        detached: this.detached,\n        start: hasPrevious,\n        back: hasPrevious,\n        goto: true,\n        next: isPlaying,\n        end: isPlaying\n      };\n      const payload = { controlStates, logItems, pausedAt };\n      this.channel?.emit(EVENTS.SYNC, payload);\n    }, \"synchronize\");\n    this.setState(storyId, ({ syncTimeout }) => {\n      clearTimeout(syncTimeout);\n      return { syncTimeout: setTimeout(synchronize, 0) };\n    });\n  }\n};\n__name(_Instrumenter, \"Instrumenter\");\nvar Instrumenter = _Instrumenter;\nfunction instrument(obj, options = {}) {\n  try {\n    let forceInstrument = false;\n    let skipInstrument = false;\n    if (global.window?.location?.search?.includes(\"instrument=true\")) {\n      forceInstrument = true;\n    } else if (global.window?.location?.search?.includes(\"instrument=false\")) {\n      skipInstrument = true;\n    }\n    if (global.window?.parent === global.window && !forceInstrument || skipInstrument) {\n      return obj;\n    }\n    if (global.window && !global.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__) {\n      global.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ = new Instrumenter();\n    }\n    const instrumenter = global.window?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__;\n    return instrumenter.instrument(obj, options);\n  } catch (e) {\n    once.warn(e);\n    return obj;\n  }\n}\n__name(instrument, \"instrument\");\nfunction getPropertyDescriptor(obj, propName) {\n  let target = obj;\n  while (target != null) {\n    const descriptor = Object.getOwnPropertyDescriptor(target, propName);\n    if (descriptor) {\n      return descriptor;\n    }\n    target = Object.getPrototypeOf(target);\n  }\n  return void 0;\n}\n__name(getPropertyDescriptor, \"getPropertyDescriptor\");\nfunction isClass(obj) {\n  if (typeof obj !== \"function\") {\n    return false;\n  }\n  const descriptor = Object.getOwnPropertyDescriptor(obj, \"prototype\");\n  if (!descriptor) {\n    return false;\n  }\n  return !descriptor.writable;\n}\n__name(isClass, \"isClass\");\nexport {\n  CallStates,\n  EVENTS,\n  instrument\n};\n",
      "start": 1762256767139,
      "end": 1762256767140,
      "order": "post",
      "sourcemaps": null
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1762256767140,
      "end": 1762256767140,
      "order": "normal-normal"
    },
    {
      "name": "vite:reporter",
      "start": 1762256767140,
      "end": 1762256767140,
      "order": "normal"
    }
  ]
}
