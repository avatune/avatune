{
  "resolvedId": "/Users/teimurgasanov/Projects/avatune/node_modules/@vitest/mocker/dist/chunk-mocker.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { mockObject } from './index.js';\nimport { M as MockerRegistry, R as RedirectedModule, A as AutomockedModule } from './chunk-registry.js';\nimport { e as extname, j as join } from './chunk-pathe.M-eThtNZ.js';\n\n// src/index.ts\nvar f = {\n  reset: [0, 0],\n  bold: [1, 22, \"\\x1B[22m\\x1B[1m\"],\n  dim: [2, 22, \"\\x1B[22m\\x1B[2m\"],\n  italic: [3, 23],\n  underline: [4, 24],\n  inverse: [7, 27],\n  hidden: [8, 28],\n  strikethrough: [9, 29],\n  black: [30, 39],\n  red: [31, 39],\n  green: [32, 39],\n  yellow: [33, 39],\n  blue: [34, 39],\n  magenta: [35, 39],\n  cyan: [36, 39],\n  white: [37, 39],\n  gray: [90, 39],\n  bgBlack: [40, 49],\n  bgRed: [41, 49],\n  bgGreen: [42, 49],\n  bgYellow: [43, 49],\n  bgBlue: [44, 49],\n  bgMagenta: [45, 49],\n  bgCyan: [46, 49],\n  bgWhite: [47, 49],\n  blackBright: [90, 39],\n  redBright: [91, 39],\n  greenBright: [92, 39],\n  yellowBright: [93, 39],\n  blueBright: [94, 39],\n  magentaBright: [95, 39],\n  cyanBright: [96, 39],\n  whiteBright: [97, 39],\n  bgBlackBright: [100, 49],\n  bgRedBright: [101, 49],\n  bgGreenBright: [102, 49],\n  bgYellowBright: [103, 49],\n  bgBlueBright: [104, 49],\n  bgMagentaBright: [105, 49],\n  bgCyanBright: [106, 49],\n  bgWhiteBright: [107, 49]\n}, h = Object.entries(f);\nfunction a(n) {\n  return String(n);\n}\na.open = \"\";\na.close = \"\";\nfunction C(n = false) {\n  let e = typeof process != \"undefined\" ? process : void 0, i = (e == null ? void 0 : e.env) || {}, g = (e == null ? void 0 : e.argv) || [];\n  return !(\"NO_COLOR\" in i || g.includes(\"--no-color\")) && (\"FORCE_COLOR\" in i || g.includes(\"--color\") || (e == null ? void 0 : e.platform) === \"win32\" || n && i.TERM !== \"dumb\" || \"CI\" in i) || typeof window != \"undefined\" && !!window.chrome;\n}\nfunction p(n = false) {\n  let e = C(n), i = (r, t, c, o) => {\n    let l = \"\", s = 0;\n    do\n      l += r.substring(s, o) + c, s = o + t.length, o = r.indexOf(t, s);\n    while (~o);\n    return l + r.substring(s);\n  }, g = (r, t, c = r) => {\n    let o = (l) => {\n      let s = String(l), b = s.indexOf(t, r.length);\n      return ~b ? r + i(s, t, c, b) + t : r + s + t;\n    };\n    return o.open = r, o.close = t, o;\n  }, u = {\n    isColorSupported: e\n  }, d = (r) => `\\x1B[${r}m`;\n  for (let [r, t] of h)\n    u[r] = e ? g(\n      d(t[0]),\n      d(t[1]),\n      t[2]\n    ) : a;\n  return u;\n}\n\np();\n\nfunction _mergeNamespaces(n, m) {\n\tm.forEach(function(e) {\n\t\te && typeof e !== \"string\" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n\t\t\tif (k !== \"default\" && !(k in n)) {\n\t\t\t\tvar d = Object.getOwnPropertyDescriptor(e, k);\n\t\t\t\tObject.defineProperty(n, k, d.get ? d : {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tget: function() {\n\t\t\t\t\t\treturn e[k];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t});\n\treturn Object.freeze(n);\n}\nfunction getDefaultExportFromCjs(x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar reactIs$1 = { exports: {} };\nvar reactIs_production = {};\n/**\n* @license React\n* react-is.production.js\n*\n* Copyright (c) Meta Platforms, Inc. and affiliates.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\nvar hasRequiredReactIs_production;\nfunction requireReactIs_production() {\n\tif (hasRequiredReactIs_production) return reactIs_production;\n\thasRequiredReactIs_production = 1;\n\tvar REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"), REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"), REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"), REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"), REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n\tvar REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"), REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"), REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"), REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"), REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"), REACT_MEMO_TYPE = Symbol.for(\"react.memo\"), REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"), REACT_VIEW_TRANSITION_TYPE = Symbol.for(\"react.view_transition\"), REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n\tfunction typeOf(object) {\n\t\tif (\"object\" === typeof object && null !== object) {\n\t\t\tvar $$typeof = object.$$typeof;\n\t\t\tswitch ($$typeof) {\n\t\t\t\tcase REACT_ELEMENT_TYPE: switch (object = object.type, object) {\n\t\t\t\t\tcase REACT_FRAGMENT_TYPE:\n\t\t\t\t\tcase REACT_PROFILER_TYPE:\n\t\t\t\t\tcase REACT_STRICT_MODE_TYPE:\n\t\t\t\t\tcase REACT_SUSPENSE_TYPE:\n\t\t\t\t\tcase REACT_SUSPENSE_LIST_TYPE:\n\t\t\t\t\tcase REACT_VIEW_TRANSITION_TYPE: return object;\n\t\t\t\t\tdefault: switch (object = object && object.$$typeof, object) {\n\t\t\t\t\t\tcase REACT_CONTEXT_TYPE:\n\t\t\t\t\t\tcase REACT_FORWARD_REF_TYPE:\n\t\t\t\t\t\tcase REACT_LAZY_TYPE:\n\t\t\t\t\t\tcase REACT_MEMO_TYPE: return object;\n\t\t\t\t\t\tcase REACT_CONSUMER_TYPE: return object;\n\t\t\t\t\t\tdefault: return $$typeof;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcase REACT_PORTAL_TYPE: return $$typeof;\n\t\t\t}\n\t\t}\n\t}\n\treactIs_production.ContextConsumer = REACT_CONSUMER_TYPE;\n\treactIs_production.ContextProvider = REACT_CONTEXT_TYPE;\n\treactIs_production.Element = REACT_ELEMENT_TYPE;\n\treactIs_production.ForwardRef = REACT_FORWARD_REF_TYPE;\n\treactIs_production.Fragment = REACT_FRAGMENT_TYPE;\n\treactIs_production.Lazy = REACT_LAZY_TYPE;\n\treactIs_production.Memo = REACT_MEMO_TYPE;\n\treactIs_production.Portal = REACT_PORTAL_TYPE;\n\treactIs_production.Profiler = REACT_PROFILER_TYPE;\n\treactIs_production.StrictMode = REACT_STRICT_MODE_TYPE;\n\treactIs_production.Suspense = REACT_SUSPENSE_TYPE;\n\treactIs_production.SuspenseList = REACT_SUSPENSE_LIST_TYPE;\n\treactIs_production.isContextConsumer = function(object) {\n\t\treturn typeOf(object) === REACT_CONSUMER_TYPE;\n\t};\n\treactIs_production.isContextProvider = function(object) {\n\t\treturn typeOf(object) === REACT_CONTEXT_TYPE;\n\t};\n\treactIs_production.isElement = function(object) {\n\t\treturn \"object\" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;\n\t};\n\treactIs_production.isForwardRef = function(object) {\n\t\treturn typeOf(object) === REACT_FORWARD_REF_TYPE;\n\t};\n\treactIs_production.isFragment = function(object) {\n\t\treturn typeOf(object) === REACT_FRAGMENT_TYPE;\n\t};\n\treactIs_production.isLazy = function(object) {\n\t\treturn typeOf(object) === REACT_LAZY_TYPE;\n\t};\n\treactIs_production.isMemo = function(object) {\n\t\treturn typeOf(object) === REACT_MEMO_TYPE;\n\t};\n\treactIs_production.isPortal = function(object) {\n\t\treturn typeOf(object) === REACT_PORTAL_TYPE;\n\t};\n\treactIs_production.isProfiler = function(object) {\n\t\treturn typeOf(object) === REACT_PROFILER_TYPE;\n\t};\n\treactIs_production.isStrictMode = function(object) {\n\t\treturn typeOf(object) === REACT_STRICT_MODE_TYPE;\n\t};\n\treactIs_production.isSuspense = function(object) {\n\t\treturn typeOf(object) === REACT_SUSPENSE_TYPE;\n\t};\n\treactIs_production.isSuspenseList = function(object) {\n\t\treturn typeOf(object) === REACT_SUSPENSE_LIST_TYPE;\n\t};\n\treactIs_production.isValidElementType = function(type) {\n\t\treturn \"string\" === typeof type || \"function\" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || \"object\" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? true : false;\n\t};\n\treactIs_production.typeOf = typeOf;\n\treturn reactIs_production;\n}\nvar reactIs_development$1 = {};\n/**\n* @license React\n* react-is.development.js\n*\n* Copyright (c) Meta Platforms, Inc. and affiliates.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\nvar hasRequiredReactIs_development$1;\nfunction requireReactIs_development$1() {\n\tif (hasRequiredReactIs_development$1) return reactIs_development$1;\n\thasRequiredReactIs_development$1 = 1;\n\t\"production\" !== process.env.NODE_ENV && function() {\n\t\tfunction typeOf(object) {\n\t\t\tif (\"object\" === typeof object && null !== object) {\n\t\t\t\tvar $$typeof = object.$$typeof;\n\t\t\t\tswitch ($$typeof) {\n\t\t\t\t\tcase REACT_ELEMENT_TYPE: switch (object = object.type, object) {\n\t\t\t\t\t\tcase REACT_FRAGMENT_TYPE:\n\t\t\t\t\t\tcase REACT_PROFILER_TYPE:\n\t\t\t\t\t\tcase REACT_STRICT_MODE_TYPE:\n\t\t\t\t\t\tcase REACT_SUSPENSE_TYPE:\n\t\t\t\t\t\tcase REACT_SUSPENSE_LIST_TYPE:\n\t\t\t\t\t\tcase REACT_VIEW_TRANSITION_TYPE: return object;\n\t\t\t\t\t\tdefault: switch (object = object && object.$$typeof, object) {\n\t\t\t\t\t\t\tcase REACT_CONTEXT_TYPE:\n\t\t\t\t\t\t\tcase REACT_FORWARD_REF_TYPE:\n\t\t\t\t\t\t\tcase REACT_LAZY_TYPE:\n\t\t\t\t\t\t\tcase REACT_MEMO_TYPE: return object;\n\t\t\t\t\t\t\tcase REACT_CONSUMER_TYPE: return object;\n\t\t\t\t\t\t\tdefault: return $$typeof;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcase REACT_PORTAL_TYPE: return $$typeof;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"), REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"), REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"), REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"), REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n\t\tvar REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"), REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"), REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"), REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"), REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"), REACT_MEMO_TYPE = Symbol.for(\"react.memo\"), REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"), REACT_VIEW_TRANSITION_TYPE = Symbol.for(\"react.view_transition\"), REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n\t\treactIs_development$1.ContextConsumer = REACT_CONSUMER_TYPE;\n\t\treactIs_development$1.ContextProvider = REACT_CONTEXT_TYPE;\n\t\treactIs_development$1.Element = REACT_ELEMENT_TYPE;\n\t\treactIs_development$1.ForwardRef = REACT_FORWARD_REF_TYPE;\n\t\treactIs_development$1.Fragment = REACT_FRAGMENT_TYPE;\n\t\treactIs_development$1.Lazy = REACT_LAZY_TYPE;\n\t\treactIs_development$1.Memo = REACT_MEMO_TYPE;\n\t\treactIs_development$1.Portal = REACT_PORTAL_TYPE;\n\t\treactIs_development$1.Profiler = REACT_PROFILER_TYPE;\n\t\treactIs_development$1.StrictMode = REACT_STRICT_MODE_TYPE;\n\t\treactIs_development$1.Suspense = REACT_SUSPENSE_TYPE;\n\t\treactIs_development$1.SuspenseList = REACT_SUSPENSE_LIST_TYPE;\n\t\treactIs_development$1.isContextConsumer = function(object) {\n\t\t\treturn typeOf(object) === REACT_CONSUMER_TYPE;\n\t\t};\n\t\treactIs_development$1.isContextProvider = function(object) {\n\t\t\treturn typeOf(object) === REACT_CONTEXT_TYPE;\n\t\t};\n\t\treactIs_development$1.isElement = function(object) {\n\t\t\treturn \"object\" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;\n\t\t};\n\t\treactIs_development$1.isForwardRef = function(object) {\n\t\t\treturn typeOf(object) === REACT_FORWARD_REF_TYPE;\n\t\t};\n\t\treactIs_development$1.isFragment = function(object) {\n\t\t\treturn typeOf(object) === REACT_FRAGMENT_TYPE;\n\t\t};\n\t\treactIs_development$1.isLazy = function(object) {\n\t\t\treturn typeOf(object) === REACT_LAZY_TYPE;\n\t\t};\n\t\treactIs_development$1.isMemo = function(object) {\n\t\t\treturn typeOf(object) === REACT_MEMO_TYPE;\n\t\t};\n\t\treactIs_development$1.isPortal = function(object) {\n\t\t\treturn typeOf(object) === REACT_PORTAL_TYPE;\n\t\t};\n\t\treactIs_development$1.isProfiler = function(object) {\n\t\t\treturn typeOf(object) === REACT_PROFILER_TYPE;\n\t\t};\n\t\treactIs_development$1.isStrictMode = function(object) {\n\t\t\treturn typeOf(object) === REACT_STRICT_MODE_TYPE;\n\t\t};\n\t\treactIs_development$1.isSuspense = function(object) {\n\t\t\treturn typeOf(object) === REACT_SUSPENSE_TYPE;\n\t\t};\n\t\treactIs_development$1.isSuspenseList = function(object) {\n\t\t\treturn typeOf(object) === REACT_SUSPENSE_LIST_TYPE;\n\t\t};\n\t\treactIs_development$1.isValidElementType = function(type) {\n\t\t\treturn \"string\" === typeof type || \"function\" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || \"object\" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? true : false;\n\t\t};\n\t\treactIs_development$1.typeOf = typeOf;\n\t}();\n\treturn reactIs_development$1;\n}\nvar hasRequiredReactIs$1;\nfunction requireReactIs$1() {\n\tif (hasRequiredReactIs$1) return reactIs$1.exports;\n\thasRequiredReactIs$1 = 1;\n\tif (process.env.NODE_ENV === \"production\") {\n\t\treactIs$1.exports = requireReactIs_production();\n\t} else {\n\t\treactIs$1.exports = requireReactIs_development$1();\n\t}\n\treturn reactIs$1.exports;\n}\nvar reactIsExports$1 = requireReactIs$1();\nvar index$1 = /* @__PURE__ */ getDefaultExportFromCjs(reactIsExports$1);\nvar ReactIs19 = /* @__PURE__ */ _mergeNamespaces({\n\t__proto__: null,\n\tdefault: index$1\n}, [reactIsExports$1]);\nvar reactIs = { exports: {} };\nvar reactIs_production_min = {};\n/**\n* @license React\n* react-is.production.min.js\n*\n* Copyright (c) Facebook, Inc. and its affiliates.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\nvar hasRequiredReactIs_production_min;\nfunction requireReactIs_production_min() {\n\tif (hasRequiredReactIs_production_min) return reactIs_production_min;\n\thasRequiredReactIs_production_min = 1;\n\tvar b = Symbol.for(\"react.element\"), c = Symbol.for(\"react.portal\"), d = Symbol.for(\"react.fragment\"), e = Symbol.for(\"react.strict_mode\"), f = Symbol.for(\"react.profiler\"), g = Symbol.for(\"react.provider\"), h = Symbol.for(\"react.context\"), k = Symbol.for(\"react.server_context\"), l = Symbol.for(\"react.forward_ref\"), m = Symbol.for(\"react.suspense\"), n = Symbol.for(\"react.suspense_list\"), p = Symbol.for(\"react.memo\"), q = Symbol.for(\"react.lazy\"), t = Symbol.for(\"react.offscreen\"), u;\n\tu = Symbol.for(\"react.module.reference\");\n\tfunction v(a) {\n\t\tif (\"object\" === typeof a && null !== a) {\n\t\t\tvar r = a.$$typeof;\n\t\t\tswitch (r) {\n\t\t\t\tcase b: switch (a = a.type, a) {\n\t\t\t\t\tcase d:\n\t\t\t\t\tcase f:\n\t\t\t\t\tcase e:\n\t\t\t\t\tcase m:\n\t\t\t\t\tcase n: return a;\n\t\t\t\t\tdefault: switch (a = a && a.$$typeof, a) {\n\t\t\t\t\t\tcase k:\n\t\t\t\t\t\tcase h:\n\t\t\t\t\t\tcase l:\n\t\t\t\t\t\tcase q:\n\t\t\t\t\t\tcase p:\n\t\t\t\t\t\tcase g: return a;\n\t\t\t\t\t\tdefault: return r;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcase c: return r;\n\t\t\t}\n\t\t}\n\t}\n\treactIs_production_min.ContextConsumer = h;\n\treactIs_production_min.ContextProvider = g;\n\treactIs_production_min.Element = b;\n\treactIs_production_min.ForwardRef = l;\n\treactIs_production_min.Fragment = d;\n\treactIs_production_min.Lazy = q;\n\treactIs_production_min.Memo = p;\n\treactIs_production_min.Portal = c;\n\treactIs_production_min.Profiler = f;\n\treactIs_production_min.StrictMode = e;\n\treactIs_production_min.Suspense = m;\n\treactIs_production_min.SuspenseList = n;\n\treactIs_production_min.isAsyncMode = function() {\n\t\treturn false;\n\t};\n\treactIs_production_min.isConcurrentMode = function() {\n\t\treturn false;\n\t};\n\treactIs_production_min.isContextConsumer = function(a) {\n\t\treturn v(a) === h;\n\t};\n\treactIs_production_min.isContextProvider = function(a) {\n\t\treturn v(a) === g;\n\t};\n\treactIs_production_min.isElement = function(a) {\n\t\treturn \"object\" === typeof a && null !== a && a.$$typeof === b;\n\t};\n\treactIs_production_min.isForwardRef = function(a) {\n\t\treturn v(a) === l;\n\t};\n\treactIs_production_min.isFragment = function(a) {\n\t\treturn v(a) === d;\n\t};\n\treactIs_production_min.isLazy = function(a) {\n\t\treturn v(a) === q;\n\t};\n\treactIs_production_min.isMemo = function(a) {\n\t\treturn v(a) === p;\n\t};\n\treactIs_production_min.isPortal = function(a) {\n\t\treturn v(a) === c;\n\t};\n\treactIs_production_min.isProfiler = function(a) {\n\t\treturn v(a) === f;\n\t};\n\treactIs_production_min.isStrictMode = function(a) {\n\t\treturn v(a) === e;\n\t};\n\treactIs_production_min.isSuspense = function(a) {\n\t\treturn v(a) === m;\n\t};\n\treactIs_production_min.isSuspenseList = function(a) {\n\t\treturn v(a) === n;\n\t};\n\treactIs_production_min.isValidElementType = function(a) {\n\t\treturn \"string\" === typeof a || \"function\" === typeof a || a === d || a === f || a === e || a === m || a === n || a === t || \"object\" === typeof a && null !== a && (a.$$typeof === q || a.$$typeof === p || a.$$typeof === g || a.$$typeof === h || a.$$typeof === l || a.$$typeof === u || void 0 !== a.getModuleId) ? true : false;\n\t};\n\treactIs_production_min.typeOf = v;\n\treturn reactIs_production_min;\n}\nvar reactIs_development = {};\n/**\n* @license React\n* react-is.development.js\n*\n* Copyright (c) Facebook, Inc. and its affiliates.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\nvar hasRequiredReactIs_development;\nfunction requireReactIs_development() {\n\tif (hasRequiredReactIs_development) return reactIs_development;\n\thasRequiredReactIs_development = 1;\n\tif (process.env.NODE_ENV !== \"production\") {\n\t\t(function() {\n\t\t\t// ATTENTION\n\t\t\t// When adding new symbols to this file,\n\t\t\t// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n\t\t\t// The Symbol used to tag the ReactElement-like types.\n\t\t\tvar REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n\t\t\tvar REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n\t\t\tvar REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n\t\t\tvar REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n\t\t\tvar REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n\t\t\tvar REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n\t\t\tvar REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n\t\t\tvar REACT_SERVER_CONTEXT_TYPE = Symbol.for(\"react.server_context\");\n\t\t\tvar REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n\t\t\tvar REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n\t\t\tvar REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n\t\t\tvar REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n\t\t\tvar REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n\t\t\tvar REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n\t\t\t// -----------------------------------------------------------------------------\n\t\t\tvar enableScopeAPI = false;\n\t\t\tvar enableCacheElement = false;\n\t\t\tvar enableTransitionTracing = false;\n\t\t\tvar enableLegacyHidden = false;\n\t\t\t// stuff. Intended to enable React core members to more easily debug scheduling\n\t\t\t// issues in DEV builds.\n\t\t\tvar enableDebugTracing = false;\n\t\t\tvar REACT_MODULE_REFERENCE;\n\t\t\t{\n\t\t\t\tREACT_MODULE_REFERENCE = Symbol.for(\"react.module.reference\");\n\t\t\t}\n\t\t\tfunction isValidElementType(type) {\n\t\t\t\tif (typeof type === \"string\" || typeof type === \"function\") {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (typeof type === \"object\" && type !== null) {\n\t\t\t\t\tif (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfunction typeOf(object) {\n\t\t\t\tif (typeof object === \"object\" && object !== null) {\n\t\t\t\t\tvar $$typeof = object.$$typeof;\n\t\t\t\t\tswitch ($$typeof) {\n\t\t\t\t\t\tcase REACT_ELEMENT_TYPE:\n\t\t\t\t\t\t\tvar type = object.type;\n\t\t\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\t\t\tcase REACT_FRAGMENT_TYPE:\n\t\t\t\t\t\t\t\tcase REACT_PROFILER_TYPE:\n\t\t\t\t\t\t\t\tcase REACT_STRICT_MODE_TYPE:\n\t\t\t\t\t\t\t\tcase REACT_SUSPENSE_TYPE:\n\t\t\t\t\t\t\t\tcase REACT_SUSPENSE_LIST_TYPE: return type;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tvar $$typeofType = type && type.$$typeof;\n\t\t\t\t\t\t\t\t\tswitch ($$typeofType) {\n\t\t\t\t\t\t\t\t\t\tcase REACT_SERVER_CONTEXT_TYPE:\n\t\t\t\t\t\t\t\t\t\tcase REACT_CONTEXT_TYPE:\n\t\t\t\t\t\t\t\t\t\tcase REACT_FORWARD_REF_TYPE:\n\t\t\t\t\t\t\t\t\t\tcase REACT_LAZY_TYPE:\n\t\t\t\t\t\t\t\t\t\tcase REACT_MEMO_TYPE:\n\t\t\t\t\t\t\t\t\t\tcase REACT_PROVIDER_TYPE: return $$typeofType;\n\t\t\t\t\t\t\t\t\t\tdefault: return $$typeof;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REACT_PORTAL_TYPE: return $$typeof;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tvar ContextConsumer = REACT_CONTEXT_TYPE;\n\t\t\tvar ContextProvider = REACT_PROVIDER_TYPE;\n\t\t\tvar Element = REACT_ELEMENT_TYPE;\n\t\t\tvar ForwardRef = REACT_FORWARD_REF_TYPE;\n\t\t\tvar Fragment = REACT_FRAGMENT_TYPE;\n\t\t\tvar Lazy = REACT_LAZY_TYPE;\n\t\t\tvar Memo = REACT_MEMO_TYPE;\n\t\t\tvar Portal = REACT_PORTAL_TYPE;\n\t\t\tvar Profiler = REACT_PROFILER_TYPE;\n\t\t\tvar StrictMode = REACT_STRICT_MODE_TYPE;\n\t\t\tvar Suspense = REACT_SUSPENSE_TYPE;\n\t\t\tvar SuspenseList = REACT_SUSPENSE_LIST_TYPE;\n\t\t\tvar hasWarnedAboutDeprecatedIsAsyncMode = false;\n\t\t\tvar hasWarnedAboutDeprecatedIsConcurrentMode = false;\n\t\t\tfunction isAsyncMode(object) {\n\t\t\t\t{\n\t\t\t\t\tif (!hasWarnedAboutDeprecatedIsAsyncMode) {\n\t\t\t\t\t\thasWarnedAboutDeprecatedIsAsyncMode = true;\n\t\t\t\t\t\tconsole[\"warn\"](\"The ReactIs.isAsyncMode() alias has been deprecated, \" + \"and will be removed in React 18+.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfunction isConcurrentMode(object) {\n\t\t\t\t{\n\t\t\t\t\tif (!hasWarnedAboutDeprecatedIsConcurrentMode) {\n\t\t\t\t\t\thasWarnedAboutDeprecatedIsConcurrentMode = true;\n\t\t\t\t\t\tconsole[\"warn\"](\"The ReactIs.isConcurrentMode() alias has been deprecated, \" + \"and will be removed in React 18+.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfunction isContextConsumer(object) {\n\t\t\t\treturn typeOf(object) === REACT_CONTEXT_TYPE;\n\t\t\t}\n\t\t\tfunction isContextProvider(object) {\n\t\t\t\treturn typeOf(object) === REACT_PROVIDER_TYPE;\n\t\t\t}\n\t\t\tfunction isElement(object) {\n\t\t\t\treturn typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n\t\t\t}\n\t\t\tfunction isForwardRef(object) {\n\t\t\t\treturn typeOf(object) === REACT_FORWARD_REF_TYPE;\n\t\t\t}\n\t\t\tfunction isFragment(object) {\n\t\t\t\treturn typeOf(object) === REACT_FRAGMENT_TYPE;\n\t\t\t}\n\t\t\tfunction isLazy(object) {\n\t\t\t\treturn typeOf(object) === REACT_LAZY_TYPE;\n\t\t\t}\n\t\t\tfunction isMemo(object) {\n\t\t\t\treturn typeOf(object) === REACT_MEMO_TYPE;\n\t\t\t}\n\t\t\tfunction isPortal(object) {\n\t\t\t\treturn typeOf(object) === REACT_PORTAL_TYPE;\n\t\t\t}\n\t\t\tfunction isProfiler(object) {\n\t\t\t\treturn typeOf(object) === REACT_PROFILER_TYPE;\n\t\t\t}\n\t\t\tfunction isStrictMode(object) {\n\t\t\t\treturn typeOf(object) === REACT_STRICT_MODE_TYPE;\n\t\t\t}\n\t\t\tfunction isSuspense(object) {\n\t\t\t\treturn typeOf(object) === REACT_SUSPENSE_TYPE;\n\t\t\t}\n\t\t\tfunction isSuspenseList(object) {\n\t\t\t\treturn typeOf(object) === REACT_SUSPENSE_LIST_TYPE;\n\t\t\t}\n\t\t\treactIs_development.ContextConsumer = ContextConsumer;\n\t\t\treactIs_development.ContextProvider = ContextProvider;\n\t\t\treactIs_development.Element = Element;\n\t\t\treactIs_development.ForwardRef = ForwardRef;\n\t\t\treactIs_development.Fragment = Fragment;\n\t\t\treactIs_development.Lazy = Lazy;\n\t\t\treactIs_development.Memo = Memo;\n\t\t\treactIs_development.Portal = Portal;\n\t\t\treactIs_development.Profiler = Profiler;\n\t\t\treactIs_development.StrictMode = StrictMode;\n\t\t\treactIs_development.Suspense = Suspense;\n\t\t\treactIs_development.SuspenseList = SuspenseList;\n\t\t\treactIs_development.isAsyncMode = isAsyncMode;\n\t\t\treactIs_development.isConcurrentMode = isConcurrentMode;\n\t\t\treactIs_development.isContextConsumer = isContextConsumer;\n\t\t\treactIs_development.isContextProvider = isContextProvider;\n\t\t\treactIs_development.isElement = isElement;\n\t\t\treactIs_development.isForwardRef = isForwardRef;\n\t\t\treactIs_development.isFragment = isFragment;\n\t\t\treactIs_development.isLazy = isLazy;\n\t\t\treactIs_development.isMemo = isMemo;\n\t\t\treactIs_development.isPortal = isPortal;\n\t\t\treactIs_development.isProfiler = isProfiler;\n\t\t\treactIs_development.isStrictMode = isStrictMode;\n\t\t\treactIs_development.isSuspense = isSuspense;\n\t\t\treactIs_development.isSuspenseList = isSuspenseList;\n\t\t\treactIs_development.isValidElementType = isValidElementType;\n\t\t\treactIs_development.typeOf = typeOf;\n\t\t})();\n\t}\n\treturn reactIs_development;\n}\nvar hasRequiredReactIs;\nfunction requireReactIs() {\n\tif (hasRequiredReactIs) return reactIs.exports;\n\thasRequiredReactIs = 1;\n\tif (process.env.NODE_ENV === \"production\") {\n\t\treactIs.exports = requireReactIs_production_min();\n\t} else {\n\t\treactIs.exports = requireReactIs_development();\n\t}\n\treturn reactIs.exports;\n}\nvar reactIsExports = requireReactIs();\nvar index = /* @__PURE__ */ getDefaultExportFromCjs(reactIsExports);\nvar ReactIs18 = /* @__PURE__ */ _mergeNamespaces({\n\t__proto__: null,\n\tdefault: index\n}, [reactIsExports]);\nconst reactIsMethods = [\n\t\"isAsyncMode\",\n\t\"isConcurrentMode\",\n\t\"isContextConsumer\",\n\t\"isContextProvider\",\n\t\"isElement\",\n\t\"isForwardRef\",\n\t\"isFragment\",\n\t\"isLazy\",\n\t\"isMemo\",\n\t\"isPortal\",\n\t\"isProfiler\",\n\t\"isStrictMode\",\n\t\"isSuspense\",\n\t\"isSuspenseList\",\n\t\"isValidElementType\"\n];\nObject.fromEntries(reactIsMethods.map((m) => [m, (v) => ReactIs18[m](v) || ReactIs19[m](v)]));\n\nlet getPromiseValue = () => 'Promise{â€¦}';\ntry {\n    // @ts-ignore\n    const { getPromiseDetails, kPending, kRejected } = process.binding('util');\n    if (Array.isArray(getPromiseDetails(Promise.resolve()))) {\n        getPromiseValue = (value, options) => {\n            const [state, innerValue] = getPromiseDetails(value);\n            if (state === kPending) {\n                return 'Promise{<pending>}';\n            }\n            return `Promise${state === kRejected ? '!' : ''}{${options.inspect(innerValue, options)}}`;\n        };\n    }\n}\ncatch (notNode) {\n    /* ignore */\n}\n\n/**\n* Get original stacktrace without source map support the most performant way.\n* - Create only 1 stack frame.\n* - Rewrite prepareStackTrace to bypass \"support-stack-trace\" (usually takes ~250ms).\n*/\nfunction createSimpleStackTrace(options) {\n\tconst { message = \"$$stack trace error\", stackTraceLimit = 1 } = options || {};\n\tconst limit = Error.stackTraceLimit;\n\tconst prepareStackTrace = Error.prepareStackTrace;\n\tError.stackTraceLimit = stackTraceLimit;\n\tError.prepareStackTrace = (e) => e.stack;\n\tconst err = new Error(message);\n\tconst stackTrace = err.stack || \"\";\n\tError.prepareStackTrace = prepareStackTrace;\n\tError.stackTraceLimit = limit;\n\treturn stackTrace;\n}\n\nvar jsTokens_1;\nvar hasRequiredJsTokens;\nfunction requireJsTokens() {\n\tif (hasRequiredJsTokens) return jsTokens_1;\n\thasRequiredJsTokens = 1;\n\t// Copyright 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023 Simon Lydell\n\t// License: MIT.\n\tvar Identifier, JSXIdentifier, JSXPunctuator, JSXString, JSXText, KeywordsWithExpressionAfter, KeywordsWithNoLineTerminatorAfter, LineTerminatorSequence, MultiLineComment, Newline, NumericLiteral, Punctuator, RegularExpressionLiteral, SingleLineComment, StringLiteral, Template, TokensNotPrecedingObjectLiteral, TokensPrecedingExpression, WhiteSpace;\n\tRegularExpressionLiteral = /\\/(?![*\\/])(?:\\[(?:(?![\\]\\\\]).|\\\\.)*\\]|(?![\\/\\\\]).|\\\\.)*(\\/[$_\\u200C\\u200D\\p{ID_Continue}]*|\\\\)?/uy;\n\tPunctuator = /--|\\+\\+|=>|\\.{3}|\\??\\.(?!\\d)|(?:&&|\\|\\||\\?\\?|[+\\-%&|^]|\\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\\/(?![\\/*]))=?|[?~,:;[\\](){}]/y;\n\tIdentifier = /(\\x23?)(?=[$_\\p{ID_Start}\\\\])(?:[$_\\u200C\\u200D\\p{ID_Continue}]|\\\\u[\\da-fA-F]{4}|\\\\u\\{[\\da-fA-F]+\\})+/uy;\n\tStringLiteral = /(['\"])(?:(?!\\1)[^\\\\\\n\\r]|\\\\(?:\\r\\n|[^]))*(\\1)?/y;\n\tNumericLiteral = /(?:0[xX][\\da-fA-F](?:_?[\\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\\d)*n|(?:(?:0(?!\\d)|0\\d*[89]\\d*|[1-9](?:_?\\d)*)(?:\\.(?:\\d(?:_?\\d)*)?)?|\\.\\d(?:_?\\d)*)(?:[eE][+-]?\\d(?:_?\\d)*)?|0[0-7]+/y;\n\tTemplate = /[`}](?:[^`\\\\$]|\\\\[^]|\\$(?!\\{))*(`|\\$\\{)?/y;\n\tWhiteSpace = /[\\t\\v\\f\\ufeff\\p{Zs}]+/uy;\n\tLineTerminatorSequence = /\\r?\\n|[\\r\\u2028\\u2029]/y;\n\tMultiLineComment = /\\/\\*(?:[^*]|\\*(?!\\/))*(\\*\\/)?/y;\n\tSingleLineComment = /\\/\\/.*/y;\n\tJSXPunctuator = /[<>.:={}]|\\/(?![\\/*])/y;\n\tJSXIdentifier = /[$_\\p{ID_Start}][$_\\u200C\\u200D\\p{ID_Continue}-]*/uy;\n\tJSXString = /(['\"])(?:(?!\\1)[^])*(\\1)?/y;\n\tJSXText = /[^<>{}]+/y;\n\tTokensPrecedingExpression = /^(?:[\\/+-]|\\.{3}|\\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/;\n\tTokensNotPrecedingObjectLiteral = /^(?:=>|[;\\]){}]|else|\\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/;\n\tKeywordsWithExpressionAfter = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/;\n\tKeywordsWithNoLineTerminatorAfter = /^(?:return|throw|yield)$/;\n\tNewline = RegExp(LineTerminatorSequence.source);\n\tjsTokens_1 = function* (input, { jsx = false } = {}) {\n\t\tvar braces, firstCodePoint, isExpression, lastIndex, lastSignificantToken, length, match, mode, nextLastIndex, nextLastSignificantToken, parenNesting, postfixIncDec, punctuator, stack;\n\t\t({length} = input);\n\t\tlastIndex = 0;\n\t\tlastSignificantToken = \"\";\n\t\tstack = [{ tag: \"JS\" }];\n\t\tbraces = [];\n\t\tparenNesting = 0;\n\t\tpostfixIncDec = false;\n\t\twhile (lastIndex < length) {\n\t\t\tmode = stack[stack.length - 1];\n\t\t\tswitch (mode.tag) {\n\t\t\t\tcase \"JS\":\n\t\t\t\tcase \"JSNonExpressionParen\":\n\t\t\t\tcase \"InterpolationInTemplate\":\n\t\t\t\tcase \"InterpolationInJSX\":\n\t\t\t\t\tif (input[lastIndex] === \"/\" && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {\n\t\t\t\t\t\tRegularExpressionLiteral.lastIndex = lastIndex;\n\t\t\t\t\t\tif (match = RegularExpressionLiteral.exec(input)) {\n\t\t\t\t\t\t\tlastIndex = RegularExpressionLiteral.lastIndex;\n\t\t\t\t\t\t\tlastSignificantToken = match[0];\n\t\t\t\t\t\t\tpostfixIncDec = true;\n\t\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\t\ttype: \"RegularExpressionLiteral\",\n\t\t\t\t\t\t\t\tvalue: match[0],\n\t\t\t\t\t\t\t\tclosed: match[1] !== void 0 && match[1] !== \"\\\\\"\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tPunctuator.lastIndex = lastIndex;\n\t\t\t\t\tif (match = Punctuator.exec(input)) {\n\t\t\t\t\t\tpunctuator = match[0];\n\t\t\t\t\t\tnextLastIndex = Punctuator.lastIndex;\n\t\t\t\t\t\tnextLastSignificantToken = punctuator;\n\t\t\t\t\t\tswitch (punctuator) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tif (lastSignificantToken === \"?NonExpressionParenKeyword\") {\n\t\t\t\t\t\t\t\t\tstack.push({\n\t\t\t\t\t\t\t\t\t\ttag: \"JSNonExpressionParen\",\n\t\t\t\t\t\t\t\t\t\tnesting: parenNesting\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tparenNesting++;\n\t\t\t\t\t\t\t\tpostfixIncDec = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenNesting--;\n\t\t\t\t\t\t\t\tpostfixIncDec = true;\n\t\t\t\t\t\t\t\tif (mode.tag === \"JSNonExpressionParen\" && parenNesting === mode.nesting) {\n\t\t\t\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\t\t\t\tnextLastSignificantToken = \"?NonExpressionParenEnd\";\n\t\t\t\t\t\t\t\t\tpostfixIncDec = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"{\":\n\t\t\t\t\t\t\t\tPunctuator.lastIndex = 0;\n\t\t\t\t\t\t\t\tisExpression = !TokensNotPrecedingObjectLiteral.test(lastSignificantToken) && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken));\n\t\t\t\t\t\t\t\tbraces.push(isExpression);\n\t\t\t\t\t\t\t\tpostfixIncDec = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"}\":\n\t\t\t\t\t\t\t\tswitch (mode.tag) {\n\t\t\t\t\t\t\t\t\tcase \"InterpolationInTemplate\":\n\t\t\t\t\t\t\t\t\t\tif (braces.length === mode.nesting) {\n\t\t\t\t\t\t\t\t\t\t\tTemplate.lastIndex = lastIndex;\n\t\t\t\t\t\t\t\t\t\t\tmatch = Template.exec(input);\n\t\t\t\t\t\t\t\t\t\t\tlastIndex = Template.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\tlastSignificantToken = match[0];\n\t\t\t\t\t\t\t\t\t\t\tif (match[1] === \"${\") {\n\t\t\t\t\t\t\t\t\t\t\t\tlastSignificantToken = \"?InterpolationInTemplate\";\n\t\t\t\t\t\t\t\t\t\t\t\tpostfixIncDec = false;\n\t\t\t\t\t\t\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"TemplateMiddle\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: match[0]\n\t\t\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\t\t\t\t\t\t\tpostfixIncDec = true;\n\t\t\t\t\t\t\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"TemplateTail\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: match[0],\n\t\t\t\t\t\t\t\t\t\t\t\t\tclosed: match[1] === \"`\"\n\t\t\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"InterpolationInJSX\": if (braces.length === mode.nesting) {\n\t\t\t\t\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\t\t\t\t\tlastIndex += 1;\n\t\t\t\t\t\t\t\t\t\tlastSignificantToken = \"}\";\n\t\t\t\t\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"JSXPunctuator\",\n\t\t\t\t\t\t\t\t\t\t\tvalue: \"}\"\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tpostfixIncDec = braces.pop();\n\t\t\t\t\t\t\t\tnextLastSignificantToken = postfixIncDec ? \"?ExpressionBraceEnd\" : \"}\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"]\":\n\t\t\t\t\t\t\t\tpostfixIncDec = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"++\":\n\t\t\t\t\t\t\tcase \"--\":\n\t\t\t\t\t\t\t\tnextLastSignificantToken = postfixIncDec ? \"?PostfixIncDec\" : \"?UnaryIncDec\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"<\":\n\t\t\t\t\t\t\t\tif (jsx && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {\n\t\t\t\t\t\t\t\t\tstack.push({ tag: \"JSXTag\" });\n\t\t\t\t\t\t\t\t\tlastIndex += 1;\n\t\t\t\t\t\t\t\t\tlastSignificantToken = \"<\";\n\t\t\t\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\t\t\t\ttype: \"JSXPunctuator\",\n\t\t\t\t\t\t\t\t\t\tvalue: punctuator\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tpostfixIncDec = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault: postfixIncDec = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastIndex = nextLastIndex;\n\t\t\t\t\t\tlastSignificantToken = nextLastSignificantToken;\n\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\ttype: \"Punctuator\",\n\t\t\t\t\t\t\tvalue: punctuator\n\t\t\t\t\t\t};\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tIdentifier.lastIndex = lastIndex;\n\t\t\t\t\tif (match = Identifier.exec(input)) {\n\t\t\t\t\t\tlastIndex = Identifier.lastIndex;\n\t\t\t\t\t\tnextLastSignificantToken = match[0];\n\t\t\t\t\t\tswitch (match[0]) {\n\t\t\t\t\t\t\tcase \"for\":\n\t\t\t\t\t\t\tcase \"if\":\n\t\t\t\t\t\t\tcase \"while\":\n\t\t\t\t\t\t\tcase \"with\": if (lastSignificantToken !== \".\" && lastSignificantToken !== \"?.\") {\n\t\t\t\t\t\t\t\tnextLastSignificantToken = \"?NonExpressionParenKeyword\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastSignificantToken = nextLastSignificantToken;\n\t\t\t\t\t\tpostfixIncDec = !KeywordsWithExpressionAfter.test(match[0]);\n\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\ttype: match[1] === \"#\" ? \"PrivateIdentifier\" : \"IdentifierName\",\n\t\t\t\t\t\t\tvalue: match[0]\n\t\t\t\t\t\t};\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tStringLiteral.lastIndex = lastIndex;\n\t\t\t\t\tif (match = StringLiteral.exec(input)) {\n\t\t\t\t\t\tlastIndex = StringLiteral.lastIndex;\n\t\t\t\t\t\tlastSignificantToken = match[0];\n\t\t\t\t\t\tpostfixIncDec = true;\n\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\ttype: \"StringLiteral\",\n\t\t\t\t\t\t\tvalue: match[0],\n\t\t\t\t\t\t\tclosed: match[2] !== void 0\n\t\t\t\t\t\t};\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tNumericLiteral.lastIndex = lastIndex;\n\t\t\t\t\tif (match = NumericLiteral.exec(input)) {\n\t\t\t\t\t\tlastIndex = NumericLiteral.lastIndex;\n\t\t\t\t\t\tlastSignificantToken = match[0];\n\t\t\t\t\t\tpostfixIncDec = true;\n\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\ttype: \"NumericLiteral\",\n\t\t\t\t\t\t\tvalue: match[0]\n\t\t\t\t\t\t};\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tTemplate.lastIndex = lastIndex;\n\t\t\t\t\tif (match = Template.exec(input)) {\n\t\t\t\t\t\tlastIndex = Template.lastIndex;\n\t\t\t\t\t\tlastSignificantToken = match[0];\n\t\t\t\t\t\tif (match[1] === \"${\") {\n\t\t\t\t\t\t\tlastSignificantToken = \"?InterpolationInTemplate\";\n\t\t\t\t\t\t\tstack.push({\n\t\t\t\t\t\t\t\ttag: \"InterpolationInTemplate\",\n\t\t\t\t\t\t\t\tnesting: braces.length\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tpostfixIncDec = false;\n\t\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\t\ttype: \"TemplateHead\",\n\t\t\t\t\t\t\t\tvalue: match[0]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpostfixIncDec = true;\n\t\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\t\ttype: \"NoSubstitutionTemplate\",\n\t\t\t\t\t\t\t\tvalue: match[0],\n\t\t\t\t\t\t\t\tclosed: match[1] === \"`\"\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"JSXTag\":\n\t\t\t\tcase \"JSXTagEnd\":\n\t\t\t\t\tJSXPunctuator.lastIndex = lastIndex;\n\t\t\t\t\tif (match = JSXPunctuator.exec(input)) {\n\t\t\t\t\t\tlastIndex = JSXPunctuator.lastIndex;\n\t\t\t\t\t\tnextLastSignificantToken = match[0];\n\t\t\t\t\t\tswitch (match[0]) {\n\t\t\t\t\t\t\tcase \"<\":\n\t\t\t\t\t\t\t\tstack.push({ tag: \"JSXTag\" });\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \">\":\n\t\t\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\t\t\tif (lastSignificantToken === \"/\" || mode.tag === \"JSXTagEnd\") {\n\t\t\t\t\t\t\t\t\tnextLastSignificantToken = \"?JSX\";\n\t\t\t\t\t\t\t\t\tpostfixIncDec = true;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tstack.push({ tag: \"JSXChildren\" });\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"{\":\n\t\t\t\t\t\t\t\tstack.push({\n\t\t\t\t\t\t\t\t\ttag: \"InterpolationInJSX\",\n\t\t\t\t\t\t\t\t\tnesting: braces.length\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tnextLastSignificantToken = \"?InterpolationInJSX\";\n\t\t\t\t\t\t\t\tpostfixIncDec = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"/\": if (lastSignificantToken === \"<\") {\n\t\t\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\t\t\tif (stack[stack.length - 1].tag === \"JSXChildren\") {\n\t\t\t\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tstack.push({ tag: \"JSXTagEnd\" });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastSignificantToken = nextLastSignificantToken;\n\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\ttype: \"JSXPunctuator\",\n\t\t\t\t\t\t\tvalue: match[0]\n\t\t\t\t\t\t};\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tJSXIdentifier.lastIndex = lastIndex;\n\t\t\t\t\tif (match = JSXIdentifier.exec(input)) {\n\t\t\t\t\t\tlastIndex = JSXIdentifier.lastIndex;\n\t\t\t\t\t\tlastSignificantToken = match[0];\n\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\ttype: \"JSXIdentifier\",\n\t\t\t\t\t\t\tvalue: match[0]\n\t\t\t\t\t\t};\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tJSXString.lastIndex = lastIndex;\n\t\t\t\t\tif (match = JSXString.exec(input)) {\n\t\t\t\t\t\tlastIndex = JSXString.lastIndex;\n\t\t\t\t\t\tlastSignificantToken = match[0];\n\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\ttype: \"JSXString\",\n\t\t\t\t\t\t\tvalue: match[0],\n\t\t\t\t\t\t\tclosed: match[2] !== void 0\n\t\t\t\t\t\t};\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"JSXChildren\":\n\t\t\t\t\tJSXText.lastIndex = lastIndex;\n\t\t\t\t\tif (match = JSXText.exec(input)) {\n\t\t\t\t\t\tlastIndex = JSXText.lastIndex;\n\t\t\t\t\t\tlastSignificantToken = match[0];\n\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\ttype: \"JSXText\",\n\t\t\t\t\t\t\tvalue: match[0]\n\t\t\t\t\t\t};\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tswitch (input[lastIndex]) {\n\t\t\t\t\t\tcase \"<\":\n\t\t\t\t\t\t\tstack.push({ tag: \"JSXTag\" });\n\t\t\t\t\t\t\tlastIndex++;\n\t\t\t\t\t\t\tlastSignificantToken = \"<\";\n\t\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\t\ttype: \"JSXPunctuator\",\n\t\t\t\t\t\t\t\tvalue: \"<\"\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tcase \"{\":\n\t\t\t\t\t\t\tstack.push({\n\t\t\t\t\t\t\t\ttag: \"InterpolationInJSX\",\n\t\t\t\t\t\t\t\tnesting: braces.length\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tlastIndex++;\n\t\t\t\t\t\t\tlastSignificantToken = \"?InterpolationInJSX\";\n\t\t\t\t\t\t\tpostfixIncDec = false;\n\t\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\t\ttype: \"JSXPunctuator\",\n\t\t\t\t\t\t\t\tvalue: \"{\"\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tWhiteSpace.lastIndex = lastIndex;\n\t\t\tif (match = WhiteSpace.exec(input)) {\n\t\t\t\tlastIndex = WhiteSpace.lastIndex;\n\t\t\t\tyield {\n\t\t\t\t\ttype: \"WhiteSpace\",\n\t\t\t\t\tvalue: match[0]\n\t\t\t\t};\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tLineTerminatorSequence.lastIndex = lastIndex;\n\t\t\tif (match = LineTerminatorSequence.exec(input)) {\n\t\t\t\tlastIndex = LineTerminatorSequence.lastIndex;\n\t\t\t\tpostfixIncDec = false;\n\t\t\t\tif (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {\n\t\t\t\t\tlastSignificantToken = \"?NoLineTerminatorHere\";\n\t\t\t\t}\n\t\t\t\tyield {\n\t\t\t\t\ttype: \"LineTerminatorSequence\",\n\t\t\t\t\tvalue: match[0]\n\t\t\t\t};\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tMultiLineComment.lastIndex = lastIndex;\n\t\t\tif (match = MultiLineComment.exec(input)) {\n\t\t\t\tlastIndex = MultiLineComment.lastIndex;\n\t\t\t\tif (Newline.test(match[0])) {\n\t\t\t\t\tpostfixIncDec = false;\n\t\t\t\t\tif (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {\n\t\t\t\t\t\tlastSignificantToken = \"?NoLineTerminatorHere\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tyield {\n\t\t\t\t\ttype: \"MultiLineComment\",\n\t\t\t\t\tvalue: match[0],\n\t\t\t\t\tclosed: match[1] !== void 0\n\t\t\t\t};\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSingleLineComment.lastIndex = lastIndex;\n\t\t\tif (match = SingleLineComment.exec(input)) {\n\t\t\t\tlastIndex = SingleLineComment.lastIndex;\n\t\t\t\tpostfixIncDec = false;\n\t\t\t\tyield {\n\t\t\t\t\ttype: \"SingleLineComment\",\n\t\t\t\t\tvalue: match[0]\n\t\t\t\t};\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfirstCodePoint = String.fromCodePoint(input.codePointAt(lastIndex));\n\t\t\tlastIndex += firstCodePoint.length;\n\t\t\tlastSignificantToken = firstCodePoint;\n\t\t\tpostfixIncDec = false;\n\t\t\tyield {\n\t\t\t\ttype: mode.tag.startsWith(\"JSX\") ? \"JSXInvalid\" : \"Invalid\",\n\t\t\t\tvalue: firstCodePoint\n\t\t\t};\n\t\t}\n\t\treturn void 0;\n\t};\n\treturn jsTokens_1;\n}\nrequireJsTokens();\n// src/index.ts\nvar reservedWords = {\n\tkeyword: [\n\t\t\"break\",\n\t\t\"case\",\n\t\t\"catch\",\n\t\t\"continue\",\n\t\t\"debugger\",\n\t\t\"default\",\n\t\t\"do\",\n\t\t\"else\",\n\t\t\"finally\",\n\t\t\"for\",\n\t\t\"function\",\n\t\t\"if\",\n\t\t\"return\",\n\t\t\"switch\",\n\t\t\"throw\",\n\t\t\"try\",\n\t\t\"var\",\n\t\t\"const\",\n\t\t\"while\",\n\t\t\"with\",\n\t\t\"new\",\n\t\t\"this\",\n\t\t\"super\",\n\t\t\"class\",\n\t\t\"extends\",\n\t\t\"export\",\n\t\t\"import\",\n\t\t\"null\",\n\t\t\"true\",\n\t\t\"false\",\n\t\t\"in\",\n\t\t\"instanceof\",\n\t\t\"typeof\",\n\t\t\"void\",\n\t\t\"delete\"\n\t],\n\tstrict: [\n\t\t\"implements\",\n\t\t\"interface\",\n\t\t\"let\",\n\t\t\"package\",\n\t\t\"private\",\n\t\t\"protected\",\n\t\t\"public\",\n\t\t\"static\",\n\t\t\"yield\"\n\t]\n}; new Set(reservedWords.keyword); new Set(reservedWords.strict);\n\nconst chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nconst intToChar = new Uint8Array(64);\nconst charToInt = new Uint8Array(128);\nfor (let i = 0; i < chars.length; i++) {\n\tconst c = chars.charCodeAt(i);\n\tintToChar[i] = c;\n\tcharToInt[c] = i;\n}\nvar UrlType;\n(function(UrlType) {\n\tUrlType[UrlType[\"Empty\"] = 1] = \"Empty\";\n\tUrlType[UrlType[\"Hash\"] = 2] = \"Hash\";\n\tUrlType[UrlType[\"Query\"] = 3] = \"Query\";\n\tUrlType[UrlType[\"RelativePath\"] = 4] = \"RelativePath\";\n\tUrlType[UrlType[\"AbsolutePath\"] = 5] = \"AbsolutePath\";\n\tUrlType[UrlType[\"SchemeRelative\"] = 6] = \"SchemeRelative\";\n\tUrlType[UrlType[\"Absolute\"] = 7] = \"Absolute\";\n})(UrlType || (UrlType = {}));\nconst _DRIVE_LETTER_START_RE = /^[A-Za-z]:\\//;\nfunction normalizeWindowsPath(input = \"\") {\n\tif (!input) {\n\t\treturn input;\n\t}\n\treturn input.replace(/\\\\/g, \"/\").replace(_DRIVE_LETTER_START_RE, (r) => r.toUpperCase());\n}\nconst _IS_ABSOLUTE_RE = /^[/\\\\](?![/\\\\])|^[/\\\\]{2}(?!\\.)|^[A-Za-z]:[/\\\\]/;\nfunction cwd() {\n\tif (typeof process !== \"undefined\" && typeof process.cwd === \"function\") {\n\t\treturn process.cwd().replace(/\\\\/g, \"/\");\n\t}\n\treturn \"/\";\n}\nconst resolve = function(...arguments_) {\n\targuments_ = arguments_.map((argument) => normalizeWindowsPath(argument));\n\tlet resolvedPath = \"\";\n\tlet resolvedAbsolute = false;\n\tfor (let index = arguments_.length - 1; index >= -1 && !resolvedAbsolute; index--) {\n\t\tconst path = index >= 0 ? arguments_[index] : cwd();\n\t\tif (!path || path.length === 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tresolvedPath = `${path}/${resolvedPath}`;\n\t\tresolvedAbsolute = isAbsolute(path);\n\t}\n\tresolvedPath = normalizeString(resolvedPath, !resolvedAbsolute);\n\tif (resolvedAbsolute && !isAbsolute(resolvedPath)) {\n\t\treturn `/${resolvedPath}`;\n\t}\n\treturn resolvedPath.length > 0 ? resolvedPath : \".\";\n};\nfunction normalizeString(path, allowAboveRoot) {\n\tlet res = \"\";\n\tlet lastSegmentLength = 0;\n\tlet lastSlash = -1;\n\tlet dots = 0;\n\tlet char = null;\n\tfor (let index = 0; index <= path.length; ++index) {\n\t\tif (index < path.length) {\n\t\t\tchar = path[index];\n\t\t} else if (char === \"/\") {\n\t\t\tbreak;\n\t\t} else {\n\t\t\tchar = \"/\";\n\t\t}\n\t\tif (char === \"/\") {\n\t\t\tif (lastSlash === index - 1 || dots === 1);\n\t\t\telse if (dots === 2) {\n\t\t\t\tif (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== \".\" || res[res.length - 2] !== \".\") {\n\t\t\t\t\tif (res.length > 2) {\n\t\t\t\t\t\tconst lastSlashIndex = res.lastIndexOf(\"/\");\n\t\t\t\t\t\tif (lastSlashIndex === -1) {\n\t\t\t\t\t\t\tres = \"\";\n\t\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tres = res.slice(0, lastSlashIndex);\n\t\t\t\t\t\t\tlastSegmentLength = res.length - 1 - res.lastIndexOf(\"/\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastSlash = index;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (res.length > 0) {\n\t\t\t\t\t\tres = \"\";\n\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\tlastSlash = index;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (allowAboveRoot) {\n\t\t\t\t\tres += res.length > 0 ? \"/..\" : \"..\";\n\t\t\t\t\tlastSegmentLength = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (res.length > 0) {\n\t\t\t\t\tres += `/${path.slice(lastSlash + 1, index)}`;\n\t\t\t\t} else {\n\t\t\t\t\tres = path.slice(lastSlash + 1, index);\n\t\t\t\t}\n\t\t\t\tlastSegmentLength = index - lastSlash - 1;\n\t\t\t}\n\t\t\tlastSlash = index;\n\t\t\tdots = 0;\n\t\t} else if (char === \".\" && dots !== -1) {\n\t\t\t++dots;\n\t\t} else {\n\t\t\tdots = -1;\n\t\t}\n\t}\n\treturn res;\n}\nconst isAbsolute = function(p) {\n\treturn _IS_ABSOLUTE_RE.test(p);\n};\nconst CHROME_IE_STACK_REGEXP = /^\\s*at .*(?:\\S:\\d+|\\(native\\))/m;\nconst SAFARI_NATIVE_CODE_REGEXP = /^(?:eval@)?(?:\\[native code\\])?$/;\nfunction extractLocation(urlLike) {\n\t// Fail-fast but return locations like \"(native)\"\n\tif (!urlLike.includes(\":\")) {\n\t\treturn [urlLike];\n\t}\n\tconst regExp = /(.+?)(?::(\\d+))?(?::(\\d+))?$/;\n\tconst parts = regExp.exec(urlLike.replace(/^\\(|\\)$/g, \"\"));\n\tif (!parts) {\n\t\treturn [urlLike];\n\t}\n\tlet url = parts[1];\n\tif (url.startsWith(\"async \")) {\n\t\turl = url.slice(6);\n\t}\n\tif (url.startsWith(\"http:\") || url.startsWith(\"https:\")) {\n\t\tconst urlObj = new URL(url);\n\t\turlObj.searchParams.delete(\"import\");\n\t\turlObj.searchParams.delete(\"browserv\");\n\t\turl = urlObj.pathname + urlObj.hash + urlObj.search;\n\t}\n\tif (url.startsWith(\"/@fs/\")) {\n\t\tconst isWindows = /^\\/@fs\\/[a-zA-Z]:\\//.test(url);\n\t\turl = url.slice(isWindows ? 5 : 4);\n\t}\n\treturn [\n\t\turl,\n\t\tparts[2] || undefined,\n\t\tparts[3] || undefined\n\t];\n}\nfunction parseSingleFFOrSafariStack(raw) {\n\tlet line = raw.trim();\n\tif (SAFARI_NATIVE_CODE_REGEXP.test(line)) {\n\t\treturn null;\n\t}\n\tif (line.includes(\" > eval\")) {\n\t\tline = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g, \":$1\");\n\t}\n\tif (!line.includes(\"@\") && !line.includes(\":\")) {\n\t\treturn null;\n\t}\n\t// eslint-disable-next-line regexp/no-super-linear-backtracking, regexp/optimal-quantifier-concatenation\n\tconst functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(@)/;\n\tconst matches = line.match(functionNameRegex);\n\tconst functionName = matches && matches[1] ? matches[1] : undefined;\n\tconst [url, lineNumber, columnNumber] = extractLocation(line.replace(functionNameRegex, \"\"));\n\tif (!url || !lineNumber || !columnNumber) {\n\t\treturn null;\n\t}\n\treturn {\n\t\tfile: url,\n\t\tmethod: functionName || \"\",\n\t\tline: Number.parseInt(lineNumber),\n\t\tcolumn: Number.parseInt(columnNumber)\n\t};\n}\nfunction parseSingleStack(raw) {\n\tconst line = raw.trim();\n\tif (!CHROME_IE_STACK_REGEXP.test(line)) {\n\t\treturn parseSingleFFOrSafariStack(line);\n\t}\n\treturn parseSingleV8Stack(line);\n}\n// Based on https://github.com/stacktracejs/error-stack-parser\n// Credit to stacktracejs\nfunction parseSingleV8Stack(raw) {\n\tlet line = raw.trim();\n\tif (!CHROME_IE_STACK_REGEXP.test(line)) {\n\t\treturn null;\n\t}\n\tif (line.includes(\"(eval \")) {\n\t\tline = line.replace(/eval code/g, \"eval\").replace(/(\\(eval at [^()]*)|(,.*$)/g, \"\");\n\t}\n\tlet sanitizedLine = line.replace(/^\\s+/, \"\").replace(/\\(eval code/g, \"(\").replace(/^.*?\\s+/, \"\");\n\t// capture and preserve the parenthesized location \"(/foo/my bar.js:12:87)\" in\n\t// case it has spaces in it, as the string is split on \\s+ later on\n\tconst location = sanitizedLine.match(/ (\\(.+\\)$)/);\n\t// remove the parenthesized location from the line, if it was matched\n\tsanitizedLine = location ? sanitizedLine.replace(location[0], \"\") : sanitizedLine;\n\t// if a location was matched, pass it to extractLocation() otherwise pass all sanitizedLine\n\t// because this line doesn't have function name\n\tconst [url, lineNumber, columnNumber] = extractLocation(location ? location[1] : sanitizedLine);\n\tlet method = location && sanitizedLine || \"\";\n\tlet file = url && [\"eval\", \"<anonymous>\"].includes(url) ? undefined : url;\n\tif (!file || !lineNumber || !columnNumber) {\n\t\treturn null;\n\t}\n\tif (method.startsWith(\"async \")) {\n\t\tmethod = method.slice(6);\n\t}\n\tif (file.startsWith(\"file://\")) {\n\t\tfile = file.slice(7);\n\t}\n\t// normalize Windows path (\\ -> /)\n\tfile = file.startsWith(\"node:\") || file.startsWith(\"internal:\") ? file : resolve(file);\n\tif (method) {\n\t\tmethod = method.replace(/__vite_ssr_import_\\d+__\\./g, \"\");\n\t}\n\treturn {\n\t\tmethod,\n\t\tfile,\n\t\tline: Number.parseInt(lineNumber),\n\t\tcolumn: Number.parseInt(columnNumber)\n\t};\n}\n\nfunction createCompilerHints(options) {\n\tconst globalThisAccessor = (options === null || options === void 0 ? void 0 : options.globalThisKey) || \"__vitest_mocker__\";\n\tfunction _mocker() {\n\t\t// @ts-expect-error injected by the plugin\n\t\treturn typeof globalThis[globalThisAccessor] !== \"undefined\" ? globalThis[globalThisAccessor] : new Proxy({}, { get(_, name) {\n\t\t\tthrow new Error(\"Vitest mocker was not initialized in this environment. \" + `vi.${String(name)}() is forbidden.`);\n\t\t} });\n\t}\n\treturn {\n\t\thoisted(factory) {\n\t\t\tif (typeof factory !== \"function\") {\n\t\t\t\tthrow new TypeError(`vi.hoisted() expects a function, but received a ${typeof factory}`);\n\t\t\t}\n\t\t\treturn factory();\n\t\t},\n\t\tmock(path, factory) {\n\t\t\tif (typeof path !== \"string\") {\n\t\t\t\tthrow new TypeError(`vi.mock() expects a string path, but received a ${typeof path}`);\n\t\t\t}\n\t\t\tconst importer = getImporter(\"mock\");\n\t\t\t_mocker().queueMock(path, importer, typeof factory === \"function\" ? () => factory(() => _mocker().importActual(path, importer)) : factory);\n\t\t},\n\t\tunmock(path) {\n\t\t\tif (typeof path !== \"string\") {\n\t\t\t\tthrow new TypeError(`vi.unmock() expects a string path, but received a ${typeof path}`);\n\t\t\t}\n\t\t\t_mocker().queueUnmock(path, getImporter(\"unmock\"));\n\t\t},\n\t\tdoMock(path, factory) {\n\t\t\tif (typeof path !== \"string\") {\n\t\t\t\tthrow new TypeError(`vi.doMock() expects a string path, but received a ${typeof path}`);\n\t\t\t}\n\t\t\tconst importer = getImporter(\"doMock\");\n\t\t\t_mocker().queueMock(path, importer, typeof factory === \"function\" ? () => factory(() => _mocker().importActual(path, importer)) : factory);\n\t\t},\n\t\tdoUnmock(path) {\n\t\t\tif (typeof path !== \"string\") {\n\t\t\t\tthrow new TypeError(`vi.doUnmock() expects a string path, but received a ${typeof path}`);\n\t\t\t}\n\t\t\t_mocker().queueUnmock(path, getImporter(\"doUnmock\"));\n\t\t},\n\t\tasync importActual(path) {\n\t\t\treturn _mocker().importActual(path, getImporter(\"importActual\"));\n\t\t},\n\t\tasync importMock(path) {\n\t\t\treturn _mocker().importMock(path, getImporter(\"importMock\"));\n\t\t}\n\t};\n}\nfunction getImporter(name) {\n\tconst stackTrace = /* @__PURE__ */ createSimpleStackTrace({ stackTraceLimit: 5 });\n\tconst stackArray = stackTrace.split(\"\\n\");\n\t// if there is no message in a stack trace, use the item - 1\n\tconst importerStackIndex = stackArray.findIndex((stack) => {\n\t\treturn stack.includes(` at Object.${name}`) || stack.includes(`${name}@`);\n\t});\n\tconst stack = /* @__PURE__ */ parseSingleStack(stackArray[importerStackIndex + 1]);\n\treturn (stack === null || stack === void 0 ? void 0 : stack.file) || \"\";\n}\n\nconst hot = import.meta.hot || {\n\ton: warn,\n\toff: warn,\n\tsend: warn\n};\nfunction warn() {\n\tconsole.warn(\"Vitest mocker cannot work if Vite didn't establish WS connection.\");\n}\nfunction rpc(event, data) {\n\thot.send(event, data);\n\treturn new Promise((resolve, reject) => {\n\t\tconst timeout = setTimeout(() => {\n\t\t\treject(new Error(`Failed to resolve ${event} in time`));\n\t\t}, 5e3);\n\t\thot.on(`${event}:result`, function r(data) {\n\t\t\tresolve(data);\n\t\t\tclearTimeout(timeout);\n\t\t\thot.off(`${event}:result`, r);\n\t\t});\n\t});\n}\n\nconst { now } = Date;\nclass ModuleMocker {\n\tregistry = new MockerRegistry();\n\tqueue = new Set();\n\tmockedIds = new Set();\n\tconstructor(interceptor, rpc, spyOn, config) {\n\t\tthis.interceptor = interceptor;\n\t\tthis.rpc = rpc;\n\t\tthis.spyOn = spyOn;\n\t\tthis.config = config;\n\t}\n\tasync prepare() {\n\t\tif (!this.queue.size) {\n\t\t\treturn;\n\t\t}\n\t\tawait Promise.all([...this.queue.values()]);\n\t}\n\tasync resolveFactoryModule(id) {\n\t\tconst mock = this.registry.get(id);\n\t\tif (!mock || mock.type !== \"manual\") {\n\t\t\tthrow new Error(`Mock ${id} wasn't registered. This is probably a Vitest error. Please, open a new issue with reproduction.`);\n\t\t}\n\t\tconst result = await mock.resolve();\n\t\treturn result;\n\t}\n\tgetFactoryModule(id) {\n\t\tconst mock = this.registry.get(id);\n\t\tif (!mock || mock.type !== \"manual\") {\n\t\t\tthrow new Error(`Mock ${id} wasn't registered. This is probably a Vitest error. Please, open a new issue with reproduction.`);\n\t\t}\n\t\tif (!mock.cache) {\n\t\t\tthrow new Error(`Mock ${id} wasn't resolved. This is probably a Vitest error. Please, open a new issue with reproduction.`);\n\t\t}\n\t\treturn mock.cache;\n\t}\n\tasync invalidate() {\n\t\tconst ids = Array.from(this.mockedIds);\n\t\tif (!ids.length) {\n\t\t\treturn;\n\t\t}\n\t\tawait this.rpc.invalidate(ids);\n\t\tawait this.interceptor.invalidate();\n\t\tthis.registry.clear();\n\t}\n\tasync importActual(id, importer) {\n\t\tconst resolved = await this.rpc.resolveId(id, importer);\n\t\tif (resolved == null) {\n\t\t\tthrow new Error(`[vitest] Cannot resolve \"${id}\" imported from \"${importer}\"`);\n\t\t}\n\t\tconst ext = extname(resolved.id);\n\t\tconst url = new URL(resolved.url, location.href);\n\t\tconst query = `_vitest_original&ext${ext}`;\n\t\tconst actualUrl = `${url.pathname}${url.search ? `${url.search}&${query}` : `?${query}`}${url.hash}`;\n\t\treturn this.wrapDynamicImport(() => import(\n\t\t\t/* @vite-ignore */\n\t\t\tactualUrl\n)).then((mod) => {\n\t\t\tif (!resolved.optimized || typeof mod.default === \"undefined\") {\n\t\t\t\treturn mod;\n\t\t\t}\n\t\t\t// vite injects this helper for optimized modules, so we try to follow the same behavior\n\t\t\tconst m = mod.default;\n\t\t\treturn (m === null || m === void 0 ? void 0 : m.__esModule) ? m : {\n\t\t\t\t...typeof m === \"object\" && !Array.isArray(m) || typeof m === \"function\" ? m : {},\n\t\t\t\tdefault: m\n\t\t\t};\n\t\t});\n\t}\n\tasync importMock(rawId, importer) {\n\t\tawait this.prepare();\n\t\tconst { resolvedId, resolvedUrl, redirectUrl } = await this.rpc.resolveMock(rawId, importer, { mock: \"auto\" });\n\t\tconst mockUrl = this.resolveMockPath(cleanVersion(resolvedUrl));\n\t\tlet mock = this.registry.get(mockUrl);\n\t\tif (!mock) {\n\t\t\tif (redirectUrl) {\n\t\t\t\tconst resolvedRedirect = new URL(this.resolveMockPath(cleanVersion(redirectUrl)), location.href).toString();\n\t\t\t\tmock = new RedirectedModule(rawId, resolvedId, mockUrl, resolvedRedirect);\n\t\t\t} else {\n\t\t\t\tmock = new AutomockedModule(rawId, resolvedId, mockUrl);\n\t\t\t}\n\t\t}\n\t\tif (mock.type === \"manual\") {\n\t\t\treturn await mock.resolve();\n\t\t}\n\t\tif (mock.type === \"automock\" || mock.type === \"autospy\") {\n\t\t\tconst url = new URL(`/@id/${resolvedId}`, location.href);\n\t\t\tconst query = url.search ? `${url.search}&t=${now()}` : `?t=${now()}`;\n\t\t\tconst moduleObject = await import(\n\t\t\t\t/* @vite-ignore */\n\t\t\t\t`${url.pathname}${query}&mock=${mock.type}${url.hash}`\n);\n\t\t\treturn this.mockObject(moduleObject, mock.type);\n\t\t}\n\t\treturn import(\n\t\t\t/* @vite-ignore */\n\t\t\tmock.redirect\n);\n\t}\n\tmockObject(object, moduleType = \"automock\") {\n\t\treturn mockObject({\n\t\t\tglobalConstructors: {\n\t\t\t\tObject,\n\t\t\t\tFunction,\n\t\t\t\tArray,\n\t\t\t\tMap,\n\t\t\t\tRegExp\n\t\t\t},\n\t\t\tspyOn: this.spyOn,\n\t\t\ttype: moduleType\n\t\t}, object);\n\t}\n\tqueueMock(rawId, importer, factoryOrOptions) {\n\t\tconst promise = this.rpc.resolveMock(rawId, importer, { mock: typeof factoryOrOptions === \"function\" ? \"factory\" : (factoryOrOptions === null || factoryOrOptions === void 0 ? void 0 : factoryOrOptions.spy) ? \"spy\" : \"auto\" }).then(async ({ redirectUrl, resolvedId, resolvedUrl, needsInterop, mockType }) => {\n\t\t\tconst mockUrl = this.resolveMockPath(cleanVersion(resolvedUrl));\n\t\t\tthis.mockedIds.add(resolvedId);\n\t\t\tconst factory = typeof factoryOrOptions === \"function\" ? async () => {\n\t\t\t\tconst data = await factoryOrOptions();\n\t\t\t\t// vite wraps all external modules that have \"needsInterop\" in a function that\n\t\t\t\t// merges all exports from default into the module object\n\t\t\t\treturn needsInterop ? { default: data } : data;\n\t\t\t} : undefined;\n\t\t\tconst mockRedirect = typeof redirectUrl === \"string\" ? new URL(this.resolveMockPath(cleanVersion(redirectUrl)), location.href).toString() : null;\n\t\t\tlet module;\n\t\t\tif (mockType === \"manual\") {\n\t\t\t\tmodule = this.registry.register(\"manual\", rawId, resolvedId, mockUrl, factory);\n\t\t\t} else if (mockType === \"autospy\") {\n\t\t\t\tmodule = this.registry.register(\"autospy\", rawId, resolvedId, mockUrl);\n\t\t\t} else if (mockType === \"redirect\") {\n\t\t\t\tmodule = this.registry.register(\"redirect\", rawId, resolvedId, mockUrl, mockRedirect);\n\t\t\t} else {\n\t\t\t\tmodule = this.registry.register(\"automock\", rawId, resolvedId, mockUrl);\n\t\t\t}\n\t\t\tawait this.interceptor.register(module);\n\t\t}).finally(() => {\n\t\t\tthis.queue.delete(promise);\n\t\t});\n\t\tthis.queue.add(promise);\n\t}\n\tqueueUnmock(id, importer) {\n\t\tconst promise = this.rpc.resolveId(id, importer).then(async (resolved) => {\n\t\t\tif (!resolved) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst mockUrl = this.resolveMockPath(cleanVersion(resolved.url));\n\t\t\tthis.mockedIds.add(resolved.id);\n\t\t\tthis.registry.delete(mockUrl);\n\t\t\tawait this.interceptor.delete(mockUrl);\n\t\t}).finally(() => {\n\t\t\tthis.queue.delete(promise);\n\t\t});\n\t\tthis.queue.add(promise);\n\t}\n\t// We need to await mock registration before importing the actual module\n\t// In case there is a mocked module in the import chain\n\twrapDynamicImport(moduleFactory) {\n\t\tif (typeof moduleFactory === \"function\") {\n\t\t\tconst promise = new Promise((resolve, reject) => {\n\t\t\t\tthis.prepare().finally(() => {\n\t\t\t\t\tmoduleFactory().then(resolve, reject);\n\t\t\t\t});\n\t\t\t});\n\t\t\treturn promise;\n\t\t}\n\t\treturn moduleFactory;\n\t}\n\tresolveMockPath(path) {\n\t\tconst config = this.config;\n\t\tconst fsRoot = join(\"/@fs/\", config.root);\n\t\t// URL can be /file/path.js, but path is resolved to /file/path\n\t\tif (path.startsWith(config.root)) {\n\t\t\treturn path.slice(config.root.length);\n\t\t}\n\t\tif (path.startsWith(fsRoot)) {\n\t\t\treturn path.slice(fsRoot.length);\n\t\t}\n\t\treturn path;\n\t}\n}\nconst versionRegexp = /(\\?|&)v=\\w{8}/;\nfunction cleanVersion(url) {\n\treturn url.replace(versionRegexp, \"\");\n}\n\nexport { ModuleMocker as M, createCompilerHints as c, hot as h, rpc as r };\n",
      "start": 1762256767043,
      "end": 1762256767055,
      "sourcemaps": null
    },
    {
      "name": "storybook:mock-loader",
      "start": 1762256767055,
      "end": 1762256767055,
      "order": "normal-pre"
    },
    {
      "name": "vite-plugin-svelte",
      "start": 1762256767055,
      "end": 1762256767055,
      "order": "pre"
    },
    {
      "name": "plugin-csf",
      "start": 1762256767055,
      "end": 1762256767055,
      "order": "pre"
    },
    {
      "name": "vite:esbuild",
      "start": 1762256767055,
      "end": 1762256767055,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1762256767055,
      "end": 1762256767055,
      "order": "normal-normal"
    },
    {
      "name": "storybook:mock-loader-preview",
      "start": 1762256767055,
      "end": 1762256767055,
      "order": "normal"
    },
    {
      "name": "storybook:svelte-docgen-plugin",
      "start": 1762256767055,
      "end": 1762256767055,
      "order": "normal"
    },
    {
      "name": "storybook:addon-svelte-csf",
      "start": 1762256767055,
      "end": 1762256767055,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { mockObject } from \"./index.js\";\nimport { M as MockerRegistry, R as RedirectedModule, A as AutomockedModule } from \"./chunk-registry.js\";\nimport { e as extname, j as join } from \"./chunk-pathe.M-eThtNZ.js\";\nvar f = {\n  reset: [0, 0],\n  bold: [1, 22, \"\\x1B[22m\\x1B[1m\"],\n  dim: [2, 22, \"\\x1B[22m\\x1B[2m\"],\n  italic: [3, 23],\n  underline: [4, 24],\n  inverse: [7, 27],\n  hidden: [8, 28],\n  strikethrough: [9, 29],\n  black: [30, 39],\n  red: [31, 39],\n  green: [32, 39],\n  yellow: [33, 39],\n  blue: [34, 39],\n  magenta: [35, 39],\n  cyan: [36, 39],\n  white: [37, 39],\n  gray: [90, 39],\n  bgBlack: [40, 49],\n  bgRed: [41, 49],\n  bgGreen: [42, 49],\n  bgYellow: [43, 49],\n  bgBlue: [44, 49],\n  bgMagenta: [45, 49],\n  bgCyan: [46, 49],\n  bgWhite: [47, 49],\n  blackBright: [90, 39],\n  redBright: [91, 39],\n  greenBright: [92, 39],\n  yellowBright: [93, 39],\n  blueBright: [94, 39],\n  magentaBright: [95, 39],\n  cyanBright: [96, 39],\n  whiteBright: [97, 39],\n  bgBlackBright: [100, 49],\n  bgRedBright: [101, 49],\n  bgGreenBright: [102, 49],\n  bgYellowBright: [103, 49],\n  bgBlueBright: [104, 49],\n  bgMagentaBright: [105, 49],\n  bgCyanBright: [106, 49],\n  bgWhiteBright: [107, 49]\n}, h = Object.entries(f);\nfunction a(n) {\n  return String(n);\n}\na.open = \"\";\na.close = \"\";\nfunction C(n = false) {\n  let e = typeof process != \"undefined\" ? process : void 0, i = (e == null ? void 0 : e.env) || {}, g = (e == null ? void 0 : e.argv) || [];\n  return !(\"NO_COLOR\" in i || g.includes(\"--no-color\")) && (\"FORCE_COLOR\" in i || g.includes(\"--color\") || (e == null ? void 0 : e.platform) === \"win32\" || n && i.TERM !== \"dumb\" || \"CI\" in i) || typeof window != \"undefined\" && !!window.chrome;\n}\nfunction p(n = false) {\n  let e = C(n), i = (r, t, c, o) => {\n    let l = \"\", s = 0;\n    do\n      l += r.substring(s, o) + c, s = o + t.length, o = r.indexOf(t, s);\n    while (~o);\n    return l + r.substring(s);\n  }, g = (r, t, c = r) => {\n    let o = (l) => {\n      let s = String(l), b = s.indexOf(t, r.length);\n      return ~b ? r + i(s, t, c, b) + t : r + s + t;\n    };\n    return o.open = r, o.close = t, o;\n  }, u = {\n    isColorSupported: e\n  }, d = (r) => `\\x1B[${r}m`;\n  for (let [r, t] of h)\n    u[r] = e ? g(\n      d(t[0]),\n      d(t[1]),\n      t[2]\n    ) : a;\n  return u;\n}\np();\nfunction _mergeNamespaces(n, m) {\n  m.forEach(function(e) {\n    e && typeof e !== \"string\" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n      if (k !== \"default\" && !(k in n)) {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function() {\n            return e[k];\n          }\n        });\n      }\n    });\n  });\n  return Object.freeze(n);\n}\nfunction getDefaultExportFromCjs(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar reactIs$1 = { exports: {} };\nvar reactIs_production = {};\n/**\n* @license React\n* react-is.production.js\n*\n* Copyright (c) Meta Platforms, Inc. and affiliates.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\nvar hasRequiredReactIs_production;\nfunction requireReactIs_production() {\n  if (hasRequiredReactIs_production) return reactIs_production;\n  hasRequiredReactIs_production = 1;\n  var REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"), REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"), REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"), REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"), REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n  var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"), REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"), REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"), REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"), REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"), REACT_MEMO_TYPE = Symbol.for(\"react.memo\"), REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"), REACT_VIEW_TRANSITION_TYPE = Symbol.for(\"react.view_transition\"), REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n  function typeOf(object) {\n    if (\"object\" === typeof object && null !== object) {\n      var $$typeof = object.$$typeof;\n      switch ($$typeof) {\n        case REACT_ELEMENT_TYPE:\n          switch (object = object.type, object) {\n            case REACT_FRAGMENT_TYPE:\n            case REACT_PROFILER_TYPE:\n            case REACT_STRICT_MODE_TYPE:\n            case REACT_SUSPENSE_TYPE:\n            case REACT_SUSPENSE_LIST_TYPE:\n            case REACT_VIEW_TRANSITION_TYPE:\n              return object;\n            default:\n              switch (object = object && object.$$typeof, object) {\n                case REACT_CONTEXT_TYPE:\n                case REACT_FORWARD_REF_TYPE:\n                case REACT_LAZY_TYPE:\n                case REACT_MEMO_TYPE:\n                  return object;\n                case REACT_CONSUMER_TYPE:\n                  return object;\n                default:\n                  return $$typeof;\n              }\n          }\n        case REACT_PORTAL_TYPE:\n          return $$typeof;\n      }\n    }\n  }\n  reactIs_production.ContextConsumer = REACT_CONSUMER_TYPE;\n  reactIs_production.ContextProvider = REACT_CONTEXT_TYPE;\n  reactIs_production.Element = REACT_ELEMENT_TYPE;\n  reactIs_production.ForwardRef = REACT_FORWARD_REF_TYPE;\n  reactIs_production.Fragment = REACT_FRAGMENT_TYPE;\n  reactIs_production.Lazy = REACT_LAZY_TYPE;\n  reactIs_production.Memo = REACT_MEMO_TYPE;\n  reactIs_production.Portal = REACT_PORTAL_TYPE;\n  reactIs_production.Profiler = REACT_PROFILER_TYPE;\n  reactIs_production.StrictMode = REACT_STRICT_MODE_TYPE;\n  reactIs_production.Suspense = REACT_SUSPENSE_TYPE;\n  reactIs_production.SuspenseList = REACT_SUSPENSE_LIST_TYPE;\n  reactIs_production.isContextConsumer = function(object) {\n    return typeOf(object) === REACT_CONSUMER_TYPE;\n  };\n  reactIs_production.isContextProvider = function(object) {\n    return typeOf(object) === REACT_CONTEXT_TYPE;\n  };\n  reactIs_production.isElement = function(object) {\n    return \"object\" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;\n  };\n  reactIs_production.isForwardRef = function(object) {\n    return typeOf(object) === REACT_FORWARD_REF_TYPE;\n  };\n  reactIs_production.isFragment = function(object) {\n    return typeOf(object) === REACT_FRAGMENT_TYPE;\n  };\n  reactIs_production.isLazy = function(object) {\n    return typeOf(object) === REACT_LAZY_TYPE;\n  };\n  reactIs_production.isMemo = function(object) {\n    return typeOf(object) === REACT_MEMO_TYPE;\n  };\n  reactIs_production.isPortal = function(object) {\n    return typeOf(object) === REACT_PORTAL_TYPE;\n  };\n  reactIs_production.isProfiler = function(object) {\n    return typeOf(object) === REACT_PROFILER_TYPE;\n  };\n  reactIs_production.isStrictMode = function(object) {\n    return typeOf(object) === REACT_STRICT_MODE_TYPE;\n  };\n  reactIs_production.isSuspense = function(object) {\n    return typeOf(object) === REACT_SUSPENSE_TYPE;\n  };\n  reactIs_production.isSuspenseList = function(object) {\n    return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;\n  };\n  reactIs_production.isValidElementType = function(type) {\n    return \"string\" === typeof type || \"function\" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || \"object\" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? true : false;\n  };\n  reactIs_production.typeOf = typeOf;\n  return reactIs_production;\n}\nvar reactIs_development$1 = {};\n/**\n* @license React\n* react-is.development.js\n*\n* Copyright (c) Meta Platforms, Inc. and affiliates.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\nvar hasRequiredReactIs_development$1;\nfunction requireReactIs_development$1() {\n  if (hasRequiredReactIs_development$1) return reactIs_development$1;\n  hasRequiredReactIs_development$1 = 1;\n  return reactIs_development$1;\n}\nvar hasRequiredReactIs$1;\nfunction requireReactIs$1() {\n  if (hasRequiredReactIs$1) return reactIs$1.exports;\n  hasRequiredReactIs$1 = 1;\n  if (true) {\n    reactIs$1.exports = requireReactIs_production();\n  } else {\n    reactIs$1.exports = requireReactIs_development$1();\n  }\n  return reactIs$1.exports;\n}\nvar reactIsExports$1 = requireReactIs$1();\nvar index$1 = /* @__PURE__ */ getDefaultExportFromCjs(reactIsExports$1);\nvar ReactIs19 = /* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  default: index$1\n}, [reactIsExports$1]);\nvar reactIs = { exports: {} };\nvar reactIs_production_min = {};\n/**\n* @license React\n* react-is.production.min.js\n*\n* Copyright (c) Facebook, Inc. and its affiliates.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\nvar hasRequiredReactIs_production_min;\nfunction requireReactIs_production_min() {\n  if (hasRequiredReactIs_production_min) return reactIs_production_min;\n  hasRequiredReactIs_production_min = 1;\n  var b = Symbol.for(\"react.element\"), c = Symbol.for(\"react.portal\"), d = Symbol.for(\"react.fragment\"), e = Symbol.for(\"react.strict_mode\"), f2 = Symbol.for(\"react.profiler\"), g = Symbol.for(\"react.provider\"), h2 = Symbol.for(\"react.context\"), k = Symbol.for(\"react.server_context\"), l = Symbol.for(\"react.forward_ref\"), m = Symbol.for(\"react.suspense\"), n = Symbol.for(\"react.suspense_list\"), p2 = Symbol.for(\"react.memo\"), q = Symbol.for(\"react.lazy\"), t = Symbol.for(\"react.offscreen\"), u;\n  u = Symbol.for(\"react.module.reference\");\n  function v(a2) {\n    if (\"object\" === typeof a2 && null !== a2) {\n      var r = a2.$$typeof;\n      switch (r) {\n        case b:\n          switch (a2 = a2.type, a2) {\n            case d:\n            case f2:\n            case e:\n            case m:\n            case n:\n              return a2;\n            default:\n              switch (a2 = a2 && a2.$$typeof, a2) {\n                case k:\n                case h2:\n                case l:\n                case q:\n                case p2:\n                case g:\n                  return a2;\n                default:\n                  return r;\n              }\n          }\n        case c:\n          return r;\n      }\n    }\n  }\n  reactIs_production_min.ContextConsumer = h2;\n  reactIs_production_min.ContextProvider = g;\n  reactIs_production_min.Element = b;\n  reactIs_production_min.ForwardRef = l;\n  reactIs_production_min.Fragment = d;\n  reactIs_production_min.Lazy = q;\n  reactIs_production_min.Memo = p2;\n  reactIs_production_min.Portal = c;\n  reactIs_production_min.Profiler = f2;\n  reactIs_production_min.StrictMode = e;\n  reactIs_production_min.Suspense = m;\n  reactIs_production_min.SuspenseList = n;\n  reactIs_production_min.isAsyncMode = function() {\n    return false;\n  };\n  reactIs_production_min.isConcurrentMode = function() {\n    return false;\n  };\n  reactIs_production_min.isContextConsumer = function(a2) {\n    return v(a2) === h2;\n  };\n  reactIs_production_min.isContextProvider = function(a2) {\n    return v(a2) === g;\n  };\n  reactIs_production_min.isElement = function(a2) {\n    return \"object\" === typeof a2 && null !== a2 && a2.$$typeof === b;\n  };\n  reactIs_production_min.isForwardRef = function(a2) {\n    return v(a2) === l;\n  };\n  reactIs_production_min.isFragment = function(a2) {\n    return v(a2) === d;\n  };\n  reactIs_production_min.isLazy = function(a2) {\n    return v(a2) === q;\n  };\n  reactIs_production_min.isMemo = function(a2) {\n    return v(a2) === p2;\n  };\n  reactIs_production_min.isPortal = function(a2) {\n    return v(a2) === c;\n  };\n  reactIs_production_min.isProfiler = function(a2) {\n    return v(a2) === f2;\n  };\n  reactIs_production_min.isStrictMode = function(a2) {\n    return v(a2) === e;\n  };\n  reactIs_production_min.isSuspense = function(a2) {\n    return v(a2) === m;\n  };\n  reactIs_production_min.isSuspenseList = function(a2) {\n    return v(a2) === n;\n  };\n  reactIs_production_min.isValidElementType = function(a2) {\n    return \"string\" === typeof a2 || \"function\" === typeof a2 || a2 === d || a2 === f2 || a2 === e || a2 === m || a2 === n || a2 === t || \"object\" === typeof a2 && null !== a2 && (a2.$$typeof === q || a2.$$typeof === p2 || a2.$$typeof === g || a2.$$typeof === h2 || a2.$$typeof === l || a2.$$typeof === u || void 0 !== a2.getModuleId) ? true : false;\n  };\n  reactIs_production_min.typeOf = v;\n  return reactIs_production_min;\n}\nvar reactIs_development = {};\n/**\n* @license React\n* react-is.development.js\n*\n* Copyright (c) Facebook, Inc. and its affiliates.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\nvar hasRequiredReactIs_development;\nfunction requireReactIs_development() {\n  if (hasRequiredReactIs_development) return reactIs_development;\n  hasRequiredReactIs_development = 1;\n  if (false) {\n    (function() {\n      var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n      var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n      var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n      var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n      var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n      var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n      var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n      var REACT_SERVER_CONTEXT_TYPE = Symbol.for(\"react.server_context\");\n      var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n      var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n      var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n      var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n      var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n      var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n      var enableScopeAPI = false;\n      var enableCacheElement = false;\n      var enableTransitionTracing = false;\n      var enableLegacyHidden = false;\n      var enableDebugTracing = false;\n      var REACT_MODULE_REFERENCE;\n      {\n        REACT_MODULE_REFERENCE = Symbol.for(\"react.module.reference\");\n      }\n      function isValidElementType(type) {\n        if (typeof type === \"string\" || typeof type === \"function\") {\n          return true;\n        }\n        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n          return true;\n        }\n        if (typeof type === \"object\" && type !== null) {\n          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {\n            return true;\n          }\n        }\n        return false;\n      }\n      function typeOf(object) {\n        if (typeof object === \"object\" && object !== null) {\n          var $$typeof = object.$$typeof;\n          switch ($$typeof) {\n            case REACT_ELEMENT_TYPE:\n              var type = object.type;\n              switch (type) {\n                case REACT_FRAGMENT_TYPE:\n                case REACT_PROFILER_TYPE:\n                case REACT_STRICT_MODE_TYPE:\n                case REACT_SUSPENSE_TYPE:\n                case REACT_SUSPENSE_LIST_TYPE:\n                  return type;\n                default:\n                  var $$typeofType = type && type.$$typeof;\n                  switch ($$typeofType) {\n                    case REACT_SERVER_CONTEXT_TYPE:\n                    case REACT_CONTEXT_TYPE:\n                    case REACT_FORWARD_REF_TYPE:\n                    case REACT_LAZY_TYPE:\n                    case REACT_MEMO_TYPE:\n                    case REACT_PROVIDER_TYPE:\n                      return $$typeofType;\n                    default:\n                      return $$typeof;\n                  }\n              }\n            case REACT_PORTAL_TYPE:\n              return $$typeof;\n          }\n        }\n        return void 0;\n      }\n      var ContextConsumer = REACT_CONTEXT_TYPE;\n      var ContextProvider = REACT_PROVIDER_TYPE;\n      var Element = REACT_ELEMENT_TYPE;\n      var ForwardRef = REACT_FORWARD_REF_TYPE;\n      var Fragment = REACT_FRAGMENT_TYPE;\n      var Lazy = REACT_LAZY_TYPE;\n      var Memo = REACT_MEMO_TYPE;\n      var Portal = REACT_PORTAL_TYPE;\n      var Profiler = REACT_PROFILER_TYPE;\n      var StrictMode = REACT_STRICT_MODE_TYPE;\n      var Suspense = REACT_SUSPENSE_TYPE;\n      var SuspenseList = REACT_SUSPENSE_LIST_TYPE;\n      var hasWarnedAboutDeprecatedIsAsyncMode = false;\n      var hasWarnedAboutDeprecatedIsConcurrentMode = false;\n      function isAsyncMode(object) {\n        {\n          if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n            hasWarnedAboutDeprecatedIsAsyncMode = true;\n            console[\"warn\"](\"The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.\");\n          }\n        }\n        return false;\n      }\n      function isConcurrentMode(object) {\n        {\n          if (!hasWarnedAboutDeprecatedIsConcurrentMode) {\n            hasWarnedAboutDeprecatedIsConcurrentMode = true;\n            console[\"warn\"](\"The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.\");\n          }\n        }\n        return false;\n      }\n      function isContextConsumer(object) {\n        return typeOf(object) === REACT_CONTEXT_TYPE;\n      }\n      function isContextProvider(object) {\n        return typeOf(object) === REACT_PROVIDER_TYPE;\n      }\n      function isElement(object) {\n        return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n      }\n      function isForwardRef(object) {\n        return typeOf(object) === REACT_FORWARD_REF_TYPE;\n      }\n      function isFragment(object) {\n        return typeOf(object) === REACT_FRAGMENT_TYPE;\n      }\n      function isLazy(object) {\n        return typeOf(object) === REACT_LAZY_TYPE;\n      }\n      function isMemo(object) {\n        return typeOf(object) === REACT_MEMO_TYPE;\n      }\n      function isPortal(object) {\n        return typeOf(object) === REACT_PORTAL_TYPE;\n      }\n      function isProfiler(object) {\n        return typeOf(object) === REACT_PROFILER_TYPE;\n      }\n      function isStrictMode(object) {\n        return typeOf(object) === REACT_STRICT_MODE_TYPE;\n      }\n      function isSuspense(object) {\n        return typeOf(object) === REACT_SUSPENSE_TYPE;\n      }\n      function isSuspenseList(object) {\n        return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;\n      }\n      reactIs_development.ContextConsumer = ContextConsumer;\n      reactIs_development.ContextProvider = ContextProvider;\n      reactIs_development.Element = Element;\n      reactIs_development.ForwardRef = ForwardRef;\n      reactIs_development.Fragment = Fragment;\n      reactIs_development.Lazy = Lazy;\n      reactIs_development.Memo = Memo;\n      reactIs_development.Portal = Portal;\n      reactIs_development.Profiler = Profiler;\n      reactIs_development.StrictMode = StrictMode;\n      reactIs_development.Suspense = Suspense;\n      reactIs_development.SuspenseList = SuspenseList;\n      reactIs_development.isAsyncMode = isAsyncMode;\n      reactIs_development.isConcurrentMode = isConcurrentMode;\n      reactIs_development.isContextConsumer = isContextConsumer;\n      reactIs_development.isContextProvider = isContextProvider;\n      reactIs_development.isElement = isElement;\n      reactIs_development.isForwardRef = isForwardRef;\n      reactIs_development.isFragment = isFragment;\n      reactIs_development.isLazy = isLazy;\n      reactIs_development.isMemo = isMemo;\n      reactIs_development.isPortal = isPortal;\n      reactIs_development.isProfiler = isProfiler;\n      reactIs_development.isStrictMode = isStrictMode;\n      reactIs_development.isSuspense = isSuspense;\n      reactIs_development.isSuspenseList = isSuspenseList;\n      reactIs_development.isValidElementType = isValidElementType;\n      reactIs_development.typeOf = typeOf;\n    })();\n  }\n  return reactIs_development;\n}\nvar hasRequiredReactIs;\nfunction requireReactIs() {\n  if (hasRequiredReactIs) return reactIs.exports;\n  hasRequiredReactIs = 1;\n  if (true) {\n    reactIs.exports = requireReactIs_production_min();\n  } else {\n    reactIs.exports = requireReactIs_development();\n  }\n  return reactIs.exports;\n}\nvar reactIsExports = requireReactIs();\nvar index = /* @__PURE__ */ getDefaultExportFromCjs(reactIsExports);\nvar ReactIs18 = /* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  default: index\n}, [reactIsExports]);\nconst reactIsMethods = [\n  \"isAsyncMode\",\n  \"isConcurrentMode\",\n  \"isContextConsumer\",\n  \"isContextProvider\",\n  \"isElement\",\n  \"isForwardRef\",\n  \"isFragment\",\n  \"isLazy\",\n  \"isMemo\",\n  \"isPortal\",\n  \"isProfiler\",\n  \"isStrictMode\",\n  \"isSuspense\",\n  \"isSuspenseList\",\n  \"isValidElementType\"\n];\nObject.fromEntries(reactIsMethods.map((m) => [m, (v) => ReactIs18[m](v) || ReactIs19[m](v)]));\nlet getPromiseValue = () => \"Promise{â€¦}\";\ntry {\n  const { getPromiseDetails, kPending, kRejected } = process.binding(\"util\");\n  if (Array.isArray(getPromiseDetails(Promise.resolve()))) {\n    getPromiseValue = (value, options) => {\n      const [state, innerValue] = getPromiseDetails(value);\n      if (state === kPending) {\n        return \"Promise{<pending>}\";\n      }\n      return `Promise${state === kRejected ? \"!\" : \"\"}{${options.inspect(innerValue, options)}}`;\n    };\n  }\n} catch (notNode) {\n}\nfunction createSimpleStackTrace(options) {\n  const { message = \"$$stack trace error\", stackTraceLimit = 1 } = options || {};\n  const limit = Error.stackTraceLimit;\n  const prepareStackTrace = Error.prepareStackTrace;\n  Error.stackTraceLimit = stackTraceLimit;\n  Error.prepareStackTrace = (e) => e.stack;\n  const err = new Error(message);\n  const stackTrace = err.stack || \"\";\n  Error.prepareStackTrace = prepareStackTrace;\n  Error.stackTraceLimit = limit;\n  return stackTrace;\n}\nvar jsTokens_1;\nvar hasRequiredJsTokens;\nfunction requireJsTokens() {\n  if (hasRequiredJsTokens) return jsTokens_1;\n  hasRequiredJsTokens = 1;\n  var Identifier, JSXIdentifier, JSXPunctuator, JSXString, JSXText, KeywordsWithExpressionAfter, KeywordsWithNoLineTerminatorAfter, LineTerminatorSequence, MultiLineComment, Newline, NumericLiteral, Punctuator, RegularExpressionLiteral, SingleLineComment, StringLiteral, Template, TokensNotPrecedingObjectLiteral, TokensPrecedingExpression, WhiteSpace;\n  RegularExpressionLiteral = /\\/(?![*\\/])(?:\\[(?:(?![\\]\\\\]).|\\\\.)*\\]|(?![\\/\\\\]).|\\\\.)*(\\/[$_\\u200C\\u200D\\p{ID_Continue}]*|\\\\)?/uy;\n  Punctuator = /--|\\+\\+|=>|\\.{3}|\\??\\.(?!\\d)|(?:&&|\\|\\||\\?\\?|[+\\-%&|^]|\\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\\/(?![\\/*]))=?|[?~,:;[\\](){}]/y;\n  Identifier = /(\\x23?)(?=[$_\\p{ID_Start}\\\\])(?:[$_\\u200C\\u200D\\p{ID_Continue}]|\\\\u[\\da-fA-F]{4}|\\\\u\\{[\\da-fA-F]+\\})+/uy;\n  StringLiteral = /(['\"])(?:(?!\\1)[^\\\\\\n\\r]|\\\\(?:\\r\\n|[^]))*(\\1)?/y;\n  NumericLiteral = /(?:0[xX][\\da-fA-F](?:_?[\\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\\d)*n|(?:(?:0(?!\\d)|0\\d*[89]\\d*|[1-9](?:_?\\d)*)(?:\\.(?:\\d(?:_?\\d)*)?)?|\\.\\d(?:_?\\d)*)(?:[eE][+-]?\\d(?:_?\\d)*)?|0[0-7]+/y;\n  Template = /[`}](?:[^`\\\\$]|\\\\[^]|\\$(?!\\{))*(`|\\$\\{)?/y;\n  WhiteSpace = /[\\t\\v\\f\\ufeff\\p{Zs}]+/uy;\n  LineTerminatorSequence = /\\r?\\n|[\\r\\u2028\\u2029]/y;\n  MultiLineComment = /\\/\\*(?:[^*]|\\*(?!\\/))*(\\*\\/)?/y;\n  SingleLineComment = /\\/\\/.*/y;\n  JSXPunctuator = /[<>.:={}]|\\/(?![\\/*])/y;\n  JSXIdentifier = /[$_\\p{ID_Start}][$_\\u200C\\u200D\\p{ID_Continue}-]*/uy;\n  JSXString = /(['\"])(?:(?!\\1)[^])*(\\1)?/y;\n  JSXText = /[^<>{}]+/y;\n  TokensPrecedingExpression = /^(?:[\\/+-]|\\.{3}|\\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/;\n  TokensNotPrecedingObjectLiteral = /^(?:=>|[;\\]){}]|else|\\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/;\n  KeywordsWithExpressionAfter = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/;\n  KeywordsWithNoLineTerminatorAfter = /^(?:return|throw|yield)$/;\n  Newline = RegExp(LineTerminatorSequence.source);\n  jsTokens_1 = function* (input, { jsx = false } = {}) {\n    var braces, firstCodePoint, isExpression, lastIndex, lastSignificantToken, length, match, mode, nextLastIndex, nextLastSignificantToken, parenNesting, postfixIncDec, punctuator, stack;\n    ({ length } = input);\n    lastIndex = 0;\n    lastSignificantToken = \"\";\n    stack = [{ tag: \"JS\" }];\n    braces = [];\n    parenNesting = 0;\n    postfixIncDec = false;\n    while (lastIndex < length) {\n      mode = stack[stack.length - 1];\n      switch (mode.tag) {\n        case \"JS\":\n        case \"JSNonExpressionParen\":\n        case \"InterpolationInTemplate\":\n        case \"InterpolationInJSX\":\n          if (input[lastIndex] === \"/\" && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {\n            RegularExpressionLiteral.lastIndex = lastIndex;\n            if (match = RegularExpressionLiteral.exec(input)) {\n              lastIndex = RegularExpressionLiteral.lastIndex;\n              lastSignificantToken = match[0];\n              postfixIncDec = true;\n              yield {\n                type: \"RegularExpressionLiteral\",\n                value: match[0],\n                closed: match[1] !== void 0 && match[1] !== \"\\\\\"\n              };\n              continue;\n            }\n          }\n          Punctuator.lastIndex = lastIndex;\n          if (match = Punctuator.exec(input)) {\n            punctuator = match[0];\n            nextLastIndex = Punctuator.lastIndex;\n            nextLastSignificantToken = punctuator;\n            switch (punctuator) {\n              case \"(\":\n                if (lastSignificantToken === \"?NonExpressionParenKeyword\") {\n                  stack.push({\n                    tag: \"JSNonExpressionParen\",\n                    nesting: parenNesting\n                  });\n                }\n                parenNesting++;\n                postfixIncDec = false;\n                break;\n              case \")\":\n                parenNesting--;\n                postfixIncDec = true;\n                if (mode.tag === \"JSNonExpressionParen\" && parenNesting === mode.nesting) {\n                  stack.pop();\n                  nextLastSignificantToken = \"?NonExpressionParenEnd\";\n                  postfixIncDec = false;\n                }\n                break;\n              case \"{\":\n                Punctuator.lastIndex = 0;\n                isExpression = !TokensNotPrecedingObjectLiteral.test(lastSignificantToken) && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken));\n                braces.push(isExpression);\n                postfixIncDec = false;\n                break;\n              case \"}\":\n                switch (mode.tag) {\n                  case \"InterpolationInTemplate\":\n                    if (braces.length === mode.nesting) {\n                      Template.lastIndex = lastIndex;\n                      match = Template.exec(input);\n                      lastIndex = Template.lastIndex;\n                      lastSignificantToken = match[0];\n                      if (match[1] === \"${\") {\n                        lastSignificantToken = \"?InterpolationInTemplate\";\n                        postfixIncDec = false;\n                        yield {\n                          type: \"TemplateMiddle\",\n                          value: match[0]\n                        };\n                      } else {\n                        stack.pop();\n                        postfixIncDec = true;\n                        yield {\n                          type: \"TemplateTail\",\n                          value: match[0],\n                          closed: match[1] === \"`\"\n                        };\n                      }\n                      continue;\n                    }\n                    break;\n                  case \"InterpolationInJSX\":\n                    if (braces.length === mode.nesting) {\n                      stack.pop();\n                      lastIndex += 1;\n                      lastSignificantToken = \"}\";\n                      yield {\n                        type: \"JSXPunctuator\",\n                        value: \"}\"\n                      };\n                      continue;\n                    }\n                }\n                postfixIncDec = braces.pop();\n                nextLastSignificantToken = postfixIncDec ? \"?ExpressionBraceEnd\" : \"}\";\n                break;\n              case \"]\":\n                postfixIncDec = true;\n                break;\n              case \"++\":\n              case \"--\":\n                nextLastSignificantToken = postfixIncDec ? \"?PostfixIncDec\" : \"?UnaryIncDec\";\n                break;\n              case \"<\":\n                if (jsx && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {\n                  stack.push({ tag: \"JSXTag\" });\n                  lastIndex += 1;\n                  lastSignificantToken = \"<\";\n                  yield {\n                    type: \"JSXPunctuator\",\n                    value: punctuator\n                  };\n                  continue;\n                }\n                postfixIncDec = false;\n                break;\n              default:\n                postfixIncDec = false;\n            }\n            lastIndex = nextLastIndex;\n            lastSignificantToken = nextLastSignificantToken;\n            yield {\n              type: \"Punctuator\",\n              value: punctuator\n            };\n            continue;\n          }\n          Identifier.lastIndex = lastIndex;\n          if (match = Identifier.exec(input)) {\n            lastIndex = Identifier.lastIndex;\n            nextLastSignificantToken = match[0];\n            switch (match[0]) {\n              case \"for\":\n              case \"if\":\n              case \"while\":\n              case \"with\":\n                if (lastSignificantToken !== \".\" && lastSignificantToken !== \"?.\") {\n                  nextLastSignificantToken = \"?NonExpressionParenKeyword\";\n                }\n            }\n            lastSignificantToken = nextLastSignificantToken;\n            postfixIncDec = !KeywordsWithExpressionAfter.test(match[0]);\n            yield {\n              type: match[1] === \"#\" ? \"PrivateIdentifier\" : \"IdentifierName\",\n              value: match[0]\n            };\n            continue;\n          }\n          StringLiteral.lastIndex = lastIndex;\n          if (match = StringLiteral.exec(input)) {\n            lastIndex = StringLiteral.lastIndex;\n            lastSignificantToken = match[0];\n            postfixIncDec = true;\n            yield {\n              type: \"StringLiteral\",\n              value: match[0],\n              closed: match[2] !== void 0\n            };\n            continue;\n          }\n          NumericLiteral.lastIndex = lastIndex;\n          if (match = NumericLiteral.exec(input)) {\n            lastIndex = NumericLiteral.lastIndex;\n            lastSignificantToken = match[0];\n            postfixIncDec = true;\n            yield {\n              type: \"NumericLiteral\",\n              value: match[0]\n            };\n            continue;\n          }\n          Template.lastIndex = lastIndex;\n          if (match = Template.exec(input)) {\n            lastIndex = Template.lastIndex;\n            lastSignificantToken = match[0];\n            if (match[1] === \"${\") {\n              lastSignificantToken = \"?InterpolationInTemplate\";\n              stack.push({\n                tag: \"InterpolationInTemplate\",\n                nesting: braces.length\n              });\n              postfixIncDec = false;\n              yield {\n                type: \"TemplateHead\",\n                value: match[0]\n              };\n            } else {\n              postfixIncDec = true;\n              yield {\n                type: \"NoSubstitutionTemplate\",\n                value: match[0],\n                closed: match[1] === \"`\"\n              };\n            }\n            continue;\n          }\n          break;\n        case \"JSXTag\":\n        case \"JSXTagEnd\":\n          JSXPunctuator.lastIndex = lastIndex;\n          if (match = JSXPunctuator.exec(input)) {\n            lastIndex = JSXPunctuator.lastIndex;\n            nextLastSignificantToken = match[0];\n            switch (match[0]) {\n              case \"<\":\n                stack.push({ tag: \"JSXTag\" });\n                break;\n              case \">\":\n                stack.pop();\n                if (lastSignificantToken === \"/\" || mode.tag === \"JSXTagEnd\") {\n                  nextLastSignificantToken = \"?JSX\";\n                  postfixIncDec = true;\n                } else {\n                  stack.push({ tag: \"JSXChildren\" });\n                }\n                break;\n              case \"{\":\n                stack.push({\n                  tag: \"InterpolationInJSX\",\n                  nesting: braces.length\n                });\n                nextLastSignificantToken = \"?InterpolationInJSX\";\n                postfixIncDec = false;\n                break;\n              case \"/\":\n                if (lastSignificantToken === \"<\") {\n                  stack.pop();\n                  if (stack[stack.length - 1].tag === \"JSXChildren\") {\n                    stack.pop();\n                  }\n                  stack.push({ tag: \"JSXTagEnd\" });\n                }\n            }\n            lastSignificantToken = nextLastSignificantToken;\n            yield {\n              type: \"JSXPunctuator\",\n              value: match[0]\n            };\n            continue;\n          }\n          JSXIdentifier.lastIndex = lastIndex;\n          if (match = JSXIdentifier.exec(input)) {\n            lastIndex = JSXIdentifier.lastIndex;\n            lastSignificantToken = match[0];\n            yield {\n              type: \"JSXIdentifier\",\n              value: match[0]\n            };\n            continue;\n          }\n          JSXString.lastIndex = lastIndex;\n          if (match = JSXString.exec(input)) {\n            lastIndex = JSXString.lastIndex;\n            lastSignificantToken = match[0];\n            yield {\n              type: \"JSXString\",\n              value: match[0],\n              closed: match[2] !== void 0\n            };\n            continue;\n          }\n          break;\n        case \"JSXChildren\":\n          JSXText.lastIndex = lastIndex;\n          if (match = JSXText.exec(input)) {\n            lastIndex = JSXText.lastIndex;\n            lastSignificantToken = match[0];\n            yield {\n              type: \"JSXText\",\n              value: match[0]\n            };\n            continue;\n          }\n          switch (input[lastIndex]) {\n            case \"<\":\n              stack.push({ tag: \"JSXTag\" });\n              lastIndex++;\n              lastSignificantToken = \"<\";\n              yield {\n                type: \"JSXPunctuator\",\n                value: \"<\"\n              };\n              continue;\n            case \"{\":\n              stack.push({\n                tag: \"InterpolationInJSX\",\n                nesting: braces.length\n              });\n              lastIndex++;\n              lastSignificantToken = \"?InterpolationInJSX\";\n              postfixIncDec = false;\n              yield {\n                type: \"JSXPunctuator\",\n                value: \"{\"\n              };\n              continue;\n          }\n      }\n      WhiteSpace.lastIndex = lastIndex;\n      if (match = WhiteSpace.exec(input)) {\n        lastIndex = WhiteSpace.lastIndex;\n        yield {\n          type: \"WhiteSpace\",\n          value: match[0]\n        };\n        continue;\n      }\n      LineTerminatorSequence.lastIndex = lastIndex;\n      if (match = LineTerminatorSequence.exec(input)) {\n        lastIndex = LineTerminatorSequence.lastIndex;\n        postfixIncDec = false;\n        if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {\n          lastSignificantToken = \"?NoLineTerminatorHere\";\n        }\n        yield {\n          type: \"LineTerminatorSequence\",\n          value: match[0]\n        };\n        continue;\n      }\n      MultiLineComment.lastIndex = lastIndex;\n      if (match = MultiLineComment.exec(input)) {\n        lastIndex = MultiLineComment.lastIndex;\n        if (Newline.test(match[0])) {\n          postfixIncDec = false;\n          if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {\n            lastSignificantToken = \"?NoLineTerminatorHere\";\n          }\n        }\n        yield {\n          type: \"MultiLineComment\",\n          value: match[0],\n          closed: match[1] !== void 0\n        };\n        continue;\n      }\n      SingleLineComment.lastIndex = lastIndex;\n      if (match = SingleLineComment.exec(input)) {\n        lastIndex = SingleLineComment.lastIndex;\n        postfixIncDec = false;\n        yield {\n          type: \"SingleLineComment\",\n          value: match[0]\n        };\n        continue;\n      }\n      firstCodePoint = String.fromCodePoint(input.codePointAt(lastIndex));\n      lastIndex += firstCodePoint.length;\n      lastSignificantToken = firstCodePoint;\n      postfixIncDec = false;\n      yield {\n        type: mode.tag.startsWith(\"JSX\") ? \"JSXInvalid\" : \"Invalid\",\n        value: firstCodePoint\n      };\n    }\n    return void 0;\n  };\n  return jsTokens_1;\n}\nrequireJsTokens();\nvar reservedWords = {\n  keyword: [\n    \"break\",\n    \"case\",\n    \"catch\",\n    \"continue\",\n    \"debugger\",\n    \"default\",\n    \"do\",\n    \"else\",\n    \"finally\",\n    \"for\",\n    \"function\",\n    \"if\",\n    \"return\",\n    \"switch\",\n    \"throw\",\n    \"try\",\n    \"var\",\n    \"const\",\n    \"while\",\n    \"with\",\n    \"new\",\n    \"this\",\n    \"super\",\n    \"class\",\n    \"extends\",\n    \"export\",\n    \"import\",\n    \"null\",\n    \"true\",\n    \"false\",\n    \"in\",\n    \"instanceof\",\n    \"typeof\",\n    \"void\",\n    \"delete\"\n  ],\n  strict: [\n    \"implements\",\n    \"interface\",\n    \"let\",\n    \"package\",\n    \"private\",\n    \"protected\",\n    \"public\",\n    \"static\",\n    \"yield\"\n  ]\n};\nnew Set(reservedWords.keyword);\nnew Set(reservedWords.strict);\nconst chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nconst intToChar = new Uint8Array(64);\nconst charToInt = new Uint8Array(128);\nfor (let i = 0; i < chars.length; i++) {\n  const c = chars.charCodeAt(i);\n  intToChar[i] = c;\n  charToInt[c] = i;\n}\nvar UrlType;\n(function(UrlType2) {\n  UrlType2[UrlType2[\"Empty\"] = 1] = \"Empty\";\n  UrlType2[UrlType2[\"Hash\"] = 2] = \"Hash\";\n  UrlType2[UrlType2[\"Query\"] = 3] = \"Query\";\n  UrlType2[UrlType2[\"RelativePath\"] = 4] = \"RelativePath\";\n  UrlType2[UrlType2[\"AbsolutePath\"] = 5] = \"AbsolutePath\";\n  UrlType2[UrlType2[\"SchemeRelative\"] = 6] = \"SchemeRelative\";\n  UrlType2[UrlType2[\"Absolute\"] = 7] = \"Absolute\";\n})(UrlType || (UrlType = {}));\nconst _DRIVE_LETTER_START_RE = /^[A-Za-z]:\\//;\nfunction normalizeWindowsPath(input = \"\") {\n  if (!input) {\n    return input;\n  }\n  return input.replace(/\\\\/g, \"/\").replace(_DRIVE_LETTER_START_RE, (r) => r.toUpperCase());\n}\nconst _IS_ABSOLUTE_RE = /^[/\\\\](?![/\\\\])|^[/\\\\]{2}(?!\\.)|^[A-Za-z]:[/\\\\]/;\nfunction cwd() {\n  if (typeof process !== \"undefined\" && typeof process.cwd === \"function\") {\n    return process.cwd().replace(/\\\\/g, \"/\");\n  }\n  return \"/\";\n}\nconst resolve = function(...arguments_) {\n  arguments_ = arguments_.map((argument) => normalizeWindowsPath(argument));\n  let resolvedPath = \"\";\n  let resolvedAbsolute = false;\n  for (let index2 = arguments_.length - 1; index2 >= -1 && !resolvedAbsolute; index2--) {\n    const path = index2 >= 0 ? arguments_[index2] : cwd();\n    if (!path || path.length === 0) {\n      continue;\n    }\n    resolvedPath = `${path}/${resolvedPath}`;\n    resolvedAbsolute = isAbsolute(path);\n  }\n  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute);\n  if (resolvedAbsolute && !isAbsolute(resolvedPath)) {\n    return `/${resolvedPath}`;\n  }\n  return resolvedPath.length > 0 ? resolvedPath : \".\";\n};\nfunction normalizeString(path, allowAboveRoot) {\n  let res = \"\";\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let char = null;\n  for (let index2 = 0; index2 <= path.length; ++index2) {\n    if (index2 < path.length) {\n      char = path[index2];\n    } else if (char === \"/\") {\n      break;\n    } else {\n      char = \"/\";\n    }\n    if (char === \"/\") {\n      if (lastSlash === index2 - 1 || dots === 1) ;\n      else if (dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== \".\" || res[res.length - 2] !== \".\") {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(\"/\");\n            if (lastSlashIndex === -1) {\n              res = \"\";\n              lastSegmentLength = 0;\n            } else {\n              res = res.slice(0, lastSlashIndex);\n              lastSegmentLength = res.length - 1 - res.lastIndexOf(\"/\");\n            }\n            lastSlash = index2;\n            dots = 0;\n            continue;\n          } else if (res.length > 0) {\n            res = \"\";\n            lastSegmentLength = 0;\n            lastSlash = index2;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          res += res.length > 0 ? \"/..\" : \"..\";\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) {\n          res += `/${path.slice(lastSlash + 1, index2)}`;\n        } else {\n          res = path.slice(lastSlash + 1, index2);\n        }\n        lastSegmentLength = index2 - lastSlash - 1;\n      }\n      lastSlash = index2;\n      dots = 0;\n    } else if (char === \".\" && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\nconst isAbsolute = function(p2) {\n  return _IS_ABSOLUTE_RE.test(p2);\n};\nconst CHROME_IE_STACK_REGEXP = /^\\s*at .*(?:\\S:\\d+|\\(native\\))/m;\nconst SAFARI_NATIVE_CODE_REGEXP = /^(?:eval@)?(?:\\[native code\\])?$/;\nfunction extractLocation(urlLike) {\n  if (!urlLike.includes(\":\")) {\n    return [urlLike];\n  }\n  const regExp = /(.+?)(?::(\\d+))?(?::(\\d+))?$/;\n  const parts = regExp.exec(urlLike.replace(/^\\(|\\)$/g, \"\"));\n  if (!parts) {\n    return [urlLike];\n  }\n  let url = parts[1];\n  if (url.startsWith(\"async \")) {\n    url = url.slice(6);\n  }\n  if (url.startsWith(\"http:\") || url.startsWith(\"https:\")) {\n    const urlObj = new URL(url);\n    urlObj.searchParams.delete(\"import\");\n    urlObj.searchParams.delete(\"browserv\");\n    url = urlObj.pathname + urlObj.hash + urlObj.search;\n  }\n  if (url.startsWith(\"/@fs/\")) {\n    const isWindows = /^\\/@fs\\/[a-zA-Z]:\\//.test(url);\n    url = url.slice(isWindows ? 5 : 4);\n  }\n  return [\n    url,\n    parts[2] || void 0,\n    parts[3] || void 0\n  ];\n}\nfunction parseSingleFFOrSafariStack(raw) {\n  let line = raw.trim();\n  if (SAFARI_NATIVE_CODE_REGEXP.test(line)) {\n    return null;\n  }\n  if (line.includes(\" > eval\")) {\n    line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g, \":$1\");\n  }\n  if (!line.includes(\"@\") && !line.includes(\":\")) {\n    return null;\n  }\n  const functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(@)/;\n  const matches = line.match(functionNameRegex);\n  const functionName = matches && matches[1] ? matches[1] : void 0;\n  const [url, lineNumber, columnNumber] = extractLocation(line.replace(functionNameRegex, \"\"));\n  if (!url || !lineNumber || !columnNumber) {\n    return null;\n  }\n  return {\n    file: url,\n    method: functionName || \"\",\n    line: Number.parseInt(lineNumber),\n    column: Number.parseInt(columnNumber)\n  };\n}\nfunction parseSingleStack(raw) {\n  const line = raw.trim();\n  if (!CHROME_IE_STACK_REGEXP.test(line)) {\n    return parseSingleFFOrSafariStack(line);\n  }\n  return parseSingleV8Stack(line);\n}\nfunction parseSingleV8Stack(raw) {\n  let line = raw.trim();\n  if (!CHROME_IE_STACK_REGEXP.test(line)) {\n    return null;\n  }\n  if (line.includes(\"(eval \")) {\n    line = line.replace(/eval code/g, \"eval\").replace(/(\\(eval at [^()]*)|(,.*$)/g, \"\");\n  }\n  let sanitizedLine = line.replace(/^\\s+/, \"\").replace(/\\(eval code/g, \"(\").replace(/^.*?\\s+/, \"\");\n  const location2 = sanitizedLine.match(/ (\\(.+\\)$)/);\n  sanitizedLine = location2 ? sanitizedLine.replace(location2[0], \"\") : sanitizedLine;\n  const [url, lineNumber, columnNumber] = extractLocation(location2 ? location2[1] : sanitizedLine);\n  let method = location2 && sanitizedLine || \"\";\n  let file = url && [\"eval\", \"<anonymous>\"].includes(url) ? void 0 : url;\n  if (!file || !lineNumber || !columnNumber) {\n    return null;\n  }\n  if (method.startsWith(\"async \")) {\n    method = method.slice(6);\n  }\n  if (file.startsWith(\"file://\")) {\n    file = file.slice(7);\n  }\n  file = file.startsWith(\"node:\") || file.startsWith(\"internal:\") ? file : resolve(file);\n  if (method) {\n    method = method.replace(/__vite_ssr_import_\\d+__\\./g, \"\");\n  }\n  return {\n    method,\n    file,\n    line: Number.parseInt(lineNumber),\n    column: Number.parseInt(columnNumber)\n  };\n}\nfunction createCompilerHints(options) {\n  const globalThisAccessor = (options === null || options === void 0 ? void 0 : options.globalThisKey) || \"__vitest_mocker__\";\n  function _mocker() {\n    return typeof globalThis[globalThisAccessor] !== \"undefined\" ? globalThis[globalThisAccessor] : new Proxy({}, { get(_, name) {\n      throw new Error(`Vitest mocker was not initialized in this environment. vi.${String(name)}() is forbidden.`);\n    } });\n  }\n  return {\n    hoisted(factory) {\n      if (typeof factory !== \"function\") {\n        throw new TypeError(`vi.hoisted() expects a function, but received a ${typeof factory}`);\n      }\n      return factory();\n    },\n    mock(path, factory) {\n      if (typeof path !== \"string\") {\n        throw new TypeError(`vi.mock() expects a string path, but received a ${typeof path}`);\n      }\n      const importer = getImporter(\"mock\");\n      _mocker().queueMock(path, importer, typeof factory === \"function\" ? () => factory(() => _mocker().importActual(path, importer)) : factory);\n    },\n    unmock(path) {\n      if (typeof path !== \"string\") {\n        throw new TypeError(`vi.unmock() expects a string path, but received a ${typeof path}`);\n      }\n      _mocker().queueUnmock(path, getImporter(\"unmock\"));\n    },\n    doMock(path, factory) {\n      if (typeof path !== \"string\") {\n        throw new TypeError(`vi.doMock() expects a string path, but received a ${typeof path}`);\n      }\n      const importer = getImporter(\"doMock\");\n      _mocker().queueMock(path, importer, typeof factory === \"function\" ? () => factory(() => _mocker().importActual(path, importer)) : factory);\n    },\n    doUnmock(path) {\n      if (typeof path !== \"string\") {\n        throw new TypeError(`vi.doUnmock() expects a string path, but received a ${typeof path}`);\n      }\n      _mocker().queueUnmock(path, getImporter(\"doUnmock\"));\n    },\n    async importActual(path) {\n      return _mocker().importActual(path, getImporter(\"importActual\"));\n    },\n    async importMock(path) {\n      return _mocker().importMock(path, getImporter(\"importMock\"));\n    }\n  };\n}\nfunction getImporter(name) {\n  const stackTrace = /* @__PURE__ */ createSimpleStackTrace({ stackTraceLimit: 5 });\n  const stackArray = stackTrace.split(\"\\n\");\n  const importerStackIndex = stackArray.findIndex((stack2) => {\n    return stack2.includes(` at Object.${name}`) || stack2.includes(`${name}@`);\n  });\n  const stack = /* @__PURE__ */ parseSingleStack(stackArray[importerStackIndex + 1]);\n  return (stack === null || stack === void 0 ? void 0 : stack.file) || \"\";\n}\nconst hot = {\n  on: warn,\n  off: warn,\n  send: warn\n};\nfunction warn() {\n  console.warn(\"Vitest mocker cannot work if Vite didn't establish WS connection.\");\n}\nfunction rpc(event, data) {\n  hot.send(event, data);\n  return new Promise((resolve2, reject) => {\n    const timeout = setTimeout(() => {\n      reject(new Error(`Failed to resolve ${event} in time`));\n    }, 5e3);\n    hot.on(`${event}:result`, function r(data2) {\n      resolve2(data2);\n      clearTimeout(timeout);\n      hot.off(`${event}:result`, r);\n    });\n  });\n}\nconst { now } = Date;\nclass ModuleMocker {\n  registry = new MockerRegistry();\n  queue = /* @__PURE__ */ new Set();\n  mockedIds = /* @__PURE__ */ new Set();\n  constructor(interceptor, rpc2, spyOn, config) {\n    this.interceptor = interceptor;\n    this.rpc = rpc2;\n    this.spyOn = spyOn;\n    this.config = config;\n  }\n  async prepare() {\n    if (!this.queue.size) {\n      return;\n    }\n    await Promise.all([...this.queue.values()]);\n  }\n  async resolveFactoryModule(id) {\n    const mock = this.registry.get(id);\n    if (!mock || mock.type !== \"manual\") {\n      throw new Error(`Mock ${id} wasn't registered. This is probably a Vitest error. Please, open a new issue with reproduction.`);\n    }\n    const result = await mock.resolve();\n    return result;\n  }\n  getFactoryModule(id) {\n    const mock = this.registry.get(id);\n    if (!mock || mock.type !== \"manual\") {\n      throw new Error(`Mock ${id} wasn't registered. This is probably a Vitest error. Please, open a new issue with reproduction.`);\n    }\n    if (!mock.cache) {\n      throw new Error(`Mock ${id} wasn't resolved. This is probably a Vitest error. Please, open a new issue with reproduction.`);\n    }\n    return mock.cache;\n  }\n  async invalidate() {\n    const ids = Array.from(this.mockedIds);\n    if (!ids.length) {\n      return;\n    }\n    await this.rpc.invalidate(ids);\n    await this.interceptor.invalidate();\n    this.registry.clear();\n  }\n  async importActual(id, importer) {\n    const resolved = await this.rpc.resolveId(id, importer);\n    if (resolved == null) {\n      throw new Error(`[vitest] Cannot resolve \"${id}\" imported from \"${importer}\"`);\n    }\n    const ext = extname(resolved.id);\n    const url = new URL(resolved.url, location.href);\n    const query = `_vitest_original&ext${ext}`;\n    const actualUrl = `${url.pathname}${url.search ? `${url.search}&${query}` : `?${query}`}${url.hash}`;\n    return this.wrapDynamicImport(() => import(\n      /* @vite-ignore */\n      actualUrl\n    )).then((mod) => {\n      if (!resolved.optimized || typeof mod.default === \"undefined\") {\n        return mod;\n      }\n      const m = mod.default;\n      return (m === null || m === void 0 ? void 0 : m.__esModule) ? m : {\n        ...typeof m === \"object\" && !Array.isArray(m) || typeof m === \"function\" ? m : {},\n        default: m\n      };\n    });\n  }\n  async importMock(rawId, importer) {\n    await this.prepare();\n    const { resolvedId, resolvedUrl, redirectUrl } = await this.rpc.resolveMock(rawId, importer, { mock: \"auto\" });\n    const mockUrl = this.resolveMockPath(cleanVersion(resolvedUrl));\n    let mock = this.registry.get(mockUrl);\n    if (!mock) {\n      if (redirectUrl) {\n        const resolvedRedirect = new URL(this.resolveMockPath(cleanVersion(redirectUrl)), location.href).toString();\n        mock = new RedirectedModule(rawId, resolvedId, mockUrl, resolvedRedirect);\n      } else {\n        mock = new AutomockedModule(rawId, resolvedId, mockUrl);\n      }\n    }\n    if (mock.type === \"manual\") {\n      return await mock.resolve();\n    }\n    if (mock.type === \"automock\" || mock.type === \"autospy\") {\n      const url = new URL(`/@id/${resolvedId}`, location.href);\n      const query = url.search ? `${url.search}&t=${now()}` : `?t=${now()}`;\n      const moduleObject = await import(\n        /* @vite-ignore */\n        `${url.pathname}${query}&mock=${mock.type}${url.hash}`\n      );\n      return this.mockObject(moduleObject, mock.type);\n    }\n    return import(\n      /* @vite-ignore */\n      mock.redirect\n    );\n  }\n  mockObject(object, moduleType = \"automock\") {\n    return mockObject({\n      globalConstructors: {\n        Object,\n        Function,\n        Array,\n        Map,\n        RegExp\n      },\n      spyOn: this.spyOn,\n      type: moduleType\n    }, object);\n  }\n  queueMock(rawId, importer, factoryOrOptions) {\n    const promise = this.rpc.resolveMock(rawId, importer, { mock: typeof factoryOrOptions === \"function\" ? \"factory\" : (factoryOrOptions === null || factoryOrOptions === void 0 ? void 0 : factoryOrOptions.spy) ? \"spy\" : \"auto\" }).then(async ({ redirectUrl, resolvedId, resolvedUrl, needsInterop, mockType }) => {\n      const mockUrl = this.resolveMockPath(cleanVersion(resolvedUrl));\n      this.mockedIds.add(resolvedId);\n      const factory = typeof factoryOrOptions === \"function\" ? async () => {\n        const data = await factoryOrOptions();\n        return needsInterop ? { default: data } : data;\n      } : void 0;\n      const mockRedirect = typeof redirectUrl === \"string\" ? new URL(this.resolveMockPath(cleanVersion(redirectUrl)), location.href).toString() : null;\n      let module;\n      if (mockType === \"manual\") {\n        module = this.registry.register(\"manual\", rawId, resolvedId, mockUrl, factory);\n      } else if (mockType === \"autospy\") {\n        module = this.registry.register(\"autospy\", rawId, resolvedId, mockUrl);\n      } else if (mockType === \"redirect\") {\n        module = this.registry.register(\"redirect\", rawId, resolvedId, mockUrl, mockRedirect);\n      } else {\n        module = this.registry.register(\"automock\", rawId, resolvedId, mockUrl);\n      }\n      await this.interceptor.register(module);\n    }).finally(() => {\n      this.queue.delete(promise);\n    });\n    this.queue.add(promise);\n  }\n  queueUnmock(id, importer) {\n    const promise = this.rpc.resolveId(id, importer).then(async (resolved) => {\n      if (!resolved) {\n        return;\n      }\n      const mockUrl = this.resolveMockPath(cleanVersion(resolved.url));\n      this.mockedIds.add(resolved.id);\n      this.registry.delete(mockUrl);\n      await this.interceptor.delete(mockUrl);\n    }).finally(() => {\n      this.queue.delete(promise);\n    });\n    this.queue.add(promise);\n  }\n  // We need to await mock registration before importing the actual module\n  // In case there is a mocked module in the import chain\n  wrapDynamicImport(moduleFactory) {\n    if (typeof moduleFactory === \"function\") {\n      const promise = new Promise((resolve2, reject) => {\n        this.prepare().finally(() => {\n          moduleFactory().then(resolve2, reject);\n        });\n      });\n      return promise;\n    }\n    return moduleFactory;\n  }\n  resolveMockPath(path) {\n    const config = this.config;\n    const fsRoot = join(\"/@fs/\", config.root);\n    if (path.startsWith(config.root)) {\n      return path.slice(config.root.length);\n    }\n    if (path.startsWith(fsRoot)) {\n      return path.slice(fsRoot.length);\n    }\n    return path;\n  }\n}\nconst versionRegexp = /(\\?|&)v=\\w{8}/;\nfunction cleanVersion(url) {\n  return url.replace(versionRegexp, \"\");\n}\nexport { ModuleMocker as M, createCompilerHints as c, hot as h, rpc as r };\n",
      "start": 1762256767055,
      "end": 1762256767099,
      "order": "normal-normal",
      "sourcemaps": null
    },
    {
      "name": "vite:build-html",
      "start": 1762256767100,
      "end": 1762256767100,
      "order": "normal-normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1762256767100,
      "end": 1762256767100,
      "order": "normal-normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1762256767100,
      "end": 1762256767100,
      "order": "normal-normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1762256767102,
      "end": 1762256767102,
      "order": "normal-normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1762256767102,
      "end": 1762256767102,
      "order": "normal-normal"
    },
    {
      "name": "vite-plugin-svelte-module",
      "start": 1762256767102,
      "end": 1762256767102,
      "order": "post"
    },
    {
      "name": "storybook:inject-export-order-plugin",
      "start": 1762256767102,
      "end": 1762256767102,
      "order": "post"
    },
    {
      "name": "storybook:strip-hmr-boundary-plugin",
      "start": 1762256767102,
      "end": 1762256767102,
      "order": "post"
    },
    {
      "name": "storybook:external-globals-plugin",
      "start": 1762256767102,
      "end": 1762256767102,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "result": "import { __vitePreload } from \"\u0000vite/preload-helper.js\";import { mockObject } from \"./index.js\";\nimport { M as MockerRegistry, R as RedirectedModule, A as AutomockedModule } from \"./chunk-registry.js\";\nimport { e as extname, j as join } from \"./chunk-pathe.M-eThtNZ.js\";\nvar f = {\n  reset: [0, 0],\n  bold: [1, 22, \"\\x1B[22m\\x1B[1m\"],\n  dim: [2, 22, \"\\x1B[22m\\x1B[2m\"],\n  italic: [3, 23],\n  underline: [4, 24],\n  inverse: [7, 27],\n  hidden: [8, 28],\n  strikethrough: [9, 29],\n  black: [30, 39],\n  red: [31, 39],\n  green: [32, 39],\n  yellow: [33, 39],\n  blue: [34, 39],\n  magenta: [35, 39],\n  cyan: [36, 39],\n  white: [37, 39],\n  gray: [90, 39],\n  bgBlack: [40, 49],\n  bgRed: [41, 49],\n  bgGreen: [42, 49],\n  bgYellow: [43, 49],\n  bgBlue: [44, 49],\n  bgMagenta: [45, 49],\n  bgCyan: [46, 49],\n  bgWhite: [47, 49],\n  blackBright: [90, 39],\n  redBright: [91, 39],\n  greenBright: [92, 39],\n  yellowBright: [93, 39],\n  blueBright: [94, 39],\n  magentaBright: [95, 39],\n  cyanBright: [96, 39],\n  whiteBright: [97, 39],\n  bgBlackBright: [100, 49],\n  bgRedBright: [101, 49],\n  bgGreenBright: [102, 49],\n  bgYellowBright: [103, 49],\n  bgBlueBright: [104, 49],\n  bgMagentaBright: [105, 49],\n  bgCyanBright: [106, 49],\n  bgWhiteBright: [107, 49]\n}, h = Object.entries(f);\nfunction a(n) {\n  return String(n);\n}\na.open = \"\";\na.close = \"\";\nfunction C(n = false) {\n  let e = typeof process != \"undefined\" ? process : void 0, i = (e == null ? void 0 : e.env) || {}, g = (e == null ? void 0 : e.argv) || [];\n  return !(\"NO_COLOR\" in i || g.includes(\"--no-color\")) && (\"FORCE_COLOR\" in i || g.includes(\"--color\") || (e == null ? void 0 : e.platform) === \"win32\" || n && i.TERM !== \"dumb\" || \"CI\" in i) || typeof window != \"undefined\" && !!window.chrome;\n}\nfunction p(n = false) {\n  let e = C(n), i = (r, t, c, o) => {\n    let l = \"\", s = 0;\n    do\n      l += r.substring(s, o) + c, s = o + t.length, o = r.indexOf(t, s);\n    while (~o);\n    return l + r.substring(s);\n  }, g = (r, t, c = r) => {\n    let o = (l) => {\n      let s = String(l), b = s.indexOf(t, r.length);\n      return ~b ? r + i(s, t, c, b) + t : r + s + t;\n    };\n    return o.open = r, o.close = t, o;\n  }, u = {\n    isColorSupported: e\n  }, d = (r) => `\\x1B[${r}m`;\n  for (let [r, t] of h)\n    u[r] = e ? g(\n      d(t[0]),\n      d(t[1]),\n      t[2]\n    ) : a;\n  return u;\n}\np();\nfunction _mergeNamespaces(n, m) {\n  m.forEach(function(e) {\n    e && typeof e !== \"string\" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n      if (k !== \"default\" && !(k in n)) {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function() {\n            return e[k];\n          }\n        });\n      }\n    });\n  });\n  return Object.freeze(n);\n}\nfunction getDefaultExportFromCjs(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar reactIs$1 = { exports: {} };\nvar reactIs_production = {};\n/**\n* @license React\n* react-is.production.js\n*\n* Copyright (c) Meta Platforms, Inc. and affiliates.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\nvar hasRequiredReactIs_production;\nfunction requireReactIs_production() {\n  if (hasRequiredReactIs_production) return reactIs_production;\n  hasRequiredReactIs_production = 1;\n  var REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"), REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"), REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"), REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"), REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n  var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"), REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"), REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"), REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"), REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"), REACT_MEMO_TYPE = Symbol.for(\"react.memo\"), REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"), REACT_VIEW_TRANSITION_TYPE = Symbol.for(\"react.view_transition\"), REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n  function typeOf(object) {\n    if (\"object\" === typeof object && null !== object) {\n      var $$typeof = object.$$typeof;\n      switch ($$typeof) {\n        case REACT_ELEMENT_TYPE:\n          switch (object = object.type, object) {\n            case REACT_FRAGMENT_TYPE:\n            case REACT_PROFILER_TYPE:\n            case REACT_STRICT_MODE_TYPE:\n            case REACT_SUSPENSE_TYPE:\n            case REACT_SUSPENSE_LIST_TYPE:\n            case REACT_VIEW_TRANSITION_TYPE:\n              return object;\n            default:\n              switch (object = object && object.$$typeof, object) {\n                case REACT_CONTEXT_TYPE:\n                case REACT_FORWARD_REF_TYPE:\n                case REACT_LAZY_TYPE:\n                case REACT_MEMO_TYPE:\n                  return object;\n                case REACT_CONSUMER_TYPE:\n                  return object;\n                default:\n                  return $$typeof;\n              }\n          }\n        case REACT_PORTAL_TYPE:\n          return $$typeof;\n      }\n    }\n  }\n  reactIs_production.ContextConsumer = REACT_CONSUMER_TYPE;\n  reactIs_production.ContextProvider = REACT_CONTEXT_TYPE;\n  reactIs_production.Element = REACT_ELEMENT_TYPE;\n  reactIs_production.ForwardRef = REACT_FORWARD_REF_TYPE;\n  reactIs_production.Fragment = REACT_FRAGMENT_TYPE;\n  reactIs_production.Lazy = REACT_LAZY_TYPE;\n  reactIs_production.Memo = REACT_MEMO_TYPE;\n  reactIs_production.Portal = REACT_PORTAL_TYPE;\n  reactIs_production.Profiler = REACT_PROFILER_TYPE;\n  reactIs_production.StrictMode = REACT_STRICT_MODE_TYPE;\n  reactIs_production.Suspense = REACT_SUSPENSE_TYPE;\n  reactIs_production.SuspenseList = REACT_SUSPENSE_LIST_TYPE;\n  reactIs_production.isContextConsumer = function(object) {\n    return typeOf(object) === REACT_CONSUMER_TYPE;\n  };\n  reactIs_production.isContextProvider = function(object) {\n    return typeOf(object) === REACT_CONTEXT_TYPE;\n  };\n  reactIs_production.isElement = function(object) {\n    return \"object\" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;\n  };\n  reactIs_production.isForwardRef = function(object) {\n    return typeOf(object) === REACT_FORWARD_REF_TYPE;\n  };\n  reactIs_production.isFragment = function(object) {\n    return typeOf(object) === REACT_FRAGMENT_TYPE;\n  };\n  reactIs_production.isLazy = function(object) {\n    return typeOf(object) === REACT_LAZY_TYPE;\n  };\n  reactIs_production.isMemo = function(object) {\n    return typeOf(object) === REACT_MEMO_TYPE;\n  };\n  reactIs_production.isPortal = function(object) {\n    return typeOf(object) === REACT_PORTAL_TYPE;\n  };\n  reactIs_production.isProfiler = function(object) {\n    return typeOf(object) === REACT_PROFILER_TYPE;\n  };\n  reactIs_production.isStrictMode = function(object) {\n    return typeOf(object) === REACT_STRICT_MODE_TYPE;\n  };\n  reactIs_production.isSuspense = function(object) {\n    return typeOf(object) === REACT_SUSPENSE_TYPE;\n  };\n  reactIs_production.isSuspenseList = function(object) {\n    return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;\n  };\n  reactIs_production.isValidElementType = function(type) {\n    return \"string\" === typeof type || \"function\" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || \"object\" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? true : false;\n  };\n  reactIs_production.typeOf = typeOf;\n  return reactIs_production;\n}\nvar reactIs_development$1 = {};\n/**\n* @license React\n* react-is.development.js\n*\n* Copyright (c) Meta Platforms, Inc. and affiliates.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\nvar hasRequiredReactIs_development$1;\nfunction requireReactIs_development$1() {\n  if (hasRequiredReactIs_development$1) return reactIs_development$1;\n  hasRequiredReactIs_development$1 = 1;\n  return reactIs_development$1;\n}\nvar hasRequiredReactIs$1;\nfunction requireReactIs$1() {\n  if (hasRequiredReactIs$1) return reactIs$1.exports;\n  hasRequiredReactIs$1 = 1;\n  if (true) {\n    reactIs$1.exports = requireReactIs_production();\n  } else {\n    reactIs$1.exports = requireReactIs_development$1();\n  }\n  return reactIs$1.exports;\n}\nvar reactIsExports$1 = requireReactIs$1();\nvar index$1 = /* @__PURE__ */ getDefaultExportFromCjs(reactIsExports$1);\nvar ReactIs19 = /* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  default: index$1\n}, [reactIsExports$1]);\nvar reactIs = { exports: {} };\nvar reactIs_production_min = {};\n/**\n* @license React\n* react-is.production.min.js\n*\n* Copyright (c) Facebook, Inc. and its affiliates.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\nvar hasRequiredReactIs_production_min;\nfunction requireReactIs_production_min() {\n  if (hasRequiredReactIs_production_min) return reactIs_production_min;\n  hasRequiredReactIs_production_min = 1;\n  var b = Symbol.for(\"react.element\"), c = Symbol.for(\"react.portal\"), d = Symbol.for(\"react.fragment\"), e = Symbol.for(\"react.strict_mode\"), f2 = Symbol.for(\"react.profiler\"), g = Symbol.for(\"react.provider\"), h2 = Symbol.for(\"react.context\"), k = Symbol.for(\"react.server_context\"), l = Symbol.for(\"react.forward_ref\"), m = Symbol.for(\"react.suspense\"), n = Symbol.for(\"react.suspense_list\"), p2 = Symbol.for(\"react.memo\"), q = Symbol.for(\"react.lazy\"), t = Symbol.for(\"react.offscreen\"), u;\n  u = Symbol.for(\"react.module.reference\");\n  function v(a2) {\n    if (\"object\" === typeof a2 && null !== a2) {\n      var r = a2.$$typeof;\n      switch (r) {\n        case b:\n          switch (a2 = a2.type, a2) {\n            case d:\n            case f2:\n            case e:\n            case m:\n            case n:\n              return a2;\n            default:\n              switch (a2 = a2 && a2.$$typeof, a2) {\n                case k:\n                case h2:\n                case l:\n                case q:\n                case p2:\n                case g:\n                  return a2;\n                default:\n                  return r;\n              }\n          }\n        case c:\n          return r;\n      }\n    }\n  }\n  reactIs_production_min.ContextConsumer = h2;\n  reactIs_production_min.ContextProvider = g;\n  reactIs_production_min.Element = b;\n  reactIs_production_min.ForwardRef = l;\n  reactIs_production_min.Fragment = d;\n  reactIs_production_min.Lazy = q;\n  reactIs_production_min.Memo = p2;\n  reactIs_production_min.Portal = c;\n  reactIs_production_min.Profiler = f2;\n  reactIs_production_min.StrictMode = e;\n  reactIs_production_min.Suspense = m;\n  reactIs_production_min.SuspenseList = n;\n  reactIs_production_min.isAsyncMode = function() {\n    return false;\n  };\n  reactIs_production_min.isConcurrentMode = function() {\n    return false;\n  };\n  reactIs_production_min.isContextConsumer = function(a2) {\n    return v(a2) === h2;\n  };\n  reactIs_production_min.isContextProvider = function(a2) {\n    return v(a2) === g;\n  };\n  reactIs_production_min.isElement = function(a2) {\n    return \"object\" === typeof a2 && null !== a2 && a2.$$typeof === b;\n  };\n  reactIs_production_min.isForwardRef = function(a2) {\n    return v(a2) === l;\n  };\n  reactIs_production_min.isFragment = function(a2) {\n    return v(a2) === d;\n  };\n  reactIs_production_min.isLazy = function(a2) {\n    return v(a2) === q;\n  };\n  reactIs_production_min.isMemo = function(a2) {\n    return v(a2) === p2;\n  };\n  reactIs_production_min.isPortal = function(a2) {\n    return v(a2) === c;\n  };\n  reactIs_production_min.isProfiler = function(a2) {\n    return v(a2) === f2;\n  };\n  reactIs_production_min.isStrictMode = function(a2) {\n    return v(a2) === e;\n  };\n  reactIs_production_min.isSuspense = function(a2) {\n    return v(a2) === m;\n  };\n  reactIs_production_min.isSuspenseList = function(a2) {\n    return v(a2) === n;\n  };\n  reactIs_production_min.isValidElementType = function(a2) {\n    return \"string\" === typeof a2 || \"function\" === typeof a2 || a2 === d || a2 === f2 || a2 === e || a2 === m || a2 === n || a2 === t || \"object\" === typeof a2 && null !== a2 && (a2.$$typeof === q || a2.$$typeof === p2 || a2.$$typeof === g || a2.$$typeof === h2 || a2.$$typeof === l || a2.$$typeof === u || void 0 !== a2.getModuleId) ? true : false;\n  };\n  reactIs_production_min.typeOf = v;\n  return reactIs_production_min;\n}\nvar reactIs_development = {};\n/**\n* @license React\n* react-is.development.js\n*\n* Copyright (c) Facebook, Inc. and its affiliates.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\nvar hasRequiredReactIs_development;\nfunction requireReactIs_development() {\n  if (hasRequiredReactIs_development) return reactIs_development;\n  hasRequiredReactIs_development = 1;\n  if (false) {\n    (function() {\n      var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n      var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n      var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n      var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n      var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n      var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n      var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n      var REACT_SERVER_CONTEXT_TYPE = Symbol.for(\"react.server_context\");\n      var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n      var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n      var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n      var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n      var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n      var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n      var enableScopeAPI = false;\n      var enableCacheElement = false;\n      var enableTransitionTracing = false;\n      var enableLegacyHidden = false;\n      var enableDebugTracing = false;\n      var REACT_MODULE_REFERENCE;\n      {\n        REACT_MODULE_REFERENCE = Symbol.for(\"react.module.reference\");\n      }\n      function isValidElementType(type) {\n        if (typeof type === \"string\" || typeof type === \"function\") {\n          return true;\n        }\n        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n          return true;\n        }\n        if (typeof type === \"object\" && type !== null) {\n          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {\n            return true;\n          }\n        }\n        return false;\n      }\n      function typeOf(object) {\n        if (typeof object === \"object\" && object !== null) {\n          var $$typeof = object.$$typeof;\n          switch ($$typeof) {\n            case REACT_ELEMENT_TYPE:\n              var type = object.type;\n              switch (type) {\n                case REACT_FRAGMENT_TYPE:\n                case REACT_PROFILER_TYPE:\n                case REACT_STRICT_MODE_TYPE:\n                case REACT_SUSPENSE_TYPE:\n                case REACT_SUSPENSE_LIST_TYPE:\n                  return type;\n                default:\n                  var $$typeofType = type && type.$$typeof;\n                  switch ($$typeofType) {\n                    case REACT_SERVER_CONTEXT_TYPE:\n                    case REACT_CONTEXT_TYPE:\n                    case REACT_FORWARD_REF_TYPE:\n                    case REACT_LAZY_TYPE:\n                    case REACT_MEMO_TYPE:\n                    case REACT_PROVIDER_TYPE:\n                      return $$typeofType;\n                    default:\n                      return $$typeof;\n                  }\n              }\n            case REACT_PORTAL_TYPE:\n              return $$typeof;\n          }\n        }\n        return void 0;\n      }\n      var ContextConsumer = REACT_CONTEXT_TYPE;\n      var ContextProvider = REACT_PROVIDER_TYPE;\n      var Element = REACT_ELEMENT_TYPE;\n      var ForwardRef = REACT_FORWARD_REF_TYPE;\n      var Fragment = REACT_FRAGMENT_TYPE;\n      var Lazy = REACT_LAZY_TYPE;\n      var Memo = REACT_MEMO_TYPE;\n      var Portal = REACT_PORTAL_TYPE;\n      var Profiler = REACT_PROFILER_TYPE;\n      var StrictMode = REACT_STRICT_MODE_TYPE;\n      var Suspense = REACT_SUSPENSE_TYPE;\n      var SuspenseList = REACT_SUSPENSE_LIST_TYPE;\n      var hasWarnedAboutDeprecatedIsAsyncMode = false;\n      var hasWarnedAboutDeprecatedIsConcurrentMode = false;\n      function isAsyncMode(object) {\n        {\n          if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n            hasWarnedAboutDeprecatedIsAsyncMode = true;\n            console[\"warn\"](\"The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.\");\n          }\n        }\n        return false;\n      }\n      function isConcurrentMode(object) {\n        {\n          if (!hasWarnedAboutDeprecatedIsConcurrentMode) {\n            hasWarnedAboutDeprecatedIsConcurrentMode = true;\n            console[\"warn\"](\"The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.\");\n          }\n        }\n        return false;\n      }\n      function isContextConsumer(object) {\n        return typeOf(object) === REACT_CONTEXT_TYPE;\n      }\n      function isContextProvider(object) {\n        return typeOf(object) === REACT_PROVIDER_TYPE;\n      }\n      function isElement(object) {\n        return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n      }\n      function isForwardRef(object) {\n        return typeOf(object) === REACT_FORWARD_REF_TYPE;\n      }\n      function isFragment(object) {\n        return typeOf(object) === REACT_FRAGMENT_TYPE;\n      }\n      function isLazy(object) {\n        return typeOf(object) === REACT_LAZY_TYPE;\n      }\n      function isMemo(object) {\n        return typeOf(object) === REACT_MEMO_TYPE;\n      }\n      function isPortal(object) {\n        return typeOf(object) === REACT_PORTAL_TYPE;\n      }\n      function isProfiler(object) {\n        return typeOf(object) === REACT_PROFILER_TYPE;\n      }\n      function isStrictMode(object) {\n        return typeOf(object) === REACT_STRICT_MODE_TYPE;\n      }\n      function isSuspense(object) {\n        return typeOf(object) === REACT_SUSPENSE_TYPE;\n      }\n      function isSuspenseList(object) {\n        return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;\n      }\n      reactIs_development.ContextConsumer = ContextConsumer;\n      reactIs_development.ContextProvider = ContextProvider;\n      reactIs_development.Element = Element;\n      reactIs_development.ForwardRef = ForwardRef;\n      reactIs_development.Fragment = Fragment;\n      reactIs_development.Lazy = Lazy;\n      reactIs_development.Memo = Memo;\n      reactIs_development.Portal = Portal;\n      reactIs_development.Profiler = Profiler;\n      reactIs_development.StrictMode = StrictMode;\n      reactIs_development.Suspense = Suspense;\n      reactIs_development.SuspenseList = SuspenseList;\n      reactIs_development.isAsyncMode = isAsyncMode;\n      reactIs_development.isConcurrentMode = isConcurrentMode;\n      reactIs_development.isContextConsumer = isContextConsumer;\n      reactIs_development.isContextProvider = isContextProvider;\n      reactIs_development.isElement = isElement;\n      reactIs_development.isForwardRef = isForwardRef;\n      reactIs_development.isFragment = isFragment;\n      reactIs_development.isLazy = isLazy;\n      reactIs_development.isMemo = isMemo;\n      reactIs_development.isPortal = isPortal;\n      reactIs_development.isProfiler = isProfiler;\n      reactIs_development.isStrictMode = isStrictMode;\n      reactIs_development.isSuspense = isSuspense;\n      reactIs_development.isSuspenseList = isSuspenseList;\n      reactIs_development.isValidElementType = isValidElementType;\n      reactIs_development.typeOf = typeOf;\n    })();\n  }\n  return reactIs_development;\n}\nvar hasRequiredReactIs;\nfunction requireReactIs() {\n  if (hasRequiredReactIs) return reactIs.exports;\n  hasRequiredReactIs = 1;\n  if (true) {\n    reactIs.exports = requireReactIs_production_min();\n  } else {\n    reactIs.exports = requireReactIs_development();\n  }\n  return reactIs.exports;\n}\nvar reactIsExports = requireReactIs();\nvar index = /* @__PURE__ */ getDefaultExportFromCjs(reactIsExports);\nvar ReactIs18 = /* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  default: index\n}, [reactIsExports]);\nconst reactIsMethods = [\n  \"isAsyncMode\",\n  \"isConcurrentMode\",\n  \"isContextConsumer\",\n  \"isContextProvider\",\n  \"isElement\",\n  \"isForwardRef\",\n  \"isFragment\",\n  \"isLazy\",\n  \"isMemo\",\n  \"isPortal\",\n  \"isProfiler\",\n  \"isStrictMode\",\n  \"isSuspense\",\n  \"isSuspenseList\",\n  \"isValidElementType\"\n];\nObject.fromEntries(reactIsMethods.map((m) => [m, (v) => ReactIs18[m](v) || ReactIs19[m](v)]));\nlet getPromiseValue = () => \"Promise{â€¦}\";\ntry {\n  const { getPromiseDetails, kPending, kRejected } = process.binding(\"util\");\n  if (Array.isArray(getPromiseDetails(Promise.resolve()))) {\n    getPromiseValue = (value, options) => {\n      const [state, innerValue] = getPromiseDetails(value);\n      if (state === kPending) {\n        return \"Promise{<pending>}\";\n      }\n      return `Promise${state === kRejected ? \"!\" : \"\"}{${options.inspect(innerValue, options)}}`;\n    };\n  }\n} catch (notNode) {\n}\nfunction createSimpleStackTrace(options) {\n  const { message = \"$$stack trace error\", stackTraceLimit = 1 } = options || {};\n  const limit = Error.stackTraceLimit;\n  const prepareStackTrace = Error.prepareStackTrace;\n  Error.stackTraceLimit = stackTraceLimit;\n  Error.prepareStackTrace = (e) => e.stack;\n  const err = new Error(message);\n  const stackTrace = err.stack || \"\";\n  Error.prepareStackTrace = prepareStackTrace;\n  Error.stackTraceLimit = limit;\n  return stackTrace;\n}\nvar jsTokens_1;\nvar hasRequiredJsTokens;\nfunction requireJsTokens() {\n  if (hasRequiredJsTokens) return jsTokens_1;\n  hasRequiredJsTokens = 1;\n  var Identifier, JSXIdentifier, JSXPunctuator, JSXString, JSXText, KeywordsWithExpressionAfter, KeywordsWithNoLineTerminatorAfter, LineTerminatorSequence, MultiLineComment, Newline, NumericLiteral, Punctuator, RegularExpressionLiteral, SingleLineComment, StringLiteral, Template, TokensNotPrecedingObjectLiteral, TokensPrecedingExpression, WhiteSpace;\n  RegularExpressionLiteral = /\\/(?![*\\/])(?:\\[(?:(?![\\]\\\\]).|\\\\.)*\\]|(?![\\/\\\\]).|\\\\.)*(\\/[$_\\u200C\\u200D\\p{ID_Continue}]*|\\\\)?/uy;\n  Punctuator = /--|\\+\\+|=>|\\.{3}|\\??\\.(?!\\d)|(?:&&|\\|\\||\\?\\?|[+\\-%&|^]|\\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\\/(?![\\/*]))=?|[?~,:;[\\](){}]/y;\n  Identifier = /(\\x23?)(?=[$_\\p{ID_Start}\\\\])(?:[$_\\u200C\\u200D\\p{ID_Continue}]|\\\\u[\\da-fA-F]{4}|\\\\u\\{[\\da-fA-F]+\\})+/uy;\n  StringLiteral = /(['\"])(?:(?!\\1)[^\\\\\\n\\r]|\\\\(?:\\r\\n|[^]))*(\\1)?/y;\n  NumericLiteral = /(?:0[xX][\\da-fA-F](?:_?[\\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\\d)*n|(?:(?:0(?!\\d)|0\\d*[89]\\d*|[1-9](?:_?\\d)*)(?:\\.(?:\\d(?:_?\\d)*)?)?|\\.\\d(?:_?\\d)*)(?:[eE][+-]?\\d(?:_?\\d)*)?|0[0-7]+/y;\n  Template = /[`}](?:[^`\\\\$]|\\\\[^]|\\$(?!\\{))*(`|\\$\\{)?/y;\n  WhiteSpace = /[\\t\\v\\f\\ufeff\\p{Zs}]+/uy;\n  LineTerminatorSequence = /\\r?\\n|[\\r\\u2028\\u2029]/y;\n  MultiLineComment = /\\/\\*(?:[^*]|\\*(?!\\/))*(\\*\\/)?/y;\n  SingleLineComment = /\\/\\/.*/y;\n  JSXPunctuator = /[<>.:={}]|\\/(?![\\/*])/y;\n  JSXIdentifier = /[$_\\p{ID_Start}][$_\\u200C\\u200D\\p{ID_Continue}-]*/uy;\n  JSXString = /(['\"])(?:(?!\\1)[^])*(\\1)?/y;\n  JSXText = /[^<>{}]+/y;\n  TokensPrecedingExpression = /^(?:[\\/+-]|\\.{3}|\\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/;\n  TokensNotPrecedingObjectLiteral = /^(?:=>|[;\\]){}]|else|\\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/;\n  KeywordsWithExpressionAfter = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/;\n  KeywordsWithNoLineTerminatorAfter = /^(?:return|throw|yield)$/;\n  Newline = RegExp(LineTerminatorSequence.source);\n  jsTokens_1 = function* (input, { jsx = false } = {}) {\n    var braces, firstCodePoint, isExpression, lastIndex, lastSignificantToken, length, match, mode, nextLastIndex, nextLastSignificantToken, parenNesting, postfixIncDec, punctuator, stack;\n    ({ length } = input);\n    lastIndex = 0;\n    lastSignificantToken = \"\";\n    stack = [{ tag: \"JS\" }];\n    braces = [];\n    parenNesting = 0;\n    postfixIncDec = false;\n    while (lastIndex < length) {\n      mode = stack[stack.length - 1];\n      switch (mode.tag) {\n        case \"JS\":\n        case \"JSNonExpressionParen\":\n        case \"InterpolationInTemplate\":\n        case \"InterpolationInJSX\":\n          if (input[lastIndex] === \"/\" && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {\n            RegularExpressionLiteral.lastIndex = lastIndex;\n            if (match = RegularExpressionLiteral.exec(input)) {\n              lastIndex = RegularExpressionLiteral.lastIndex;\n              lastSignificantToken = match[0];\n              postfixIncDec = true;\n              yield {\n                type: \"RegularExpressionLiteral\",\n                value: match[0],\n                closed: match[1] !== void 0 && match[1] !== \"\\\\\"\n              };\n              continue;\n            }\n          }\n          Punctuator.lastIndex = lastIndex;\n          if (match = Punctuator.exec(input)) {\n            punctuator = match[0];\n            nextLastIndex = Punctuator.lastIndex;\n            nextLastSignificantToken = punctuator;\n            switch (punctuator) {\n              case \"(\":\n                if (lastSignificantToken === \"?NonExpressionParenKeyword\") {\n                  stack.push({\n                    tag: \"JSNonExpressionParen\",\n                    nesting: parenNesting\n                  });\n                }\n                parenNesting++;\n                postfixIncDec = false;\n                break;\n              case \")\":\n                parenNesting--;\n                postfixIncDec = true;\n                if (mode.tag === \"JSNonExpressionParen\" && parenNesting === mode.nesting) {\n                  stack.pop();\n                  nextLastSignificantToken = \"?NonExpressionParenEnd\";\n                  postfixIncDec = false;\n                }\n                break;\n              case \"{\":\n                Punctuator.lastIndex = 0;\n                isExpression = !TokensNotPrecedingObjectLiteral.test(lastSignificantToken) && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken));\n                braces.push(isExpression);\n                postfixIncDec = false;\n                break;\n              case \"}\":\n                switch (mode.tag) {\n                  case \"InterpolationInTemplate\":\n                    if (braces.length === mode.nesting) {\n                      Template.lastIndex = lastIndex;\n                      match = Template.exec(input);\n                      lastIndex = Template.lastIndex;\n                      lastSignificantToken = match[0];\n                      if (match[1] === \"${\") {\n                        lastSignificantToken = \"?InterpolationInTemplate\";\n                        postfixIncDec = false;\n                        yield {\n                          type: \"TemplateMiddle\",\n                          value: match[0]\n                        };\n                      } else {\n                        stack.pop();\n                        postfixIncDec = true;\n                        yield {\n                          type: \"TemplateTail\",\n                          value: match[0],\n                          closed: match[1] === \"`\"\n                        };\n                      }\n                      continue;\n                    }\n                    break;\n                  case \"InterpolationInJSX\":\n                    if (braces.length === mode.nesting) {\n                      stack.pop();\n                      lastIndex += 1;\n                      lastSignificantToken = \"}\";\n                      yield {\n                        type: \"JSXPunctuator\",\n                        value: \"}\"\n                      };\n                      continue;\n                    }\n                }\n                postfixIncDec = braces.pop();\n                nextLastSignificantToken = postfixIncDec ? \"?ExpressionBraceEnd\" : \"}\";\n                break;\n              case \"]\":\n                postfixIncDec = true;\n                break;\n              case \"++\":\n              case \"--\":\n                nextLastSignificantToken = postfixIncDec ? \"?PostfixIncDec\" : \"?UnaryIncDec\";\n                break;\n              case \"<\":\n                if (jsx && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {\n                  stack.push({ tag: \"JSXTag\" });\n                  lastIndex += 1;\n                  lastSignificantToken = \"<\";\n                  yield {\n                    type: \"JSXPunctuator\",\n                    value: punctuator\n                  };\n                  continue;\n                }\n                postfixIncDec = false;\n                break;\n              default:\n                postfixIncDec = false;\n            }\n            lastIndex = nextLastIndex;\n            lastSignificantToken = nextLastSignificantToken;\n            yield {\n              type: \"Punctuator\",\n              value: punctuator\n            };\n            continue;\n          }\n          Identifier.lastIndex = lastIndex;\n          if (match = Identifier.exec(input)) {\n            lastIndex = Identifier.lastIndex;\n            nextLastSignificantToken = match[0];\n            switch (match[0]) {\n              case \"for\":\n              case \"if\":\n              case \"while\":\n              case \"with\":\n                if (lastSignificantToken !== \".\" && lastSignificantToken !== \"?.\") {\n                  nextLastSignificantToken = \"?NonExpressionParenKeyword\";\n                }\n            }\n            lastSignificantToken = nextLastSignificantToken;\n            postfixIncDec = !KeywordsWithExpressionAfter.test(match[0]);\n            yield {\n              type: match[1] === \"#\" ? \"PrivateIdentifier\" : \"IdentifierName\",\n              value: match[0]\n            };\n            continue;\n          }\n          StringLiteral.lastIndex = lastIndex;\n          if (match = StringLiteral.exec(input)) {\n            lastIndex = StringLiteral.lastIndex;\n            lastSignificantToken = match[0];\n            postfixIncDec = true;\n            yield {\n              type: \"StringLiteral\",\n              value: match[0],\n              closed: match[2] !== void 0\n            };\n            continue;\n          }\n          NumericLiteral.lastIndex = lastIndex;\n          if (match = NumericLiteral.exec(input)) {\n            lastIndex = NumericLiteral.lastIndex;\n            lastSignificantToken = match[0];\n            postfixIncDec = true;\n            yield {\n              type: \"NumericLiteral\",\n              value: match[0]\n            };\n            continue;\n          }\n          Template.lastIndex = lastIndex;\n          if (match = Template.exec(input)) {\n            lastIndex = Template.lastIndex;\n            lastSignificantToken = match[0];\n            if (match[1] === \"${\") {\n              lastSignificantToken = \"?InterpolationInTemplate\";\n              stack.push({\n                tag: \"InterpolationInTemplate\",\n                nesting: braces.length\n              });\n              postfixIncDec = false;\n              yield {\n                type: \"TemplateHead\",\n                value: match[0]\n              };\n            } else {\n              postfixIncDec = true;\n              yield {\n                type: \"NoSubstitutionTemplate\",\n                value: match[0],\n                closed: match[1] === \"`\"\n              };\n            }\n            continue;\n          }\n          break;\n        case \"JSXTag\":\n        case \"JSXTagEnd\":\n          JSXPunctuator.lastIndex = lastIndex;\n          if (match = JSXPunctuator.exec(input)) {\n            lastIndex = JSXPunctuator.lastIndex;\n            nextLastSignificantToken = match[0];\n            switch (match[0]) {\n              case \"<\":\n                stack.push({ tag: \"JSXTag\" });\n                break;\n              case \">\":\n                stack.pop();\n                if (lastSignificantToken === \"/\" || mode.tag === \"JSXTagEnd\") {\n                  nextLastSignificantToken = \"?JSX\";\n                  postfixIncDec = true;\n                } else {\n                  stack.push({ tag: \"JSXChildren\" });\n                }\n                break;\n              case \"{\":\n                stack.push({\n                  tag: \"InterpolationInJSX\",\n                  nesting: braces.length\n                });\n                nextLastSignificantToken = \"?InterpolationInJSX\";\n                postfixIncDec = false;\n                break;\n              case \"/\":\n                if (lastSignificantToken === \"<\") {\n                  stack.pop();\n                  if (stack[stack.length - 1].tag === \"JSXChildren\") {\n                    stack.pop();\n                  }\n                  stack.push({ tag: \"JSXTagEnd\" });\n                }\n            }\n            lastSignificantToken = nextLastSignificantToken;\n            yield {\n              type: \"JSXPunctuator\",\n              value: match[0]\n            };\n            continue;\n          }\n          JSXIdentifier.lastIndex = lastIndex;\n          if (match = JSXIdentifier.exec(input)) {\n            lastIndex = JSXIdentifier.lastIndex;\n            lastSignificantToken = match[0];\n            yield {\n              type: \"JSXIdentifier\",\n              value: match[0]\n            };\n            continue;\n          }\n          JSXString.lastIndex = lastIndex;\n          if (match = JSXString.exec(input)) {\n            lastIndex = JSXString.lastIndex;\n            lastSignificantToken = match[0];\n            yield {\n              type: \"JSXString\",\n              value: match[0],\n              closed: match[2] !== void 0\n            };\n            continue;\n          }\n          break;\n        case \"JSXChildren\":\n          JSXText.lastIndex = lastIndex;\n          if (match = JSXText.exec(input)) {\n            lastIndex = JSXText.lastIndex;\n            lastSignificantToken = match[0];\n            yield {\n              type: \"JSXText\",\n              value: match[0]\n            };\n            continue;\n          }\n          switch (input[lastIndex]) {\n            case \"<\":\n              stack.push({ tag: \"JSXTag\" });\n              lastIndex++;\n              lastSignificantToken = \"<\";\n              yield {\n                type: \"JSXPunctuator\",\n                value: \"<\"\n              };\n              continue;\n            case \"{\":\n              stack.push({\n                tag: \"InterpolationInJSX\",\n                nesting: braces.length\n              });\n              lastIndex++;\n              lastSignificantToken = \"?InterpolationInJSX\";\n              postfixIncDec = false;\n              yield {\n                type: \"JSXPunctuator\",\n                value: \"{\"\n              };\n              continue;\n          }\n      }\n      WhiteSpace.lastIndex = lastIndex;\n      if (match = WhiteSpace.exec(input)) {\n        lastIndex = WhiteSpace.lastIndex;\n        yield {\n          type: \"WhiteSpace\",\n          value: match[0]\n        };\n        continue;\n      }\n      LineTerminatorSequence.lastIndex = lastIndex;\n      if (match = LineTerminatorSequence.exec(input)) {\n        lastIndex = LineTerminatorSequence.lastIndex;\n        postfixIncDec = false;\n        if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {\n          lastSignificantToken = \"?NoLineTerminatorHere\";\n        }\n        yield {\n          type: \"LineTerminatorSequence\",\n          value: match[0]\n        };\n        continue;\n      }\n      MultiLineComment.lastIndex = lastIndex;\n      if (match = MultiLineComment.exec(input)) {\n        lastIndex = MultiLineComment.lastIndex;\n        if (Newline.test(match[0])) {\n          postfixIncDec = false;\n          if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {\n            lastSignificantToken = \"?NoLineTerminatorHere\";\n          }\n        }\n        yield {\n          type: \"MultiLineComment\",\n          value: match[0],\n          closed: match[1] !== void 0\n        };\n        continue;\n      }\n      SingleLineComment.lastIndex = lastIndex;\n      if (match = SingleLineComment.exec(input)) {\n        lastIndex = SingleLineComment.lastIndex;\n        postfixIncDec = false;\n        yield {\n          type: \"SingleLineComment\",\n          value: match[0]\n        };\n        continue;\n      }\n      firstCodePoint = String.fromCodePoint(input.codePointAt(lastIndex));\n      lastIndex += firstCodePoint.length;\n      lastSignificantToken = firstCodePoint;\n      postfixIncDec = false;\n      yield {\n        type: mode.tag.startsWith(\"JSX\") ? \"JSXInvalid\" : \"Invalid\",\n        value: firstCodePoint\n      };\n    }\n    return void 0;\n  };\n  return jsTokens_1;\n}\nrequireJsTokens();\nvar reservedWords = {\n  keyword: [\n    \"break\",\n    \"case\",\n    \"catch\",\n    \"continue\",\n    \"debugger\",\n    \"default\",\n    \"do\",\n    \"else\",\n    \"finally\",\n    \"for\",\n    \"function\",\n    \"if\",\n    \"return\",\n    \"switch\",\n    \"throw\",\n    \"try\",\n    \"var\",\n    \"const\",\n    \"while\",\n    \"with\",\n    \"new\",\n    \"this\",\n    \"super\",\n    \"class\",\n    \"extends\",\n    \"export\",\n    \"import\",\n    \"null\",\n    \"true\",\n    \"false\",\n    \"in\",\n    \"instanceof\",\n    \"typeof\",\n    \"void\",\n    \"delete\"\n  ],\n  strict: [\n    \"implements\",\n    \"interface\",\n    \"let\",\n    \"package\",\n    \"private\",\n    \"protected\",\n    \"public\",\n    \"static\",\n    \"yield\"\n  ]\n};\nnew Set(reservedWords.keyword);\nnew Set(reservedWords.strict);\nconst chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nconst intToChar = new Uint8Array(64);\nconst charToInt = new Uint8Array(128);\nfor (let i = 0; i < chars.length; i++) {\n  const c = chars.charCodeAt(i);\n  intToChar[i] = c;\n  charToInt[c] = i;\n}\nvar UrlType;\n(function(UrlType2) {\n  UrlType2[UrlType2[\"Empty\"] = 1] = \"Empty\";\n  UrlType2[UrlType2[\"Hash\"] = 2] = \"Hash\";\n  UrlType2[UrlType2[\"Query\"] = 3] = \"Query\";\n  UrlType2[UrlType2[\"RelativePath\"] = 4] = \"RelativePath\";\n  UrlType2[UrlType2[\"AbsolutePath\"] = 5] = \"AbsolutePath\";\n  UrlType2[UrlType2[\"SchemeRelative\"] = 6] = \"SchemeRelative\";\n  UrlType2[UrlType2[\"Absolute\"] = 7] = \"Absolute\";\n})(UrlType || (UrlType = {}));\nconst _DRIVE_LETTER_START_RE = /^[A-Za-z]:\\//;\nfunction normalizeWindowsPath(input = \"\") {\n  if (!input) {\n    return input;\n  }\n  return input.replace(/\\\\/g, \"/\").replace(_DRIVE_LETTER_START_RE, (r) => r.toUpperCase());\n}\nconst _IS_ABSOLUTE_RE = /^[/\\\\](?![/\\\\])|^[/\\\\]{2}(?!\\.)|^[A-Za-z]:[/\\\\]/;\nfunction cwd() {\n  if (typeof process !== \"undefined\" && typeof process.cwd === \"function\") {\n    return process.cwd().replace(/\\\\/g, \"/\");\n  }\n  return \"/\";\n}\nconst resolve = function(...arguments_) {\n  arguments_ = arguments_.map((argument) => normalizeWindowsPath(argument));\n  let resolvedPath = \"\";\n  let resolvedAbsolute = false;\n  for (let index2 = arguments_.length - 1; index2 >= -1 && !resolvedAbsolute; index2--) {\n    const path = index2 >= 0 ? arguments_[index2] : cwd();\n    if (!path || path.length === 0) {\n      continue;\n    }\n    resolvedPath = `${path}/${resolvedPath}`;\n    resolvedAbsolute = isAbsolute(path);\n  }\n  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute);\n  if (resolvedAbsolute && !isAbsolute(resolvedPath)) {\n    return `/${resolvedPath}`;\n  }\n  return resolvedPath.length > 0 ? resolvedPath : \".\";\n};\nfunction normalizeString(path, allowAboveRoot) {\n  let res = \"\";\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let char = null;\n  for (let index2 = 0; index2 <= path.length; ++index2) {\n    if (index2 < path.length) {\n      char = path[index2];\n    } else if (char === \"/\") {\n      break;\n    } else {\n      char = \"/\";\n    }\n    if (char === \"/\") {\n      if (lastSlash === index2 - 1 || dots === 1) ;\n      else if (dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== \".\" || res[res.length - 2] !== \".\") {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(\"/\");\n            if (lastSlashIndex === -1) {\n              res = \"\";\n              lastSegmentLength = 0;\n            } else {\n              res = res.slice(0, lastSlashIndex);\n              lastSegmentLength = res.length - 1 - res.lastIndexOf(\"/\");\n            }\n            lastSlash = index2;\n            dots = 0;\n            continue;\n          } else if (res.length > 0) {\n            res = \"\";\n            lastSegmentLength = 0;\n            lastSlash = index2;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          res += res.length > 0 ? \"/..\" : \"..\";\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) {\n          res += `/${path.slice(lastSlash + 1, index2)}`;\n        } else {\n          res = path.slice(lastSlash + 1, index2);\n        }\n        lastSegmentLength = index2 - lastSlash - 1;\n      }\n      lastSlash = index2;\n      dots = 0;\n    } else if (char === \".\" && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\nconst isAbsolute = function(p2) {\n  return _IS_ABSOLUTE_RE.test(p2);\n};\nconst CHROME_IE_STACK_REGEXP = /^\\s*at .*(?:\\S:\\d+|\\(native\\))/m;\nconst SAFARI_NATIVE_CODE_REGEXP = /^(?:eval@)?(?:\\[native code\\])?$/;\nfunction extractLocation(urlLike) {\n  if (!urlLike.includes(\":\")) {\n    return [urlLike];\n  }\n  const regExp = /(.+?)(?::(\\d+))?(?::(\\d+))?$/;\n  const parts = regExp.exec(urlLike.replace(/^\\(|\\)$/g, \"\"));\n  if (!parts) {\n    return [urlLike];\n  }\n  let url = parts[1];\n  if (url.startsWith(\"async \")) {\n    url = url.slice(6);\n  }\n  if (url.startsWith(\"http:\") || url.startsWith(\"https:\")) {\n    const urlObj = new URL(url);\n    urlObj.searchParams.delete(\"import\");\n    urlObj.searchParams.delete(\"browserv\");\n    url = urlObj.pathname + urlObj.hash + urlObj.search;\n  }\n  if (url.startsWith(\"/@fs/\")) {\n    const isWindows = /^\\/@fs\\/[a-zA-Z]:\\//.test(url);\n    url = url.slice(isWindows ? 5 : 4);\n  }\n  return [\n    url,\n    parts[2] || void 0,\n    parts[3] || void 0\n  ];\n}\nfunction parseSingleFFOrSafariStack(raw) {\n  let line = raw.trim();\n  if (SAFARI_NATIVE_CODE_REGEXP.test(line)) {\n    return null;\n  }\n  if (line.includes(\" > eval\")) {\n    line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g, \":$1\");\n  }\n  if (!line.includes(\"@\") && !line.includes(\":\")) {\n    return null;\n  }\n  const functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(@)/;\n  const matches = line.match(functionNameRegex);\n  const functionName = matches && matches[1] ? matches[1] : void 0;\n  const [url, lineNumber, columnNumber] = extractLocation(line.replace(functionNameRegex, \"\"));\n  if (!url || !lineNumber || !columnNumber) {\n    return null;\n  }\n  return {\n    file: url,\n    method: functionName || \"\",\n    line: Number.parseInt(lineNumber),\n    column: Number.parseInt(columnNumber)\n  };\n}\nfunction parseSingleStack(raw) {\n  const line = raw.trim();\n  if (!CHROME_IE_STACK_REGEXP.test(line)) {\n    return parseSingleFFOrSafariStack(line);\n  }\n  return parseSingleV8Stack(line);\n}\nfunction parseSingleV8Stack(raw) {\n  let line = raw.trim();\n  if (!CHROME_IE_STACK_REGEXP.test(line)) {\n    return null;\n  }\n  if (line.includes(\"(eval \")) {\n    line = line.replace(/eval code/g, \"eval\").replace(/(\\(eval at [^()]*)|(,.*$)/g, \"\");\n  }\n  let sanitizedLine = line.replace(/^\\s+/, \"\").replace(/\\(eval code/g, \"(\").replace(/^.*?\\s+/, \"\");\n  const location2 = sanitizedLine.match(/ (\\(.+\\)$)/);\n  sanitizedLine = location2 ? sanitizedLine.replace(location2[0], \"\") : sanitizedLine;\n  const [url, lineNumber, columnNumber] = extractLocation(location2 ? location2[1] : sanitizedLine);\n  let method = location2 && sanitizedLine || \"\";\n  let file = url && [\"eval\", \"<anonymous>\"].includes(url) ? void 0 : url;\n  if (!file || !lineNumber || !columnNumber) {\n    return null;\n  }\n  if (method.startsWith(\"async \")) {\n    method = method.slice(6);\n  }\n  if (file.startsWith(\"file://\")) {\n    file = file.slice(7);\n  }\n  file = file.startsWith(\"node:\") || file.startsWith(\"internal:\") ? file : resolve(file);\n  if (method) {\n    method = method.replace(/__vite_ssr_import_\\d+__\\./g, \"\");\n  }\n  return {\n    method,\n    file,\n    line: Number.parseInt(lineNumber),\n    column: Number.parseInt(columnNumber)\n  };\n}\nfunction createCompilerHints(options) {\n  const globalThisAccessor = (options === null || options === void 0 ? void 0 : options.globalThisKey) || \"__vitest_mocker__\";\n  function _mocker() {\n    return typeof globalThis[globalThisAccessor] !== \"undefined\" ? globalThis[globalThisAccessor] : new Proxy({}, { get(_, name) {\n      throw new Error(`Vitest mocker was not initialized in this environment. vi.${String(name)}() is forbidden.`);\n    } });\n  }\n  return {\n    hoisted(factory) {\n      if (typeof factory !== \"function\") {\n        throw new TypeError(`vi.hoisted() expects a function, but received a ${typeof factory}`);\n      }\n      return factory();\n    },\n    mock(path, factory) {\n      if (typeof path !== \"string\") {\n        throw new TypeError(`vi.mock() expects a string path, but received a ${typeof path}`);\n      }\n      const importer = getImporter(\"mock\");\n      _mocker().queueMock(path, importer, typeof factory === \"function\" ? () => factory(() => _mocker().importActual(path, importer)) : factory);\n    },\n    unmock(path) {\n      if (typeof path !== \"string\") {\n        throw new TypeError(`vi.unmock() expects a string path, but received a ${typeof path}`);\n      }\n      _mocker().queueUnmock(path, getImporter(\"unmock\"));\n    },\n    doMock(path, factory) {\n      if (typeof path !== \"string\") {\n        throw new TypeError(`vi.doMock() expects a string path, but received a ${typeof path}`);\n      }\n      const importer = getImporter(\"doMock\");\n      _mocker().queueMock(path, importer, typeof factory === \"function\" ? () => factory(() => _mocker().importActual(path, importer)) : factory);\n    },\n    doUnmock(path) {\n      if (typeof path !== \"string\") {\n        throw new TypeError(`vi.doUnmock() expects a string path, but received a ${typeof path}`);\n      }\n      _mocker().queueUnmock(path, getImporter(\"doUnmock\"));\n    },\n    async importActual(path) {\n      return _mocker().importActual(path, getImporter(\"importActual\"));\n    },\n    async importMock(path) {\n      return _mocker().importMock(path, getImporter(\"importMock\"));\n    }\n  };\n}\nfunction getImporter(name) {\n  const stackTrace = /* @__PURE__ */ createSimpleStackTrace({ stackTraceLimit: 5 });\n  const stackArray = stackTrace.split(\"\\n\");\n  const importerStackIndex = stackArray.findIndex((stack2) => {\n    return stack2.includes(` at Object.${name}`) || stack2.includes(`${name}@`);\n  });\n  const stack = /* @__PURE__ */ parseSingleStack(stackArray[importerStackIndex + 1]);\n  return (stack === null || stack === void 0 ? void 0 : stack.file) || \"\";\n}\nconst hot = {\n  on: warn,\n  off: warn,\n  send: warn\n};\nfunction warn() {\n  console.warn(\"Vitest mocker cannot work if Vite didn't establish WS connection.\");\n}\nfunction rpc(event, data) {\n  hot.send(event, data);\n  return new Promise((resolve2, reject) => {\n    const timeout = setTimeout(() => {\n      reject(new Error(`Failed to resolve ${event} in time`));\n    }, 5e3);\n    hot.on(`${event}:result`, function r(data2) {\n      resolve2(data2);\n      clearTimeout(timeout);\n      hot.off(`${event}:result`, r);\n    });\n  });\n}\nconst { now } = Date;\nclass ModuleMocker {\n  registry = new MockerRegistry();\n  queue = /* @__PURE__ */ new Set();\n  mockedIds = /* @__PURE__ */ new Set();\n  constructor(interceptor, rpc2, spyOn, config) {\n    this.interceptor = interceptor;\n    this.rpc = rpc2;\n    this.spyOn = spyOn;\n    this.config = config;\n  }\n  async prepare() {\n    if (!this.queue.size) {\n      return;\n    }\n    await Promise.all([...this.queue.values()]);\n  }\n  async resolveFactoryModule(id) {\n    const mock = this.registry.get(id);\n    if (!mock || mock.type !== \"manual\") {\n      throw new Error(`Mock ${id} wasn't registered. This is probably a Vitest error. Please, open a new issue with reproduction.`);\n    }\n    const result = await mock.resolve();\n    return result;\n  }\n  getFactoryModule(id) {\n    const mock = this.registry.get(id);\n    if (!mock || mock.type !== \"manual\") {\n      throw new Error(`Mock ${id} wasn't registered. This is probably a Vitest error. Please, open a new issue with reproduction.`);\n    }\n    if (!mock.cache) {\n      throw new Error(`Mock ${id} wasn't resolved. This is probably a Vitest error. Please, open a new issue with reproduction.`);\n    }\n    return mock.cache;\n  }\n  async invalidate() {\n    const ids = Array.from(this.mockedIds);\n    if (!ids.length) {\n      return;\n    }\n    await this.rpc.invalidate(ids);\n    await this.interceptor.invalidate();\n    this.registry.clear();\n  }\n  async importActual(id, importer) {\n    const resolved = await this.rpc.resolveId(id, importer);\n    if (resolved == null) {\n      throw new Error(`[vitest] Cannot resolve \"${id}\" imported from \"${importer}\"`);\n    }\n    const ext = extname(resolved.id);\n    const url = new URL(resolved.url, location.href);\n    const query = `_vitest_original&ext${ext}`;\n    const actualUrl = `${url.pathname}${url.search ? `${url.search}&${query}` : `?${query}`}${url.hash}`;\n    return this.wrapDynamicImport(() => import(\n      /* @vite-ignore */\n      actualUrl\n    )).then((mod) => {\n      if (!resolved.optimized || typeof mod.default === \"undefined\") {\n        return mod;\n      }\n      const m = mod.default;\n      return (m === null || m === void 0 ? void 0 : m.__esModule) ? m : {\n        ...typeof m === \"object\" && !Array.isArray(m) || typeof m === \"function\" ? m : {},\n        default: m\n      };\n    });\n  }\n  async importMock(rawId, importer) {\n    await this.prepare();\n    const { resolvedId, resolvedUrl, redirectUrl } = await this.rpc.resolveMock(rawId, importer, { mock: \"auto\" });\n    const mockUrl = this.resolveMockPath(cleanVersion(resolvedUrl));\n    let mock = this.registry.get(mockUrl);\n    if (!mock) {\n      if (redirectUrl) {\n        const resolvedRedirect = new URL(this.resolveMockPath(cleanVersion(redirectUrl)), location.href).toString();\n        mock = new RedirectedModule(rawId, resolvedId, mockUrl, resolvedRedirect);\n      } else {\n        mock = new AutomockedModule(rawId, resolvedId, mockUrl);\n      }\n    }\n    if (mock.type === \"manual\") {\n      return await mock.resolve();\n    }\n    if (mock.type === \"automock\" || mock.type === \"autospy\") {\n      const url = new URL(`/@id/${resolvedId}`, location.href);\n      const query = url.search ? `${url.search}&t=${now()}` : `?t=${now()}`;\n      const moduleObject = await __vitePreload(() => import(\n        /* @vite-ignore */\n        `${url.pathname}${query}&mock=${mock.type}${url.hash}`\n      ),__VITE_IS_MODERN__?__VITE_PRELOAD__:void 0,import.meta.url);\n      return this.mockObject(moduleObject, mock.type);\n    }\n    return import(\n      /* @vite-ignore */\n      mock.redirect\n    );\n  }\n  mockObject(object, moduleType = \"automock\") {\n    return mockObject({\n      globalConstructors: {\n        Object,\n        Function,\n        Array,\n        Map,\n        RegExp\n      },\n      spyOn: this.spyOn,\n      type: moduleType\n    }, object);\n  }\n  queueMock(rawId, importer, factoryOrOptions) {\n    const promise = this.rpc.resolveMock(rawId, importer, { mock: typeof factoryOrOptions === \"function\" ? \"factory\" : (factoryOrOptions === null || factoryOrOptions === void 0 ? void 0 : factoryOrOptions.spy) ? \"spy\" : \"auto\" }).then(async ({ redirectUrl, resolvedId, resolvedUrl, needsInterop, mockType }) => {\n      const mockUrl = this.resolveMockPath(cleanVersion(resolvedUrl));\n      this.mockedIds.add(resolvedId);\n      const factory = typeof factoryOrOptions === \"function\" ? async () => {\n        const data = await factoryOrOptions();\n        return needsInterop ? { default: data } : data;\n      } : void 0;\n      const mockRedirect = typeof redirectUrl === \"string\" ? new URL(this.resolveMockPath(cleanVersion(redirectUrl)), location.href).toString() : null;\n      let module;\n      if (mockType === \"manual\") {\n        module = this.registry.register(\"manual\", rawId, resolvedId, mockUrl, factory);\n      } else if (mockType === \"autospy\") {\n        module = this.registry.register(\"autospy\", rawId, resolvedId, mockUrl);\n      } else if (mockType === \"redirect\") {\n        module = this.registry.register(\"redirect\", rawId, resolvedId, mockUrl, mockRedirect);\n      } else {\n        module = this.registry.register(\"automock\", rawId, resolvedId, mockUrl);\n      }\n      await this.interceptor.register(module);\n    }).finally(() => {\n      this.queue.delete(promise);\n    });\n    this.queue.add(promise);\n  }\n  queueUnmock(id, importer) {\n    const promise = this.rpc.resolveId(id, importer).then(async (resolved) => {\n      if (!resolved) {\n        return;\n      }\n      const mockUrl = this.resolveMockPath(cleanVersion(resolved.url));\n      this.mockedIds.add(resolved.id);\n      this.registry.delete(mockUrl);\n      await this.interceptor.delete(mockUrl);\n    }).finally(() => {\n      this.queue.delete(promise);\n    });\n    this.queue.add(promise);\n  }\n  // We need to await mock registration before importing the actual module\n  // In case there is a mocked module in the import chain\n  wrapDynamicImport(moduleFactory) {\n    if (typeof moduleFactory === \"function\") {\n      const promise = new Promise((resolve2, reject) => {\n        this.prepare().finally(() => {\n          moduleFactory().then(resolve2, reject);\n        });\n      });\n      return promise;\n    }\n    return moduleFactory;\n  }\n  resolveMockPath(path) {\n    const config = this.config;\n    const fsRoot = join(\"/@fs/\", config.root);\n    if (path.startsWith(config.root)) {\n      return path.slice(config.root.length);\n    }\n    if (path.startsWith(fsRoot)) {\n      return path.slice(fsRoot.length);\n    }\n    return path;\n  }\n}\nconst versionRegexp = /(\\?|&)v=\\w{8}/;\nfunction cleanVersion(url) {\n  return url.replace(versionRegexp, \"\");\n}\nexport { ModuleMocker as M, createCompilerHints as c, hot as h, rpc as r };\n",
      "start": 1762256767102,
      "end": 1762256767103,
      "order": "normal-normal",
      "sourcemaps": null
    },
    {
      "name": "vite:reporter",
      "start": 1762256767103,
      "end": 1762256767103,
      "order": "normal"
    }
  ]
}
