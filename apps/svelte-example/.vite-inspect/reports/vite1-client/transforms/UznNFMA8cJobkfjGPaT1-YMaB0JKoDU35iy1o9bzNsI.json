{
  "resolvedId": "/Users/teimurgasanov/Projects/avatune/node_modules/storybook/dist/_browser-chunks/chunk-B4A3ADP3.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import {\n  mapValues\n} from \"./chunk-UTNZYD2N.js\";\nimport {\n  isPlainObject\n} from \"./chunk-FSBVR7H5.js\";\nimport {\n  __commonJS,\n  __name,\n  __toESM\n} from \"./chunk-MM7DTO55.js\";\n\n// ../node_modules/jsdoc-type-pratt-parser/dist/index.js\nvar require_dist = __commonJS({\n  \"../node_modules/jsdoc-type-pratt-parser/dist/index.js\"(exports, module) {\n    (function(global, factory) {\n      typeof exports === \"object\" && typeof module !== \"undefined\" ? factory(exports) : typeof define === \"function\" && define.amd ? define([\"exports\"], factory) : (global = typeof globalThis !== \"undefined\" ? globalThis : global || self, factory(global.jtpp = {}));\n    })(exports, function(exports2) {\n      \"use strict\";\n      function tokenToString(token) {\n        if (token.text !== void 0 && token.text !== \"\") {\n          return `'${token.type}' with value '${token.text}'`;\n        } else {\n          return `'${token.type}'`;\n        }\n      }\n      __name(tokenToString, \"tokenToString\");\n      const _NoParsletFoundError = class _NoParsletFoundError extends Error {\n        constructor(token) {\n          super(`No parslet found for token: ${tokenToString(token)}`);\n          this.token = token;\n          Object.setPrototypeOf(this, _NoParsletFoundError.prototype);\n        }\n        getToken() {\n          return this.token;\n        }\n      };\n      __name(_NoParsletFoundError, \"NoParsletFoundError\");\n      let NoParsletFoundError = _NoParsletFoundError;\n      const _EarlyEndOfParseError = class _EarlyEndOfParseError extends Error {\n        constructor(token) {\n          super(`The parsing ended early. The next token was: ${tokenToString(token)}`);\n          this.token = token;\n          Object.setPrototypeOf(this, _EarlyEndOfParseError.prototype);\n        }\n        getToken() {\n          return this.token;\n        }\n      };\n      __name(_EarlyEndOfParseError, \"EarlyEndOfParseError\");\n      let EarlyEndOfParseError = _EarlyEndOfParseError;\n      const _UnexpectedTypeError = class _UnexpectedTypeError extends Error {\n        constructor(result, message) {\n          let error = `Unexpected type: '${result.type}'.`;\n          if (message !== void 0) {\n            error += ` Message: ${message}`;\n          }\n          super(error);\n          Object.setPrototypeOf(this, _UnexpectedTypeError.prototype);\n        }\n      };\n      __name(_UnexpectedTypeError, \"UnexpectedTypeError\");\n      let UnexpectedTypeError = _UnexpectedTypeError;\n      function makePunctuationRule(type) {\n        return (text) => {\n          if (text.startsWith(type)) {\n            return { type, text: type };\n          } else {\n            return null;\n          }\n        };\n      }\n      __name(makePunctuationRule, \"makePunctuationRule\");\n      function getQuoted(text) {\n        let position = 0;\n        let char;\n        const mark = text[0];\n        let escaped = false;\n        if (mark !== \"'\" && mark !== '\"') {\n          return null;\n        }\n        while (position < text.length) {\n          position++;\n          char = text[position];\n          if (!escaped && char === mark) {\n            position++;\n            break;\n          }\n          escaped = !escaped && char === \"\\\\\";\n        }\n        if (char !== mark) {\n          throw new Error(\"Unterminated String\");\n        }\n        return text.slice(0, position);\n      }\n      __name(getQuoted, \"getQuoted\");\n      const identifierStartRegex = new RegExp(\"[$_\\\\p{ID_Start}]|\\\\\\\\u\\\\p{Hex_Digit}{4}|\\\\\\\\u\\\\{0*(?:\\\\p{Hex_Digit}{1,5}|10\\\\p{Hex_Digit}{4})\\\\}\", \"u\");\n      const identifierContinueRegex = new RegExp(\"[$\\\\-\\\\p{ID_Continue}\\\\u200C\\\\u200D]|\\\\\\\\u\\\\p{Hex_Digit}{4}|\\\\\\\\u\\\\{0*(?:\\\\p{Hex_Digit}{1,5}|10\\\\p{Hex_Digit}{4})\\\\}\", \"u\");\n      function getIdentifier(text) {\n        let char = text[0];\n        if (!identifierStartRegex.test(char)) {\n          return null;\n        }\n        let position = 1;\n        do {\n          char = text[position];\n          if (!identifierContinueRegex.test(char)) {\n            break;\n          }\n          position++;\n        } while (position < text.length);\n        return text.slice(0, position);\n      }\n      __name(getIdentifier, \"getIdentifier\");\n      const numberRegex = /^(NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity))/;\n      function getNumber(text) {\n        var _a, _b;\n        return (_b = (_a = numberRegex.exec(text)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;\n      }\n      __name(getNumber, \"getNumber\");\n      const identifierRule = /* @__PURE__ */ __name((text) => {\n        const value = getIdentifier(text);\n        if (value == null) {\n          return null;\n        }\n        return {\n          type: \"Identifier\",\n          text: value\n        };\n      }, \"identifierRule\");\n      function makeKeyWordRule(type) {\n        return (text) => {\n          if (!text.startsWith(type)) {\n            return null;\n          }\n          const prepends = text[type.length];\n          if (prepends !== void 0 && identifierContinueRegex.test(prepends)) {\n            return null;\n          }\n          return {\n            type,\n            text: type\n          };\n        };\n      }\n      __name(makeKeyWordRule, \"makeKeyWordRule\");\n      const stringValueRule = /* @__PURE__ */ __name((text) => {\n        const value = getQuoted(text);\n        if (value == null) {\n          return null;\n        }\n        return {\n          type: \"StringValue\",\n          text: value\n        };\n      }, \"stringValueRule\");\n      const eofRule = /* @__PURE__ */ __name((text) => {\n        if (text.length > 0) {\n          return null;\n        }\n        return {\n          type: \"EOF\",\n          text: \"\"\n        };\n      }, \"eofRule\");\n      const numberRule = /* @__PURE__ */ __name((text) => {\n        const value = getNumber(text);\n        if (value === null) {\n          return null;\n        }\n        return {\n          type: \"Number\",\n          text: value\n        };\n      }, \"numberRule\");\n      const rules = [\n        eofRule,\n        makePunctuationRule(\"=>\"),\n        makePunctuationRule(\"(\"),\n        makePunctuationRule(\")\"),\n        makePunctuationRule(\"{\"),\n        makePunctuationRule(\"}\"),\n        makePunctuationRule(\"[\"),\n        makePunctuationRule(\"]\"),\n        makePunctuationRule(\"|\"),\n        makePunctuationRule(\"&\"),\n        makePunctuationRule(\"<\"),\n        makePunctuationRule(\">\"),\n        makePunctuationRule(\",\"),\n        makePunctuationRule(\";\"),\n        makePunctuationRule(\"*\"),\n        makePunctuationRule(\"?\"),\n        makePunctuationRule(\"!\"),\n        makePunctuationRule(\"=\"),\n        makePunctuationRule(\":\"),\n        makePunctuationRule(\"...\"),\n        makePunctuationRule(\".\"),\n        makePunctuationRule(\"#\"),\n        makePunctuationRule(\"~\"),\n        makePunctuationRule(\"/\"),\n        makePunctuationRule(\"@\"),\n        makeKeyWordRule(\"undefined\"),\n        makeKeyWordRule(\"null\"),\n        makeKeyWordRule(\"function\"),\n        makeKeyWordRule(\"this\"),\n        makeKeyWordRule(\"new\"),\n        makeKeyWordRule(\"module\"),\n        makeKeyWordRule(\"event\"),\n        makeKeyWordRule(\"extends\"),\n        makeKeyWordRule(\"external\"),\n        makeKeyWordRule(\"infer\"),\n        makeKeyWordRule(\"typeof\"),\n        makeKeyWordRule(\"keyof\"),\n        makeKeyWordRule(\"readonly\"),\n        makeKeyWordRule(\"import\"),\n        makeKeyWordRule(\"is\"),\n        makeKeyWordRule(\"in\"),\n        makeKeyWordRule(\"asserts\"),\n        numberRule,\n        identifierRule,\n        stringValueRule\n      ];\n      const breakingWhitespaceRegex = /^\\s*\\n\\s*/;\n      const _Lexer = class _Lexer {\n        static create(text) {\n          const current = this.read(text);\n          text = current.text;\n          const next = this.read(text);\n          text = next.text;\n          return new _Lexer(text, void 0, current.token, next.token);\n        }\n        constructor(text, previous, current, next) {\n          this.text = \"\";\n          this.text = text;\n          this.previous = previous;\n          this.current = current;\n          this.next = next;\n        }\n        static read(text, startOfLine = false) {\n          startOfLine = startOfLine || breakingWhitespaceRegex.test(text);\n          text = text.trim();\n          for (const rule of rules) {\n            const partial = rule(text);\n            if (partial !== null) {\n              const token = Object.assign(Object.assign({}, partial), { startOfLine });\n              text = text.slice(token.text.length);\n              return { text, token };\n            }\n          }\n          throw new Error(\"Unexpected Token \" + text);\n        }\n        advance() {\n          const next = _Lexer.read(this.text);\n          return new _Lexer(next.text, this.current, this.next, next.token);\n        }\n      };\n      __name(_Lexer, \"Lexer\");\n      let Lexer = _Lexer;\n      function assertRootResult(result) {\n        if (result === void 0) {\n          throw new Error(\"Unexpected undefined\");\n        }\n        if (result.type === \"JsdocTypeKeyValue\" || result.type === \"JsdocTypeParameterList\" || result.type === \"JsdocTypeProperty\" || result.type === \"JsdocTypeReadonlyProperty\" || result.type === \"JsdocTypeObjectField\" || result.type === \"JsdocTypeJsdocObjectField\" || result.type === \"JsdocTypeIndexSignature\" || result.type === \"JsdocTypeMappedType\" || result.type === \"JsdocTypeTypeParameter\") {\n          throw new UnexpectedTypeError(result);\n        }\n        return result;\n      }\n      __name(assertRootResult, \"assertRootResult\");\n      function assertPlainKeyValueOrRootResult(result) {\n        if (result.type === \"JsdocTypeKeyValue\") {\n          return assertPlainKeyValueResult(result);\n        }\n        return assertRootResult(result);\n      }\n      __name(assertPlainKeyValueOrRootResult, \"assertPlainKeyValueOrRootResult\");\n      function assertPlainKeyValueOrNameResult(result) {\n        if (result.type === \"JsdocTypeName\") {\n          return result;\n        }\n        return assertPlainKeyValueResult(result);\n      }\n      __name(assertPlainKeyValueOrNameResult, \"assertPlainKeyValueOrNameResult\");\n      function assertPlainKeyValueResult(result) {\n        if (result.type !== \"JsdocTypeKeyValue\") {\n          throw new UnexpectedTypeError(result);\n        }\n        return result;\n      }\n      __name(assertPlainKeyValueResult, \"assertPlainKeyValueResult\");\n      function assertNumberOrVariadicNameResult(result) {\n        var _a;\n        if (result.type === \"JsdocTypeVariadic\") {\n          if (((_a = result.element) === null || _a === void 0 ? void 0 : _a.type) === \"JsdocTypeName\") {\n            return result;\n          }\n          throw new UnexpectedTypeError(result);\n        }\n        if (result.type !== \"JsdocTypeNumber\" && result.type !== \"JsdocTypeName\") {\n          throw new UnexpectedTypeError(result);\n        }\n        return result;\n      }\n      __name(assertNumberOrVariadicNameResult, \"assertNumberOrVariadicNameResult\");\n      function assertArrayOrTupleResult(result) {\n        if (result.type === \"JsdocTypeTuple\") {\n          return result;\n        }\n        if (result.type === \"JsdocTypeGeneric\" && result.meta.brackets === \"square\") {\n          return result;\n        }\n        throw new UnexpectedTypeError(result);\n      }\n      __name(assertArrayOrTupleResult, \"assertArrayOrTupleResult\");\n      function isSquaredProperty(result) {\n        return result.type === \"JsdocTypeIndexSignature\" || result.type === \"JsdocTypeMappedType\";\n      }\n      __name(isSquaredProperty, \"isSquaredProperty\");\n      var Precedence;\n      (function(Precedence2) {\n        Precedence2[Precedence2[\"ALL\"] = 0] = \"ALL\";\n        Precedence2[Precedence2[\"PARAMETER_LIST\"] = 1] = \"PARAMETER_LIST\";\n        Precedence2[Precedence2[\"OBJECT\"] = 2] = \"OBJECT\";\n        Precedence2[Precedence2[\"KEY_VALUE\"] = 3] = \"KEY_VALUE\";\n        Precedence2[Precedence2[\"INDEX_BRACKETS\"] = 4] = \"INDEX_BRACKETS\";\n        Precedence2[Precedence2[\"UNION\"] = 5] = \"UNION\";\n        Precedence2[Precedence2[\"INTERSECTION\"] = 6] = \"INTERSECTION\";\n        Precedence2[Precedence2[\"PREFIX\"] = 7] = \"PREFIX\";\n        Precedence2[Precedence2[\"INFIX\"] = 8] = \"INFIX\";\n        Precedence2[Precedence2[\"TUPLE\"] = 9] = \"TUPLE\";\n        Precedence2[Precedence2[\"SYMBOL\"] = 10] = \"SYMBOL\";\n        Precedence2[Precedence2[\"OPTIONAL\"] = 11] = \"OPTIONAL\";\n        Precedence2[Precedence2[\"NULLABLE\"] = 12] = \"NULLABLE\";\n        Precedence2[Precedence2[\"KEY_OF_TYPE_OF\"] = 13] = \"KEY_OF_TYPE_OF\";\n        Precedence2[Precedence2[\"FUNCTION\"] = 14] = \"FUNCTION\";\n        Precedence2[Precedence2[\"ARROW\"] = 15] = \"ARROW\";\n        Precedence2[Precedence2[\"ARRAY_BRACKETS\"] = 16] = \"ARRAY_BRACKETS\";\n        Precedence2[Precedence2[\"GENERIC\"] = 17] = \"GENERIC\";\n        Precedence2[Precedence2[\"NAME_PATH\"] = 18] = \"NAME_PATH\";\n        Precedence2[Precedence2[\"PARENTHESIS\"] = 19] = \"PARENTHESIS\";\n        Precedence2[Precedence2[\"SPECIAL_TYPES\"] = 20] = \"SPECIAL_TYPES\";\n      })(Precedence || (Precedence = {}));\n      const _Parser = class _Parser {\n        constructor(grammar, textOrLexer, baseParser) {\n          this.grammar = grammar;\n          if (typeof textOrLexer === \"string\") {\n            this._lexer = Lexer.create(textOrLexer);\n          } else {\n            this._lexer = textOrLexer;\n          }\n          this.baseParser = baseParser;\n        }\n        get lexer() {\n          return this._lexer;\n        }\n        /**\n         * Parses a given string and throws an error if the parse ended before the end of the string.\n         */\n        parse() {\n          const result = this.parseType(Precedence.ALL);\n          if (this.lexer.current.type !== \"EOF\") {\n            throw new EarlyEndOfParseError(this.lexer.current);\n          }\n          return result;\n        }\n        /**\n         * Parses with the current lexer and asserts that the result is a {@link RootResult}.\n         */\n        parseType(precedence) {\n          return assertRootResult(this.parseIntermediateType(precedence));\n        }\n        /**\n         * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues\n         * to parse the state in the infix step.\n         */\n        parseIntermediateType(precedence) {\n          const result = this.tryParslets(null, precedence);\n          if (result === null) {\n            throw new NoParsletFoundError(this.lexer.current);\n          }\n          return this.parseInfixIntermediateType(result, precedence);\n        }\n        /**\n         * In the infix parsing step the parser continues to parse the current state with all parslets until none returns\n         * a result.\n         */\n        parseInfixIntermediateType(left, precedence) {\n          let result = this.tryParslets(left, precedence);\n          while (result !== null) {\n            left = result;\n            result = this.tryParslets(left, precedence);\n          }\n          return left;\n        }\n        /**\n         * Tries to parse the current state with all parslets in the grammar and returns the first non null result.\n         */\n        tryParslets(left, precedence) {\n          for (const parslet of this.grammar) {\n            const result = parslet(this, precedence, left);\n            if (result !== null) {\n              return result;\n            }\n          }\n          return null;\n        }\n        /**\n         * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was\n         * advanced.\n         */\n        consume(types) {\n          if (!Array.isArray(types)) {\n            types = [types];\n          }\n          if (types.includes(this.lexer.current.type)) {\n            this._lexer = this.lexer.advance();\n            return true;\n          } else {\n            return false;\n          }\n        }\n        acceptLexerState(parser) {\n          this._lexer = parser.lexer;\n        }\n      };\n      __name(_Parser, \"Parser\");\n      let Parser = _Parser;\n      function isQuestionMarkUnknownType(next) {\n        return next === \"}\" || next === \"EOF\" || next === \"|\" || next === \",\" || next === \")\" || next === \">\";\n      }\n      __name(isQuestionMarkUnknownType, \"isQuestionMarkUnknownType\");\n      const nullableParslet = /* @__PURE__ */ __name((parser, precedence, left) => {\n        const type = parser.lexer.current.type;\n        const next = parser.lexer.next.type;\n        const accept = left == null && type === \"?\" && !isQuestionMarkUnknownType(next) || left != null && type === \"?\";\n        if (!accept) {\n          return null;\n        }\n        parser.consume(\"?\");\n        if (left == null) {\n          return {\n            type: \"JsdocTypeNullable\",\n            element: parser.parseType(Precedence.NULLABLE),\n            meta: {\n              position: \"prefix\"\n            }\n          };\n        } else {\n          return {\n            type: \"JsdocTypeNullable\",\n            element: assertRootResult(left),\n            meta: {\n              position: \"suffix\"\n            }\n          };\n        }\n      }, \"nullableParslet\");\n      function composeParslet(options) {\n        const parslet = /* @__PURE__ */ __name((parser, curPrecedence, left) => {\n          const type = parser.lexer.current.type;\n          const next = parser.lexer.next.type;\n          if (left === null) {\n            if (\"parsePrefix\" in options) {\n              if (options.accept(type, next)) {\n                return options.parsePrefix(parser);\n              }\n            }\n          } else {\n            if (\"parseInfix\" in options) {\n              if (options.precedence > curPrecedence && options.accept(type, next)) {\n                return options.parseInfix(parser, left);\n              }\n            }\n          }\n          return null;\n        }, \"parslet\");\n        Object.defineProperty(parslet, \"name\", {\n          value: options.name\n        });\n        return parslet;\n      }\n      __name(composeParslet, \"composeParslet\");\n      const optionalParslet = composeParslet({\n        name: \"optionalParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"=\", \"accept\"),\n        precedence: Precedence.OPTIONAL,\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          parser.consume(\"=\");\n          return {\n            type: \"JsdocTypeOptional\",\n            element: parser.parseType(Precedence.OPTIONAL),\n            meta: {\n              position: \"prefix\"\n            }\n          };\n        }, \"parsePrefix\"),\n        parseInfix: /* @__PURE__ */ __name((parser, left) => {\n          parser.consume(\"=\");\n          return {\n            type: \"JsdocTypeOptional\",\n            element: assertRootResult(left),\n            meta: {\n              position: \"suffix\"\n            }\n          };\n        }, \"parseInfix\")\n      });\n      const numberParslet = composeParslet({\n        name: \"numberParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"Number\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          const value = parseFloat(parser.lexer.current.text);\n          parser.consume(\"Number\");\n          return {\n            type: \"JsdocTypeNumber\",\n            value\n          };\n        }, \"parsePrefix\")\n      });\n      const parenthesisParslet = composeParslet({\n        name: \"parenthesisParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"(\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          parser.consume(\"(\");\n          if (parser.consume(\")\")) {\n            return {\n              type: \"JsdocTypeParameterList\",\n              elements: []\n            };\n          }\n          const result = parser.parseIntermediateType(Precedence.ALL);\n          if (!parser.consume(\")\")) {\n            throw new Error(\"Unterminated parenthesis\");\n          }\n          if (result.type === \"JsdocTypeParameterList\") {\n            return result;\n          } else if (result.type === \"JsdocTypeKeyValue\") {\n            return {\n              type: \"JsdocTypeParameterList\",\n              elements: [result]\n            };\n          }\n          return {\n            type: \"JsdocTypeParenthesis\",\n            element: assertRootResult(result)\n          };\n        }, \"parsePrefix\")\n      });\n      const specialTypesParslet = composeParslet({\n        name: \"specialTypesParslet\",\n        accept: /* @__PURE__ */ __name((type, next) => type === \"?\" && isQuestionMarkUnknownType(next) || type === \"null\" || type === \"undefined\" || type === \"*\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          if (parser.consume(\"null\")) {\n            return {\n              type: \"JsdocTypeNull\"\n            };\n          }\n          if (parser.consume(\"undefined\")) {\n            return {\n              type: \"JsdocTypeUndefined\"\n            };\n          }\n          if (parser.consume(\"*\")) {\n            return {\n              type: \"JsdocTypeAny\"\n            };\n          }\n          if (parser.consume(\"?\")) {\n            return {\n              type: \"JsdocTypeUnknown\"\n            };\n          }\n          throw new Error(\"Unacceptable token: \" + parser.lexer.current.text);\n        }, \"parsePrefix\")\n      });\n      const notNullableParslet = composeParslet({\n        name: \"notNullableParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"!\", \"accept\"),\n        precedence: Precedence.NULLABLE,\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          parser.consume(\"!\");\n          return {\n            type: \"JsdocTypeNotNullable\",\n            element: parser.parseType(Precedence.NULLABLE),\n            meta: {\n              position: \"prefix\"\n            }\n          };\n        }, \"parsePrefix\"),\n        parseInfix: /* @__PURE__ */ __name((parser, left) => {\n          parser.consume(\"!\");\n          return {\n            type: \"JsdocTypeNotNullable\",\n            element: assertRootResult(left),\n            meta: {\n              position: \"suffix\"\n            }\n          };\n        }, \"parseInfix\")\n      });\n      function createParameterListParslet({ allowTrailingComma }) {\n        return composeParslet({\n          name: \"parameterListParslet\",\n          accept: /* @__PURE__ */ __name((type) => type === \",\", \"accept\"),\n          precedence: Precedence.PARAMETER_LIST,\n          parseInfix: /* @__PURE__ */ __name((parser, left) => {\n            const elements = [\n              assertPlainKeyValueOrRootResult(left)\n            ];\n            parser.consume(\",\");\n            do {\n              try {\n                const next = parser.parseIntermediateType(Precedence.PARAMETER_LIST);\n                elements.push(assertPlainKeyValueOrRootResult(next));\n              } catch (e) {\n                if (e instanceof NoParsletFoundError) {\n                  break;\n                } else {\n                  throw e;\n                }\n              }\n            } while (parser.consume(\",\"));\n            if (elements.length > 0 && elements.slice(0, -1).some((e) => e.type === \"JsdocTypeVariadic\")) {\n              throw new Error(\"Only the last parameter may be a rest parameter\");\n            }\n            return {\n              type: \"JsdocTypeParameterList\",\n              elements\n            };\n          }, \"parseInfix\")\n        });\n      }\n      __name(createParameterListParslet, \"createParameterListParslet\");\n      const genericParslet = composeParslet({\n        name: \"genericParslet\",\n        accept: /* @__PURE__ */ __name((type, next) => type === \"<\" || type === \".\" && next === \"<\", \"accept\"),\n        precedence: Precedence.GENERIC,\n        parseInfix: /* @__PURE__ */ __name((parser, left) => {\n          const dot = parser.consume(\".\");\n          parser.consume(\"<\");\n          const objects = [];\n          let infer = false;\n          if (parser.consume(\"infer\")) {\n            infer = true;\n            const left2 = parser.parseIntermediateType(Precedence.SYMBOL);\n            if (left2.type !== \"JsdocTypeName\") {\n              throw new UnexpectedTypeError(left2, \"A typescript asserts always has to have a name on the left side.\");\n            }\n            objects.push(left2);\n          } else {\n            do {\n              objects.push(parser.parseType(Precedence.PARAMETER_LIST));\n            } while (parser.consume(\",\"));\n          }\n          if (!parser.consume(\">\")) {\n            throw new Error(\"Unterminated generic parameter list\");\n          }\n          return Object.assign(Object.assign({ type: \"JsdocTypeGeneric\", left: assertRootResult(left), elements: objects }, infer ? { infer: true } : {}), { meta: {\n            brackets: \"angle\",\n            dot\n          } });\n        }, \"parseInfix\")\n      });\n      const unionParslet = composeParslet({\n        name: \"unionParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"|\", \"accept\"),\n        precedence: Precedence.UNION,\n        parseInfix: /* @__PURE__ */ __name((parser, left) => {\n          parser.consume(\"|\");\n          const elements = [];\n          do {\n            elements.push(parser.parseType(Precedence.UNION));\n          } while (parser.consume(\"|\"));\n          return {\n            type: \"JsdocTypeUnion\",\n            elements: [assertRootResult(left), ...elements]\n          };\n        }, \"parseInfix\")\n      });\n      const baseGrammar = [\n        nullableParslet,\n        optionalParslet,\n        numberParslet,\n        parenthesisParslet,\n        specialTypesParslet,\n        notNullableParslet,\n        createParameterListParslet({\n          allowTrailingComma: true\n        }),\n        genericParslet,\n        unionParslet,\n        optionalParslet\n      ];\n      function createNamePathParslet({ allowSquareBracketsOnAnyType, allowJsdocNamePaths, pathGrammar: pathGrammar2 }) {\n        return /* @__PURE__ */ __name(function namePathParslet(parser, precedence, left) {\n          if (left == null || precedence >= Precedence.NAME_PATH) {\n            return null;\n          }\n          const type = parser.lexer.current.type;\n          const next = parser.lexer.next.type;\n          const accept = type === \".\" && next !== \"<\" || type === \"[\" && (allowSquareBracketsOnAnyType || left.type === \"JsdocTypeName\") || allowJsdocNamePaths && (type === \"~\" || type === \"#\");\n          if (!accept) {\n            return null;\n          }\n          let pathType;\n          let brackets = false;\n          if (parser.consume(\".\")) {\n            pathType = \"property\";\n          } else if (parser.consume(\"[\")) {\n            pathType = \"property-brackets\";\n            brackets = true;\n          } else if (parser.consume(\"~\")) {\n            pathType = \"inner\";\n          } else {\n            parser.consume(\"#\");\n            pathType = \"instance\";\n          }\n          const pathParser = pathGrammar2 !== null ? new Parser(pathGrammar2, parser.lexer, parser) : parser;\n          const parsed = pathParser.parseIntermediateType(Precedence.NAME_PATH);\n          parser.acceptLexerState(pathParser);\n          let right;\n          switch (parsed.type) {\n            case \"JsdocTypeName\":\n              right = {\n                type: \"JsdocTypeProperty\",\n                value: parsed.value,\n                meta: {\n                  quote: void 0\n                }\n              };\n              break;\n            case \"JsdocTypeNumber\":\n              right = {\n                type: \"JsdocTypeProperty\",\n                value: parsed.value.toString(10),\n                meta: {\n                  quote: void 0\n                }\n              };\n              break;\n            case \"JsdocTypeStringValue\":\n              right = {\n                type: \"JsdocTypeProperty\",\n                value: parsed.value,\n                meta: {\n                  quote: parsed.meta.quote\n                }\n              };\n              break;\n            case \"JsdocTypeSpecialNamePath\":\n              if (parsed.specialType === \"event\") {\n                right = parsed;\n              } else {\n                throw new UnexpectedTypeError(parsed, \"Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'\");\n              }\n              break;\n            default:\n              throw new UnexpectedTypeError(parsed, \"Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'\");\n          }\n          if (brackets && !parser.consume(\"]\")) {\n            const token = parser.lexer.current;\n            throw new Error(`Unterminated square brackets. Next token is '${token.type}' with text '${token.text}'`);\n          }\n          return {\n            type: \"JsdocTypeNamePath\",\n            left: assertRootResult(left),\n            right,\n            pathType\n          };\n        }, \"namePathParslet\");\n      }\n      __name(createNamePathParslet, \"createNamePathParslet\");\n      function createNameParslet({ allowedAdditionalTokens }) {\n        return composeParslet({\n          name: \"nameParslet\",\n          accept: /* @__PURE__ */ __name((type) => type === \"Identifier\" || type === \"this\" || type === \"new\" || allowedAdditionalTokens.includes(type), \"accept\"),\n          parsePrefix: /* @__PURE__ */ __name((parser) => {\n            const { type, text } = parser.lexer.current;\n            parser.consume(type);\n            return {\n              type: \"JsdocTypeName\",\n              value: text\n            };\n          }, \"parsePrefix\")\n        });\n      }\n      __name(createNameParslet, \"createNameParslet\");\n      const stringValueParslet = composeParslet({\n        name: \"stringValueParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"StringValue\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          const text = parser.lexer.current.text;\n          parser.consume(\"StringValue\");\n          return {\n            type: \"JsdocTypeStringValue\",\n            value: text.slice(1, -1),\n            meta: {\n              quote: text[0] === \"'\" ? \"single\" : \"double\"\n            }\n          };\n        }, \"parsePrefix\")\n      });\n      function createSpecialNamePathParslet({ pathGrammar: pathGrammar2, allowedTypes }) {\n        return composeParslet({\n          name: \"specialNamePathParslet\",\n          accept: /* @__PURE__ */ __name((type) => allowedTypes.includes(type), \"accept\"),\n          parsePrefix: /* @__PURE__ */ __name((parser) => {\n            const type = parser.lexer.current.type;\n            parser.consume(type);\n            if (!parser.consume(\":\")) {\n              return {\n                type: \"JsdocTypeName\",\n                value: type\n              };\n            }\n            let result;\n            let token = parser.lexer.current;\n            if (parser.consume(\"StringValue\")) {\n              result = {\n                type: \"JsdocTypeSpecialNamePath\",\n                value: token.text.slice(1, -1),\n                specialType: type,\n                meta: {\n                  quote: token.text[0] === \"'\" ? \"single\" : \"double\"\n                }\n              };\n            } else {\n              let value = \"\";\n              const allowed = [\"Identifier\", \"@\", \"/\"];\n              while (allowed.some((type2) => parser.consume(type2))) {\n                value += token.text;\n                token = parser.lexer.current;\n              }\n              result = {\n                type: \"JsdocTypeSpecialNamePath\",\n                value,\n                specialType: type,\n                meta: {\n                  quote: void 0\n                }\n              };\n            }\n            const moduleParser = new Parser(pathGrammar2, parser.lexer, parser);\n            const moduleResult = moduleParser.parseInfixIntermediateType(result, Precedence.ALL);\n            parser.acceptLexerState(moduleParser);\n            return assertRootResult(moduleResult);\n          }, \"parsePrefix\")\n        });\n      }\n      __name(createSpecialNamePathParslet, \"createSpecialNamePathParslet\");\n      const basePathGrammar = [\n        createNameParslet({\n          allowedAdditionalTokens: [\"external\", \"module\"]\n        }),\n        stringValueParslet,\n        numberParslet,\n        createNamePathParslet({\n          allowSquareBracketsOnAnyType: false,\n          allowJsdocNamePaths: true,\n          pathGrammar: null\n        })\n      ];\n      const pathGrammar = [\n        ...basePathGrammar,\n        createSpecialNamePathParslet({\n          allowedTypes: [\"event\"],\n          pathGrammar: basePathGrammar\n        })\n      ];\n      function getParameters(value) {\n        let parameters;\n        if (value.type === \"JsdocTypeParameterList\") {\n          parameters = value.elements;\n        } else if (value.type === \"JsdocTypeParenthesis\") {\n          parameters = [value.element];\n        } else {\n          throw new UnexpectedTypeError(value);\n        }\n        return parameters.map((p) => assertPlainKeyValueOrRootResult(p));\n      }\n      __name(getParameters, \"getParameters\");\n      function getUnnamedParameters(value) {\n        const parameters = getParameters(value);\n        if (parameters.some((p) => p.type === \"JsdocTypeKeyValue\")) {\n          throw new Error(\"No parameter should be named\");\n        }\n        return parameters;\n      }\n      __name(getUnnamedParameters, \"getUnnamedParameters\");\n      function createFunctionParslet({ allowNamedParameters, allowNoReturnType, allowWithoutParenthesis, allowNewAsFunctionKeyword }) {\n        return composeParslet({\n          name: \"functionParslet\",\n          accept: /* @__PURE__ */ __name((type, next) => type === \"function\" || allowNewAsFunctionKeyword && type === \"new\" && next === \"(\", \"accept\"),\n          parsePrefix: /* @__PURE__ */ __name((parser) => {\n            const newKeyword = parser.consume(\"new\");\n            parser.consume(\"function\");\n            const hasParenthesis = parser.lexer.current.type === \"(\";\n            if (!hasParenthesis) {\n              if (!allowWithoutParenthesis) {\n                throw new Error(\"function is missing parameter list\");\n              }\n              return {\n                type: \"JsdocTypeName\",\n                value: \"function\"\n              };\n            }\n            let result = {\n              type: \"JsdocTypeFunction\",\n              parameters: [],\n              arrow: false,\n              constructor: newKeyword,\n              parenthesis: hasParenthesis\n            };\n            const value = parser.parseIntermediateType(Precedence.FUNCTION);\n            if (allowNamedParameters === void 0) {\n              result.parameters = getUnnamedParameters(value);\n            } else if (newKeyword && value.type === \"JsdocTypeFunction\" && value.arrow) {\n              result = value;\n              result.constructor = true;\n              return result;\n            } else {\n              result.parameters = getParameters(value);\n              for (const p of result.parameters) {\n                if (p.type === \"JsdocTypeKeyValue\" && !allowNamedParameters.includes(p.key)) {\n                  throw new Error(`only allowed named parameters are ${allowNamedParameters.join(\", \")} but got ${p.type}`);\n                }\n              }\n            }\n            if (parser.consume(\":\")) {\n              result.returnType = parser.parseType(Precedence.PREFIX);\n            } else {\n              if (!allowNoReturnType) {\n                throw new Error(\"function is missing return type\");\n              }\n            }\n            return result;\n          }, \"parsePrefix\")\n        });\n      }\n      __name(createFunctionParslet, \"createFunctionParslet\");\n      function createVariadicParslet({ allowPostfix, allowEnclosingBrackets }) {\n        return composeParslet({\n          name: \"variadicParslet\",\n          accept: /* @__PURE__ */ __name((type) => type === \"...\", \"accept\"),\n          precedence: Precedence.PREFIX,\n          parsePrefix: /* @__PURE__ */ __name((parser) => {\n            parser.consume(\"...\");\n            const brackets = allowEnclosingBrackets && parser.consume(\"[\");\n            try {\n              const element = parser.parseType(Precedence.PREFIX);\n              if (brackets && !parser.consume(\"]\")) {\n                throw new Error(\"Unterminated variadic type. Missing ']'\");\n              }\n              return {\n                type: \"JsdocTypeVariadic\",\n                element: assertRootResult(element),\n                meta: {\n                  position: \"prefix\",\n                  squareBrackets: brackets\n                }\n              };\n            } catch (e) {\n              if (e instanceof NoParsletFoundError) {\n                if (brackets) {\n                  throw new Error(\"Empty square brackets for variadic are not allowed.\");\n                }\n                return {\n                  type: \"JsdocTypeVariadic\",\n                  meta: {\n                    position: void 0,\n                    squareBrackets: false\n                  }\n                };\n              } else {\n                throw e;\n              }\n            }\n          }, \"parsePrefix\"),\n          parseInfix: allowPostfix ? (parser, left) => {\n            parser.consume(\"...\");\n            return {\n              type: \"JsdocTypeVariadic\",\n              element: assertRootResult(left),\n              meta: {\n                position: \"suffix\",\n                squareBrackets: false\n              }\n            };\n          } : void 0\n        });\n      }\n      __name(createVariadicParslet, \"createVariadicParslet\");\n      const symbolParslet = composeParslet({\n        name: \"symbolParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"(\", \"accept\"),\n        precedence: Precedence.SYMBOL,\n        parseInfix: /* @__PURE__ */ __name((parser, left) => {\n          if (left.type !== \"JsdocTypeName\") {\n            throw new Error(\"Symbol expects a name on the left side. (Reacting on '(')\");\n          }\n          parser.consume(\"(\");\n          const result = {\n            type: \"JsdocTypeSymbol\",\n            value: left.value\n          };\n          if (!parser.consume(\")\")) {\n            const next = parser.parseIntermediateType(Precedence.SYMBOL);\n            result.element = assertNumberOrVariadicNameResult(next);\n            if (!parser.consume(\")\")) {\n              throw new Error(\"Symbol does not end after value\");\n            }\n          }\n          return result;\n        }, \"parseInfix\")\n      });\n      const arrayBracketsParslet = composeParslet({\n        name: \"arrayBracketsParslet\",\n        precedence: Precedence.ARRAY_BRACKETS,\n        accept: /* @__PURE__ */ __name((type, next) => type === \"[\" && next === \"]\", \"accept\"),\n        parseInfix: /* @__PURE__ */ __name((parser, left) => {\n          parser.consume(\"[\");\n          parser.consume(\"]\");\n          return {\n            type: \"JsdocTypeGeneric\",\n            left: {\n              type: \"JsdocTypeName\",\n              value: \"Array\"\n            },\n            elements: [\n              assertRootResult(left)\n            ],\n            meta: {\n              brackets: \"square\",\n              dot: false\n            }\n          };\n        }, \"parseInfix\")\n      });\n      function createObjectParslet({ objectFieldGrammar: objectFieldGrammar2, allowKeyTypes }) {\n        return composeParslet({\n          name: \"objectParslet\",\n          accept: /* @__PURE__ */ __name((type) => type === \"{\", \"accept\"),\n          parsePrefix: /* @__PURE__ */ __name((parser) => {\n            parser.consume(\"{\");\n            const result = {\n              type: \"JsdocTypeObject\",\n              meta: {\n                separator: \"comma\"\n              },\n              elements: []\n            };\n            if (!parser.consume(\"}\")) {\n              let separator;\n              const fieldParser = new Parser(objectFieldGrammar2, parser.lexer, parser);\n              while (true) {\n                fieldParser.acceptLexerState(parser);\n                let field = fieldParser.parseIntermediateType(Precedence.OBJECT);\n                parser.acceptLexerState(fieldParser);\n                if (field === void 0 && allowKeyTypes) {\n                  field = parser.parseIntermediateType(Precedence.OBJECT);\n                }\n                let optional = false;\n                if (field.type === \"JsdocTypeNullable\") {\n                  optional = true;\n                  field = field.element;\n                }\n                if (field.type === \"JsdocTypeNumber\" || field.type === \"JsdocTypeName\" || field.type === \"JsdocTypeStringValue\") {\n                  let quote2;\n                  if (field.type === \"JsdocTypeStringValue\") {\n                    quote2 = field.meta.quote;\n                  }\n                  result.elements.push({\n                    type: \"JsdocTypeObjectField\",\n                    key: field.value.toString(),\n                    right: void 0,\n                    optional,\n                    readonly: false,\n                    meta: {\n                      quote: quote2\n                    }\n                  });\n                } else if (field.type === \"JsdocTypeObjectField\" || field.type === \"JsdocTypeJsdocObjectField\") {\n                  result.elements.push(field);\n                } else {\n                  throw new UnexpectedTypeError(field);\n                }\n                if (parser.lexer.current.startOfLine) {\n                  separator = \"linebreak\";\n                  parser.consume(\",\") || parser.consume(\";\");\n                } else if (parser.consume(\",\")) {\n                  separator = \"comma\";\n                } else if (parser.consume(\";\")) {\n                  separator = \"semicolon\";\n                } else {\n                  break;\n                }\n                const type = parser.lexer.current.type;\n                if (type === \"}\") {\n                  break;\n                }\n              }\n              result.meta.separator = separator !== null && separator !== void 0 ? separator : \"comma\";\n              if (separator === \"linebreak\") {\n                result.meta.propertyIndent = \"  \";\n              }\n              if (!parser.consume(\"}\")) {\n                throw new Error(\"Unterminated record type. Missing '}'\");\n              }\n            }\n            return result;\n          }, \"parsePrefix\")\n        });\n      }\n      __name(createObjectParslet, \"createObjectParslet\");\n      function createObjectFieldParslet({ allowSquaredProperties, allowKeyTypes, allowReadonly, allowOptional }) {\n        return composeParslet({\n          name: \"objectFieldParslet\",\n          precedence: Precedence.KEY_VALUE,\n          accept: /* @__PURE__ */ __name((type) => type === \":\", \"accept\"),\n          parseInfix: /* @__PURE__ */ __name((parser, left) => {\n            var _a;\n            let optional = false;\n            let readonlyProperty = false;\n            if (allowOptional && left.type === \"JsdocTypeNullable\") {\n              optional = true;\n              left = left.element;\n            }\n            if (allowReadonly && left.type === \"JsdocTypeReadonlyProperty\") {\n              readonlyProperty = true;\n              left = left.element;\n            }\n            const parentParser = (_a = parser.baseParser) !== null && _a !== void 0 ? _a : parser;\n            parentParser.acceptLexerState(parser);\n            if (left.type === \"JsdocTypeNumber\" || left.type === \"JsdocTypeName\" || left.type === \"JsdocTypeStringValue\" || isSquaredProperty(left)) {\n              if (isSquaredProperty(left) && !allowSquaredProperties) {\n                throw new UnexpectedTypeError(left);\n              }\n              parentParser.consume(\":\");\n              let quote2;\n              if (left.type === \"JsdocTypeStringValue\") {\n                quote2 = left.meta.quote;\n              }\n              const right = parentParser.parseType(Precedence.KEY_VALUE);\n              parser.acceptLexerState(parentParser);\n              return {\n                type: \"JsdocTypeObjectField\",\n                key: isSquaredProperty(left) ? left : left.value.toString(),\n                right,\n                optional,\n                readonly: readonlyProperty,\n                meta: {\n                  quote: quote2\n                }\n              };\n            } else {\n              if (!allowKeyTypes) {\n                throw new UnexpectedTypeError(left);\n              }\n              parentParser.consume(\":\");\n              const right = parentParser.parseType(Precedence.KEY_VALUE);\n              parser.acceptLexerState(parentParser);\n              return {\n                type: \"JsdocTypeJsdocObjectField\",\n                left: assertRootResult(left),\n                right\n              };\n            }\n          }, \"parseInfix\")\n        });\n      }\n      __name(createObjectFieldParslet, \"createObjectFieldParslet\");\n      function createKeyValueParslet({ allowOptional, allowVariadic }) {\n        return composeParslet({\n          name: \"keyValueParslet\",\n          precedence: Precedence.KEY_VALUE,\n          accept: /* @__PURE__ */ __name((type) => type === \":\", \"accept\"),\n          parseInfix: /* @__PURE__ */ __name((parser, left) => {\n            let optional = false;\n            let variadic = false;\n            if (allowOptional && left.type === \"JsdocTypeNullable\") {\n              optional = true;\n              left = left.element;\n            }\n            if (allowVariadic && left.type === \"JsdocTypeVariadic\" && left.element !== void 0) {\n              variadic = true;\n              left = left.element;\n            }\n            if (left.type !== \"JsdocTypeName\") {\n              throw new UnexpectedTypeError(left);\n            }\n            parser.consume(\":\");\n            const right = parser.parseType(Precedence.KEY_VALUE);\n            return {\n              type: \"JsdocTypeKeyValue\",\n              key: left.value,\n              right,\n              optional,\n              variadic\n            };\n          }, \"parseInfix\")\n        });\n      }\n      __name(createKeyValueParslet, \"createKeyValueParslet\");\n      const jsdocBaseGrammar = [\n        ...baseGrammar,\n        createFunctionParslet({\n          allowWithoutParenthesis: true,\n          allowNamedParameters: [\"this\", \"new\"],\n          allowNoReturnType: true,\n          allowNewAsFunctionKeyword: false\n        }),\n        stringValueParslet,\n        createSpecialNamePathParslet({\n          allowedTypes: [\"module\", \"external\", \"event\"],\n          pathGrammar\n        }),\n        createVariadicParslet({\n          allowEnclosingBrackets: true,\n          allowPostfix: true\n        }),\n        createNameParslet({\n          allowedAdditionalTokens: [\"keyof\"]\n        }),\n        symbolParslet,\n        arrayBracketsParslet,\n        createNamePathParslet({\n          allowSquareBracketsOnAnyType: false,\n          allowJsdocNamePaths: true,\n          pathGrammar\n        })\n      ];\n      const jsdocGrammar = [\n        ...jsdocBaseGrammar,\n        createObjectParslet({\n          // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here\n          // we leave out the object type deliberately\n          objectFieldGrammar: [\n            createNameParslet({\n              allowedAdditionalTokens: [\"typeof\", \"module\", \"in\"]\n            }),\n            createObjectFieldParslet({\n              allowSquaredProperties: false,\n              allowKeyTypes: true,\n              allowOptional: false,\n              allowReadonly: false\n            }),\n            ...jsdocBaseGrammar\n          ],\n          allowKeyTypes: true\n        }),\n        createKeyValueParslet({\n          allowOptional: true,\n          allowVariadic: true\n        })\n      ];\n      const typeOfParslet = composeParslet({\n        name: \"typeOfParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"typeof\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          parser.consume(\"typeof\");\n          return {\n            type: \"JsdocTypeTypeof\",\n            element: parser.parseType(Precedence.KEY_OF_TYPE_OF)\n          };\n        }, \"parsePrefix\")\n      });\n      const objectFieldGrammar$1 = [\n        createNameParslet({\n          allowedAdditionalTokens: [\"typeof\", \"module\", \"keyof\", \"event\", \"external\", \"in\"]\n        }),\n        nullableParslet,\n        optionalParslet,\n        stringValueParslet,\n        numberParslet,\n        createObjectFieldParslet({\n          allowSquaredProperties: false,\n          allowKeyTypes: false,\n          allowOptional: false,\n          allowReadonly: false\n        })\n      ];\n      const closureGrammar = [\n        ...baseGrammar,\n        createObjectParslet({\n          allowKeyTypes: false,\n          objectFieldGrammar: objectFieldGrammar$1\n        }),\n        createNameParslet({\n          allowedAdditionalTokens: [\"event\", \"external\", \"in\"]\n        }),\n        typeOfParslet,\n        createFunctionParslet({\n          allowWithoutParenthesis: false,\n          allowNamedParameters: [\"this\", \"new\"],\n          allowNoReturnType: true,\n          allowNewAsFunctionKeyword: false\n        }),\n        createVariadicParslet({\n          allowEnclosingBrackets: false,\n          allowPostfix: false\n        }),\n        // additional name parslet is needed for some special cases\n        createNameParslet({\n          allowedAdditionalTokens: [\"keyof\"]\n        }),\n        createSpecialNamePathParslet({\n          allowedTypes: [\"module\"],\n          pathGrammar\n        }),\n        createNamePathParslet({\n          allowSquareBracketsOnAnyType: false,\n          allowJsdocNamePaths: true,\n          pathGrammar\n        }),\n        createKeyValueParslet({\n          allowOptional: false,\n          allowVariadic: false\n        }),\n        symbolParslet\n      ];\n      const assertsParslet = composeParslet({\n        name: \"assertsParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"asserts\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          parser.consume(\"asserts\");\n          const left = parser.parseIntermediateType(Precedence.SYMBOL);\n          if (left.type !== \"JsdocTypeName\") {\n            throw new UnexpectedTypeError(left, \"A typescript asserts always has to have a name on the left side.\");\n          }\n          if (!parser.consume(\"is\")) {\n            return {\n              type: \"JsdocTypeAssertsPlain\",\n              element: left\n            };\n          }\n          return {\n            type: \"JsdocTypeAsserts\",\n            left,\n            right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n          };\n        }, \"parsePrefix\")\n      });\n      function createTupleParslet({ allowQuestionMark }) {\n        return composeParslet({\n          name: \"tupleParslet\",\n          accept: /* @__PURE__ */ __name((type) => type === \"[\", \"accept\"),\n          parsePrefix: /* @__PURE__ */ __name((parser) => {\n            parser.consume(\"[\");\n            const result = {\n              type: \"JsdocTypeTuple\",\n              elements: []\n            };\n            if (parser.consume(\"]\")) {\n              return result;\n            }\n            const typeList = parser.parseIntermediateType(Precedence.ALL);\n            if (typeList.type === \"JsdocTypeParameterList\") {\n              if (typeList.elements[0].type === \"JsdocTypeKeyValue\") {\n                result.elements = typeList.elements.map(assertPlainKeyValueResult);\n              } else {\n                result.elements = typeList.elements.map(assertRootResult);\n              }\n            } else {\n              if (typeList.type === \"JsdocTypeKeyValue\") {\n                result.elements = [assertPlainKeyValueResult(typeList)];\n              } else {\n                result.elements = [assertRootResult(typeList)];\n              }\n            }\n            if (!parser.consume(\"]\")) {\n              throw new Error(\"Unterminated '['\");\n            }\n            if (result.elements.some((e) => e.type === \"JsdocTypeUnknown\")) {\n              throw new Error(\"Question mark in tuple not allowed\");\n            }\n            return result;\n          }, \"parsePrefix\")\n        });\n      }\n      __name(createTupleParslet, \"createTupleParslet\");\n      const keyOfParslet = composeParslet({\n        name: \"keyOfParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"keyof\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          parser.consume(\"keyof\");\n          return {\n            type: \"JsdocTypeKeyof\",\n            element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))\n          };\n        }, \"parsePrefix\")\n      });\n      const importParslet = composeParslet({\n        name: \"importParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"import\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          parser.consume(\"import\");\n          if (!parser.consume(\"(\")) {\n            throw new Error(\"Missing parenthesis after import keyword\");\n          }\n          const path = parser.parseType(Precedence.PREFIX);\n          if (path.type !== \"JsdocTypeStringValue\") {\n            throw new Error(\"Only string values are allowed as paths for imports\");\n          }\n          if (!parser.consume(\")\")) {\n            throw new Error(\"Missing closing parenthesis after import keyword\");\n          }\n          return {\n            type: \"JsdocTypeImport\",\n            element: path\n          };\n        }, \"parsePrefix\")\n      });\n      const readonlyPropertyParslet = composeParslet({\n        name: \"readonlyPropertyParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"readonly\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          parser.consume(\"readonly\");\n          return {\n            type: \"JsdocTypeReadonlyProperty\",\n            element: parser.parseIntermediateType(Precedence.KEY_VALUE)\n          };\n        }, \"parsePrefix\")\n      });\n      const arrowFunctionParslet = composeParslet({\n        name: \"arrowFunctionParslet\",\n        precedence: Precedence.ARROW,\n        accept: /* @__PURE__ */ __name((type) => type === \"=>\", \"accept\"),\n        parseInfix: /* @__PURE__ */ __name((parser, left) => {\n          parser.consume(\"=>\");\n          return {\n            type: \"JsdocTypeFunction\",\n            parameters: getParameters(left).map(assertPlainKeyValueOrNameResult),\n            arrow: true,\n            constructor: false,\n            parenthesis: true,\n            returnType: parser.parseType(Precedence.OBJECT)\n          };\n        }, \"parseInfix\")\n      });\n      const genericArrowFunctionParslet = composeParslet({\n        name: \"genericArrowFunctionParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"<\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          const typeParameters = [];\n          parser.consume(\"<\");\n          do {\n            let defaultValue;\n            let name = parser.parseIntermediateType(Precedence.SYMBOL);\n            if (name.type === \"JsdocTypeOptional\") {\n              name = name.element;\n              defaultValue = parser.parseType(Precedence.SYMBOL);\n            }\n            if (name.type !== \"JsdocTypeName\") {\n              throw new UnexpectedTypeError(name);\n            }\n            let constraint;\n            if (parser.consume(\"extends\")) {\n              constraint = parser.parseType(Precedence.SYMBOL);\n              if (constraint.type === \"JsdocTypeOptional\") {\n                constraint = constraint.element;\n                defaultValue = parser.parseType(Precedence.SYMBOL);\n              }\n            }\n            const typeParameter = {\n              type: \"JsdocTypeTypeParameter\",\n              name\n            };\n            if (constraint !== void 0) {\n              typeParameter.constraint = constraint;\n            }\n            if (defaultValue !== void 0) {\n              typeParameter.defaultValue = defaultValue;\n            }\n            typeParameters.push(typeParameter);\n            if (parser.consume(\">\")) {\n              break;\n            }\n          } while (parser.consume(\",\"));\n          const functionBase = parser.parseIntermediateType(Precedence.SYMBOL);\n          functionBase.typeParameters = typeParameters;\n          return functionBase;\n        }, \"parsePrefix\")\n      });\n      const intersectionParslet = composeParslet({\n        name: \"intersectionParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"&\", \"accept\"),\n        precedence: Precedence.INTERSECTION,\n        parseInfix: /* @__PURE__ */ __name((parser, left) => {\n          parser.consume(\"&\");\n          const elements = [];\n          do {\n            elements.push(parser.parseType(Precedence.INTERSECTION));\n          } while (parser.consume(\"&\"));\n          return {\n            type: \"JsdocTypeIntersection\",\n            elements: [assertRootResult(left), ...elements]\n          };\n        }, \"parseInfix\")\n      });\n      const predicateParslet = composeParslet({\n        name: \"predicateParslet\",\n        precedence: Precedence.INFIX,\n        accept: /* @__PURE__ */ __name((type) => type === \"is\", \"accept\"),\n        parseInfix: /* @__PURE__ */ __name((parser, left) => {\n          if (left.type !== \"JsdocTypeName\") {\n            throw new UnexpectedTypeError(left, \"A typescript predicate always has to have a name on the left side.\");\n          }\n          parser.consume(\"is\");\n          return {\n            type: \"JsdocTypePredicate\",\n            left,\n            right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n          };\n        }, \"parseInfix\")\n      });\n      const objectSquaredPropertyParslet = composeParslet({\n        name: \"objectSquareBracketPropertyParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"[\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          if (parser.baseParser === void 0) {\n            throw new Error(\"Only allowed inside object grammar\");\n          }\n          parser.consume(\"[\");\n          const key = parser.lexer.current.text;\n          parser.consume(\"Identifier\");\n          let result;\n          if (parser.consume(\":\")) {\n            const parentParser = parser.baseParser;\n            parentParser.acceptLexerState(parser);\n            result = {\n              type: \"JsdocTypeIndexSignature\",\n              key,\n              right: parentParser.parseType(Precedence.INDEX_BRACKETS)\n            };\n            parser.acceptLexerState(parentParser);\n          } else if (parser.consume(\"in\")) {\n            const parentParser = parser.baseParser;\n            parentParser.acceptLexerState(parser);\n            result = {\n              type: \"JsdocTypeMappedType\",\n              key,\n              right: parentParser.parseType(Precedence.ARRAY_BRACKETS)\n            };\n            parser.acceptLexerState(parentParser);\n          } else {\n            throw new Error(\"Missing ':' or 'in' inside square bracketed property.\");\n          }\n          if (!parser.consume(\"]\")) {\n            throw new Error(\"Unterminated square brackets\");\n          }\n          return result;\n        }, \"parsePrefix\")\n      });\n      const readonlyArrayParslet = composeParslet({\n        name: \"readonlyArrayParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"readonly\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          parser.consume(\"readonly\");\n          return {\n            type: \"JsdocTypeReadonlyArray\",\n            element: assertArrayOrTupleResult(parser.parseIntermediateType(Precedence.ALL))\n          };\n        }, \"parsePrefix\")\n      });\n      const conditionalParslet = composeParslet({\n        name: \"conditionalParslet\",\n        precedence: Precedence.INFIX,\n        accept: /* @__PURE__ */ __name((type) => type === \"extends\", \"accept\"),\n        parseInfix: /* @__PURE__ */ __name((parser, left) => {\n          parser.consume(\"extends\");\n          const extendsType = parser.parseType(Precedence.KEY_OF_TYPE_OF).element;\n          const trueType = parser.parseType(Precedence.INFIX);\n          parser.consume(\":\");\n          return {\n            type: \"JsdocTypeConditional\",\n            checksType: assertRootResult(left),\n            extendsType,\n            trueType,\n            falseType: parser.parseType(Precedence.INFIX)\n          };\n        }, \"parseInfix\")\n      });\n      const objectFieldGrammar = [\n        readonlyPropertyParslet,\n        createNameParslet({\n          allowedAdditionalTokens: [\"typeof\", \"module\", \"keyof\", \"event\", \"external\", \"in\"]\n        }),\n        nullableParslet,\n        optionalParslet,\n        stringValueParslet,\n        numberParslet,\n        createObjectFieldParslet({\n          allowSquaredProperties: true,\n          allowKeyTypes: false,\n          allowOptional: true,\n          allowReadonly: true\n        }),\n        objectSquaredPropertyParslet\n      ];\n      const typescriptGrammar = [\n        ...baseGrammar,\n        createObjectParslet({\n          allowKeyTypes: false,\n          objectFieldGrammar\n        }),\n        readonlyArrayParslet,\n        typeOfParslet,\n        keyOfParslet,\n        importParslet,\n        stringValueParslet,\n        createFunctionParslet({\n          allowWithoutParenthesis: true,\n          allowNoReturnType: false,\n          allowNamedParameters: [\"this\", \"new\", \"args\"],\n          allowNewAsFunctionKeyword: true\n        }),\n        createTupleParslet({\n          allowQuestionMark: false\n        }),\n        createVariadicParslet({\n          allowEnclosingBrackets: false,\n          allowPostfix: false\n        }),\n        assertsParslet,\n        conditionalParslet,\n        createNameParslet({\n          allowedAdditionalTokens: [\"event\", \"external\", \"in\"]\n        }),\n        createSpecialNamePathParslet({\n          allowedTypes: [\"module\"],\n          pathGrammar\n        }),\n        arrayBracketsParslet,\n        arrowFunctionParslet,\n        genericArrowFunctionParslet,\n        createNamePathParslet({\n          allowSquareBracketsOnAnyType: true,\n          allowJsdocNamePaths: false,\n          pathGrammar\n        }),\n        intersectionParslet,\n        predicateParslet,\n        createKeyValueParslet({\n          allowVariadic: true,\n          allowOptional: true\n        })\n      ];\n      function parse3(expression, mode) {\n        switch (mode) {\n          case \"closure\":\n            return new Parser(closureGrammar, expression).parse();\n          case \"jsdoc\":\n            return new Parser(jsdocGrammar, expression).parse();\n          case \"typescript\":\n            return new Parser(typescriptGrammar, expression).parse();\n        }\n      }\n      __name(parse3, \"parse\");\n      function tryParse(expression, modes = [\"typescript\", \"closure\", \"jsdoc\"]) {\n        let error;\n        for (const mode of modes) {\n          try {\n            return parse3(expression, mode);\n          } catch (e) {\n            error = e;\n          }\n        }\n        throw error;\n      }\n      __name(tryParse, \"tryParse\");\n      function transform(rules2, parseResult) {\n        const rule = rules2[parseResult.type];\n        if (rule === void 0) {\n          throw new Error(`In this set of transform rules exists no rule for type ${parseResult.type}.`);\n        }\n        return rule(parseResult, (aParseResult) => transform(rules2, aParseResult));\n      }\n      __name(transform, \"transform\");\n      function notAvailableTransform(parseResult) {\n        throw new Error(\"This transform is not available. Are you trying the correct parsing mode?\");\n      }\n      __name(notAvailableTransform, \"notAvailableTransform\");\n      function extractSpecialParams(source) {\n        const result = {\n          params: []\n        };\n        for (const param of source.parameters) {\n          if (param.type === \"JsdocTypeKeyValue\") {\n            if (param.key === \"this\") {\n              result.this = param.right;\n            } else if (param.key === \"new\") {\n              result.new = param.right;\n            } else {\n              result.params.push(param);\n            }\n          } else {\n            result.params.push(param);\n          }\n        }\n        return result;\n      }\n      __name(extractSpecialParams, \"extractSpecialParams\");\n      function applyPosition(position, target, value) {\n        return position === \"prefix\" ? value + target : target + value;\n      }\n      __name(applyPosition, \"applyPosition\");\n      function quote(value, quote2) {\n        switch (quote2) {\n          case \"double\":\n            return `\"${value}\"`;\n          case \"single\":\n            return `'${value}'`;\n          case void 0:\n            return value;\n        }\n      }\n      __name(quote, \"quote\");\n      function stringifyRules2() {\n        return {\n          JsdocTypeParenthesis: /* @__PURE__ */ __name((result, transform2) => `(${result.element !== void 0 ? transform2(result.element) : \"\"})`, \"JsdocTypeParenthesis\"),\n          JsdocTypeKeyof: /* @__PURE__ */ __name((result, transform2) => `keyof ${transform2(result.element)}`, \"JsdocTypeKeyof\"),\n          JsdocTypeFunction: /* @__PURE__ */ __name((result, transform2) => {\n            var _a;\n            if (!result.arrow) {\n              let stringified = result.constructor ? \"new\" : \"function\";\n              if (!result.parenthesis) {\n                return stringified;\n              }\n              stringified += `(${result.parameters.map(transform2).join(\", \")})`;\n              if (result.returnType !== void 0) {\n                stringified += `: ${transform2(result.returnType)}`;\n              }\n              return stringified;\n            } else {\n              if (result.returnType === void 0) {\n                throw new Error(\"Arrow function needs a return type.\");\n              }\n              let stringified = `${result.typeParameters !== void 0 ? `<${(_a = result.typeParameters.map(transform2).join(\", \")) !== null && _a !== void 0 ? _a : \"\"}>` : \"\"}(${result.parameters.map(transform2).join(\", \")}) => ${transform2(result.returnType)}`;\n              if (result.constructor) {\n                stringified = \"new \" + stringified;\n              }\n              return stringified;\n            }\n          }, \"JsdocTypeFunction\"),\n          JsdocTypeName: /* @__PURE__ */ __name((result) => result.value, \"JsdocTypeName\"),\n          JsdocTypeTuple: /* @__PURE__ */ __name((result, transform2) => `[${result.elements.map(transform2).join(\", \")}]`, \"JsdocTypeTuple\"),\n          JsdocTypeVariadic: /* @__PURE__ */ __name((result, transform2) => result.meta.position === void 0 ? \"...\" : applyPosition(result.meta.position, transform2(result.element), \"...\"), \"JsdocTypeVariadic\"),\n          JsdocTypeNamePath: /* @__PURE__ */ __name((result, transform2) => {\n            const left = transform2(result.left);\n            const right = transform2(result.right);\n            switch (result.pathType) {\n              case \"inner\":\n                return `${left}~${right}`;\n              case \"instance\":\n                return `${left}#${right}`;\n              case \"property\":\n                return `${left}.${right}`;\n              case \"property-brackets\":\n                return `${left}[${right}]`;\n            }\n          }, \"JsdocTypeNamePath\"),\n          JsdocTypeStringValue: /* @__PURE__ */ __name((result) => quote(result.value, result.meta.quote), \"JsdocTypeStringValue\"),\n          JsdocTypeAny: /* @__PURE__ */ __name(() => \"*\", \"JsdocTypeAny\"),\n          JsdocTypeGeneric: /* @__PURE__ */ __name((result, transform2) => {\n            if (result.meta.brackets === \"square\") {\n              const element = result.elements[0];\n              const transformed = transform2(element);\n              if (element.type === \"JsdocTypeUnion\" || element.type === \"JsdocTypeIntersection\") {\n                return `(${transformed})[]`;\n              } else {\n                return `${transformed}[]`;\n              }\n            } else {\n              return `${transform2(result.left)}${result.meta.dot ? \".\" : \"\"}<${result.infer === true ? \"infer \" : \"\"}${result.elements.map(transform2).join(\", \")}>`;\n            }\n          }, \"JsdocTypeGeneric\"),\n          JsdocTypeImport: /* @__PURE__ */ __name((result, transform2) => `import(${transform2(result.element)})`, \"JsdocTypeImport\"),\n          JsdocTypeObjectField: /* @__PURE__ */ __name((result, transform2) => {\n            let text = \"\";\n            if (result.readonly) {\n              text += \"readonly \";\n            }\n            if (typeof result.key === \"string\") {\n              text += quote(result.key, result.meta.quote);\n            } else {\n              text += transform2(result.key);\n            }\n            if (result.optional) {\n              text += \"?\";\n            }\n            if (result.right === void 0) {\n              return text;\n            } else {\n              return text + `: ${transform2(result.right)}`;\n            }\n          }, \"JsdocTypeObjectField\"),\n          JsdocTypeJsdocObjectField: /* @__PURE__ */ __name((result, transform2) => {\n            return `${transform2(result.left)}: ${transform2(result.right)}`;\n          }, \"JsdocTypeJsdocObjectField\"),\n          JsdocTypeKeyValue: /* @__PURE__ */ __name((result, transform2) => {\n            let text = result.key;\n            if (result.optional) {\n              text += \"?\";\n            }\n            if (result.variadic) {\n              text = \"...\" + text;\n            }\n            if (result.right === void 0) {\n              return text;\n            } else {\n              return text + `: ${transform2(result.right)}`;\n            }\n          }, \"JsdocTypeKeyValue\"),\n          JsdocTypeSpecialNamePath: /* @__PURE__ */ __name((result) => `${result.specialType}:${quote(result.value, result.meta.quote)}`, \"JsdocTypeSpecialNamePath\"),\n          JsdocTypeNotNullable: /* @__PURE__ */ __name((result, transform2) => applyPosition(result.meta.position, transform2(result.element), \"!\"), \"JsdocTypeNotNullable\"),\n          JsdocTypeNull: /* @__PURE__ */ __name(() => \"null\", \"JsdocTypeNull\"),\n          JsdocTypeNullable: /* @__PURE__ */ __name((result, transform2) => applyPosition(result.meta.position, transform2(result.element), \"?\"), \"JsdocTypeNullable\"),\n          JsdocTypeNumber: /* @__PURE__ */ __name((result) => result.value.toString(), \"JsdocTypeNumber\"),\n          JsdocTypeObject: /* @__PURE__ */ __name((result, transform2) => {\n            var _a, _b;\n            return `{${(result.meta.separator === \"linebreak\" && result.elements.length > 1 ? \"\\n\" + ((_a = result.meta.propertyIndent) !== null && _a !== void 0 ? _a : \"\") : \"\") + result.elements.map(transform2).join(result.meta.separator === \"comma\" ? \", \" : result.meta.separator === \"linebreak\" ? \"\\n\" + ((_b = result.meta.propertyIndent) !== null && _b !== void 0 ? _b : \"\") : \"; \") + (result.meta.separator === \"linebreak\" && result.elements.length > 1 ? \"\\n\" : \"\")}}`;\n          }, \"JsdocTypeObject\"),\n          JsdocTypeOptional: /* @__PURE__ */ __name((result, transform2) => applyPosition(result.meta.position, transform2(result.element), \"=\"), \"JsdocTypeOptional\"),\n          JsdocTypeSymbol: /* @__PURE__ */ __name((result, transform2) => `${result.value}(${result.element !== void 0 ? transform2(result.element) : \"\"})`, \"JsdocTypeSymbol\"),\n          JsdocTypeTypeof: /* @__PURE__ */ __name((result, transform2) => `typeof ${transform2(result.element)}`, \"JsdocTypeTypeof\"),\n          JsdocTypeUndefined: /* @__PURE__ */ __name(() => \"undefined\", \"JsdocTypeUndefined\"),\n          JsdocTypeUnion: /* @__PURE__ */ __name((result, transform2) => result.elements.map(transform2).join(\" | \"), \"JsdocTypeUnion\"),\n          JsdocTypeUnknown: /* @__PURE__ */ __name(() => \"?\", \"JsdocTypeUnknown\"),\n          JsdocTypeIntersection: /* @__PURE__ */ __name((result, transform2) => result.elements.map(transform2).join(\" & \"), \"JsdocTypeIntersection\"),\n          JsdocTypeProperty: /* @__PURE__ */ __name((result) => quote(result.value, result.meta.quote), \"JsdocTypeProperty\"),\n          JsdocTypePredicate: /* @__PURE__ */ __name((result, transform2) => `${transform2(result.left)} is ${transform2(result.right)}`, \"JsdocTypePredicate\"),\n          JsdocTypeIndexSignature: /* @__PURE__ */ __name((result, transform2) => `[${result.key}: ${transform2(result.right)}]`, \"JsdocTypeIndexSignature\"),\n          JsdocTypeMappedType: /* @__PURE__ */ __name((result, transform2) => `[${result.key} in ${transform2(result.right)}]`, \"JsdocTypeMappedType\"),\n          JsdocTypeAsserts: /* @__PURE__ */ __name((result, transform2) => `asserts ${transform2(result.left)} is ${transform2(result.right)}`, \"JsdocTypeAsserts\"),\n          JsdocTypeReadonlyArray: /* @__PURE__ */ __name((result, transform2) => `readonly ${transform2(result.element)}`, \"JsdocTypeReadonlyArray\"),\n          JsdocTypeAssertsPlain: /* @__PURE__ */ __name((result, transform2) => `asserts ${transform2(result.element)}`, \"JsdocTypeAssertsPlain\"),\n          JsdocTypeConditional: /* @__PURE__ */ __name((result, transform2) => `${transform2(result.checksType)} extends ${transform2(result.extendsType)} ? ${transform2(result.trueType)} : ${transform2(result.falseType)}`, \"JsdocTypeConditional\"),\n          JsdocTypeTypeParameter: /* @__PURE__ */ __name((result, transform2) => `${transform2(result.name)}${result.constraint !== void 0 ? ` extends ${transform2(result.constraint)}` : \"\"}${result.defaultValue !== void 0 ? ` = ${transform2(result.defaultValue)}` : \"\"}`, \"JsdocTypeTypeParameter\")\n        };\n      }\n      __name(stringifyRules2, \"stringifyRules\");\n      const storedStringifyRules = stringifyRules2();\n      function stringify2(result) {\n        return transform(storedStringifyRules, result);\n      }\n      __name(stringify2, \"stringify\");\n      const reservedWords = [\n        \"null\",\n        \"true\",\n        \"false\",\n        \"break\",\n        \"case\",\n        \"catch\",\n        \"class\",\n        \"const\",\n        \"continue\",\n        \"debugger\",\n        \"default\",\n        \"delete\",\n        \"do\",\n        \"else\",\n        \"export\",\n        \"extends\",\n        \"finally\",\n        \"for\",\n        \"function\",\n        \"if\",\n        \"import\",\n        \"in\",\n        \"instanceof\",\n        \"new\",\n        \"return\",\n        \"super\",\n        \"switch\",\n        \"this\",\n        \"throw\",\n        \"try\",\n        \"typeof\",\n        \"var\",\n        \"void\",\n        \"while\",\n        \"with\",\n        \"yield\"\n      ];\n      function makeName(value) {\n        const result = {\n          type: \"NameExpression\",\n          name: value\n        };\n        if (reservedWords.includes(value)) {\n          result.reservedWord = true;\n        }\n        return result;\n      }\n      __name(makeName, \"makeName\");\n      const catharsisTransformRules = {\n        JsdocTypeOptional: /* @__PURE__ */ __name((result, transform2) => {\n          const transformed = transform2(result.element);\n          transformed.optional = true;\n          return transformed;\n        }, \"JsdocTypeOptional\"),\n        JsdocTypeNullable: /* @__PURE__ */ __name((result, transform2) => {\n          const transformed = transform2(result.element);\n          transformed.nullable = true;\n          return transformed;\n        }, \"JsdocTypeNullable\"),\n        JsdocTypeNotNullable: /* @__PURE__ */ __name((result, transform2) => {\n          const transformed = transform2(result.element);\n          transformed.nullable = false;\n          return transformed;\n        }, \"JsdocTypeNotNullable\"),\n        JsdocTypeVariadic: /* @__PURE__ */ __name((result, transform2) => {\n          if (result.element === void 0) {\n            throw new Error(\"dots without value are not allowed in catharsis mode\");\n          }\n          const transformed = transform2(result.element);\n          transformed.repeatable = true;\n          return transformed;\n        }, \"JsdocTypeVariadic\"),\n        JsdocTypeAny: /* @__PURE__ */ __name(() => ({\n          type: \"AllLiteral\"\n        }), \"JsdocTypeAny\"),\n        JsdocTypeNull: /* @__PURE__ */ __name(() => ({\n          type: \"NullLiteral\"\n        }), \"JsdocTypeNull\"),\n        JsdocTypeStringValue: /* @__PURE__ */ __name((result) => makeName(quote(result.value, result.meta.quote)), \"JsdocTypeStringValue\"),\n        JsdocTypeUndefined: /* @__PURE__ */ __name(() => ({\n          type: \"UndefinedLiteral\"\n        }), \"JsdocTypeUndefined\"),\n        JsdocTypeUnknown: /* @__PURE__ */ __name(() => ({\n          type: \"UnknownLiteral\"\n        }), \"JsdocTypeUnknown\"),\n        JsdocTypeFunction: /* @__PURE__ */ __name((result, transform2) => {\n          const params = extractSpecialParams(result);\n          const transformed = {\n            type: \"FunctionType\",\n            params: params.params.map(transform2)\n          };\n          if (params.this !== void 0) {\n            transformed.this = transform2(params.this);\n          }\n          if (params.new !== void 0) {\n            transformed.new = transform2(params.new);\n          }\n          if (result.returnType !== void 0) {\n            transformed.result = transform2(result.returnType);\n          }\n          return transformed;\n        }, \"JsdocTypeFunction\"),\n        JsdocTypeGeneric: /* @__PURE__ */ __name((result, transform2) => ({\n          type: \"TypeApplication\",\n          applications: result.elements.map((o) => transform2(o)),\n          expression: transform2(result.left)\n        }), \"JsdocTypeGeneric\"),\n        JsdocTypeSpecialNamePath: /* @__PURE__ */ __name((result) => makeName(result.specialType + \":\" + quote(result.value, result.meta.quote)), \"JsdocTypeSpecialNamePath\"),\n        JsdocTypeName: /* @__PURE__ */ __name((result) => {\n          if (result.value !== \"function\") {\n            return makeName(result.value);\n          } else {\n            return {\n              type: \"FunctionType\",\n              params: []\n            };\n          }\n        }, \"JsdocTypeName\"),\n        JsdocTypeNumber: /* @__PURE__ */ __name((result) => makeName(result.value.toString()), \"JsdocTypeNumber\"),\n        JsdocTypeObject: /* @__PURE__ */ __name((result, transform2) => {\n          const transformed = {\n            type: \"RecordType\",\n            fields: []\n          };\n          for (const field of result.elements) {\n            if (field.type !== \"JsdocTypeObjectField\" && field.type !== \"JsdocTypeJsdocObjectField\") {\n              transformed.fields.push({\n                type: \"FieldType\",\n                key: transform2(field),\n                value: void 0\n              });\n            } else {\n              transformed.fields.push(transform2(field));\n            }\n          }\n          return transformed;\n        }, \"JsdocTypeObject\"),\n        JsdocTypeObjectField: /* @__PURE__ */ __name((result, transform2) => {\n          if (typeof result.key !== \"string\") {\n            throw new Error(\"Index signatures and mapped types are not supported\");\n          }\n          return {\n            type: \"FieldType\",\n            key: makeName(quote(result.key, result.meta.quote)),\n            value: result.right === void 0 ? void 0 : transform2(result.right)\n          };\n        }, \"JsdocTypeObjectField\"),\n        JsdocTypeJsdocObjectField: /* @__PURE__ */ __name((result, transform2) => ({\n          type: \"FieldType\",\n          key: transform2(result.left),\n          value: transform2(result.right)\n        }), \"JsdocTypeJsdocObjectField\"),\n        JsdocTypeUnion: /* @__PURE__ */ __name((result, transform2) => ({\n          type: \"TypeUnion\",\n          elements: result.elements.map((e) => transform2(e))\n        }), \"JsdocTypeUnion\"),\n        JsdocTypeKeyValue: /* @__PURE__ */ __name((result, transform2) => {\n          return {\n            type: \"FieldType\",\n            key: makeName(result.key),\n            value: result.right === void 0 ? void 0 : transform2(result.right)\n          };\n        }, \"JsdocTypeKeyValue\"),\n        JsdocTypeNamePath: /* @__PURE__ */ __name((result, transform2) => {\n          const leftResult = transform2(result.left);\n          let rightValue;\n          if (result.right.type === \"JsdocTypeSpecialNamePath\") {\n            rightValue = transform2(result.right).name;\n          } else {\n            rightValue = quote(result.right.value, result.right.meta.quote);\n          }\n          const joiner = result.pathType === \"inner\" ? \"~\" : result.pathType === \"instance\" ? \"#\" : \".\";\n          return makeName(`${leftResult.name}${joiner}${rightValue}`);\n        }, \"JsdocTypeNamePath\"),\n        JsdocTypeSymbol: /* @__PURE__ */ __name((result) => {\n          let value = \"\";\n          let element = result.element;\n          let trailingDots = false;\n          if ((element === null || element === void 0 ? void 0 : element.type) === \"JsdocTypeVariadic\") {\n            if (element.meta.position === \"prefix\") {\n              value = \"...\";\n            } else {\n              trailingDots = true;\n            }\n            element = element.element;\n          }\n          if ((element === null || element === void 0 ? void 0 : element.type) === \"JsdocTypeName\") {\n            value += element.value;\n          } else if ((element === null || element === void 0 ? void 0 : element.type) === \"JsdocTypeNumber\") {\n            value += element.value.toString();\n          }\n          if (trailingDots) {\n            value += \"...\";\n          }\n          return makeName(`${result.value}(${value})`);\n        }, \"JsdocTypeSymbol\"),\n        JsdocTypeParenthesis: /* @__PURE__ */ __name((result, transform2) => transform2(assertRootResult(result.element)), \"JsdocTypeParenthesis\"),\n        JsdocTypeMappedType: notAvailableTransform,\n        JsdocTypeIndexSignature: notAvailableTransform,\n        JsdocTypeImport: notAvailableTransform,\n        JsdocTypeKeyof: notAvailableTransform,\n        JsdocTypeTuple: notAvailableTransform,\n        JsdocTypeTypeof: notAvailableTransform,\n        JsdocTypeIntersection: notAvailableTransform,\n        JsdocTypeProperty: notAvailableTransform,\n        JsdocTypePredicate: notAvailableTransform,\n        JsdocTypeAsserts: notAvailableTransform,\n        JsdocTypeReadonlyArray: notAvailableTransform,\n        JsdocTypeAssertsPlain: notAvailableTransform,\n        JsdocTypeConditional: notAvailableTransform,\n        JsdocTypeTypeParameter: notAvailableTransform\n      };\n      function catharsisTransform(result) {\n        return transform(catharsisTransformRules, result);\n      }\n      __name(catharsisTransform, \"catharsisTransform\");\n      function getQuoteStyle(quote2) {\n        switch (quote2) {\n          case void 0:\n            return \"none\";\n          case \"single\":\n            return \"single\";\n          case \"double\":\n            return \"double\";\n        }\n      }\n      __name(getQuoteStyle, \"getQuoteStyle\");\n      function getMemberType(type) {\n        switch (type) {\n          case \"inner\":\n            return \"INNER_MEMBER\";\n          case \"instance\":\n            return \"INSTANCE_MEMBER\";\n          case \"property\":\n            return \"MEMBER\";\n          case \"property-brackets\":\n            return \"MEMBER\";\n        }\n      }\n      __name(getMemberType, \"getMemberType\");\n      function nestResults(type, results) {\n        if (results.length === 2) {\n          return {\n            type,\n            left: results[0],\n            right: results[1]\n          };\n        } else {\n          return {\n            type,\n            left: results[0],\n            right: nestResults(type, results.slice(1))\n          };\n        }\n      }\n      __name(nestResults, \"nestResults\");\n      const jtpRules = {\n        JsdocTypeOptional: /* @__PURE__ */ __name((result, transform2) => ({\n          type: \"OPTIONAL\",\n          value: transform2(result.element),\n          meta: {\n            syntax: result.meta.position === \"prefix\" ? \"PREFIX_EQUAL_SIGN\" : \"SUFFIX_EQUALS_SIGN\"\n          }\n        }), \"JsdocTypeOptional\"),\n        JsdocTypeNullable: /* @__PURE__ */ __name((result, transform2) => ({\n          type: \"NULLABLE\",\n          value: transform2(result.element),\n          meta: {\n            syntax: result.meta.position === \"prefix\" ? \"PREFIX_QUESTION_MARK\" : \"SUFFIX_QUESTION_MARK\"\n          }\n        }), \"JsdocTypeNullable\"),\n        JsdocTypeNotNullable: /* @__PURE__ */ __name((result, transform2) => ({\n          type: \"NOT_NULLABLE\",\n          value: transform2(result.element),\n          meta: {\n            syntax: result.meta.position === \"prefix\" ? \"PREFIX_BANG\" : \"SUFFIX_BANG\"\n          }\n        }), \"JsdocTypeNotNullable\"),\n        JsdocTypeVariadic: /* @__PURE__ */ __name((result, transform2) => {\n          const transformed = {\n            type: \"VARIADIC\",\n            meta: {\n              syntax: result.meta.position === \"prefix\" ? \"PREFIX_DOTS\" : result.meta.position === \"suffix\" ? \"SUFFIX_DOTS\" : \"ONLY_DOTS\"\n            }\n          };\n          if (result.element !== void 0) {\n            transformed.value = transform2(result.element);\n          }\n          return transformed;\n        }, \"JsdocTypeVariadic\"),\n        JsdocTypeName: /* @__PURE__ */ __name((result) => ({\n          type: \"NAME\",\n          name: result.value\n        }), \"JsdocTypeName\"),\n        JsdocTypeTypeof: /* @__PURE__ */ __name((result, transform2) => ({\n          type: \"TYPE_QUERY\",\n          name: transform2(result.element)\n        }), \"JsdocTypeTypeof\"),\n        JsdocTypeTuple: /* @__PURE__ */ __name((result, transform2) => ({\n          type: \"TUPLE\",\n          entries: result.elements.map(transform2)\n        }), \"JsdocTypeTuple\"),\n        JsdocTypeKeyof: /* @__PURE__ */ __name((result, transform2) => ({\n          type: \"KEY_QUERY\",\n          value: transform2(result.element)\n        }), \"JsdocTypeKeyof\"),\n        JsdocTypeImport: /* @__PURE__ */ __name((result) => ({\n          type: \"IMPORT\",\n          path: {\n            type: \"STRING_VALUE\",\n            quoteStyle: getQuoteStyle(result.element.meta.quote),\n            string: result.element.value\n          }\n        }), \"JsdocTypeImport\"),\n        JsdocTypeUndefined: /* @__PURE__ */ __name(() => ({\n          type: \"NAME\",\n          name: \"undefined\"\n        }), \"JsdocTypeUndefined\"),\n        JsdocTypeAny: /* @__PURE__ */ __name(() => ({\n          type: \"ANY\"\n        }), \"JsdocTypeAny\"),\n        JsdocTypeFunction: /* @__PURE__ */ __name((result, transform2) => {\n          const specialParams = extractSpecialParams(result);\n          const transformed = {\n            type: result.arrow ? \"ARROW\" : \"FUNCTION\",\n            params: specialParams.params.map((param) => {\n              if (param.type === \"JsdocTypeKeyValue\") {\n                if (param.right === void 0) {\n                  throw new Error(\"Function parameter without ':' is not expected to be 'KEY_VALUE'\");\n                }\n                return {\n                  type: \"NAMED_PARAMETER\",\n                  name: param.key,\n                  typeName: transform2(param.right)\n                };\n              } else {\n                return transform2(param);\n              }\n            }),\n            new: null,\n            returns: null\n          };\n          if (specialParams.this !== void 0) {\n            transformed.this = transform2(specialParams.this);\n          } else if (!result.arrow) {\n            transformed.this = null;\n          }\n          if (specialParams.new !== void 0) {\n            transformed.new = transform2(specialParams.new);\n          }\n          if (result.returnType !== void 0) {\n            transformed.returns = transform2(result.returnType);\n          }\n          return transformed;\n        }, \"JsdocTypeFunction\"),\n        JsdocTypeGeneric: /* @__PURE__ */ __name((result, transform2) => {\n          const transformed = {\n            type: \"GENERIC\",\n            subject: transform2(result.left),\n            objects: result.elements.map(transform2),\n            meta: {\n              syntax: result.meta.brackets === \"square\" ? \"SQUARE_BRACKET\" : result.meta.dot ? \"ANGLE_BRACKET_WITH_DOT\" : \"ANGLE_BRACKET\"\n            }\n          };\n          if (result.meta.brackets === \"square\" && result.elements[0].type === \"JsdocTypeFunction\" && !result.elements[0].parenthesis) {\n            transformed.objects[0] = {\n              type: \"NAME\",\n              name: \"function\"\n            };\n          }\n          return transformed;\n        }, \"JsdocTypeGeneric\"),\n        JsdocTypeObjectField: /* @__PURE__ */ __name((result, transform2) => {\n          if (typeof result.key !== \"string\") {\n            throw new Error(\"Index signatures and mapped types are not supported\");\n          }\n          if (result.right === void 0) {\n            return {\n              type: \"RECORD_ENTRY\",\n              key: result.key,\n              quoteStyle: getQuoteStyle(result.meta.quote),\n              value: null,\n              readonly: false\n            };\n          }\n          let right = transform2(result.right);\n          if (result.optional) {\n            right = {\n              type: \"OPTIONAL\",\n              value: right,\n              meta: {\n                syntax: \"SUFFIX_KEY_QUESTION_MARK\"\n              }\n            };\n          }\n          return {\n            type: \"RECORD_ENTRY\",\n            key: result.key.toString(),\n            quoteStyle: getQuoteStyle(result.meta.quote),\n            value: right,\n            readonly: false\n          };\n        }, \"JsdocTypeObjectField\"),\n        JsdocTypeJsdocObjectField: /* @__PURE__ */ __name(() => {\n          throw new Error(\"Keys may not be typed in jsdoctypeparser.\");\n        }, \"JsdocTypeJsdocObjectField\"),\n        JsdocTypeKeyValue: /* @__PURE__ */ __name((result, transform2) => {\n          if (result.right === void 0) {\n            return {\n              type: \"RECORD_ENTRY\",\n              key: result.key,\n              quoteStyle: \"none\",\n              value: null,\n              readonly: false\n            };\n          }\n          let right = transform2(result.right);\n          if (result.optional) {\n            right = {\n              type: \"OPTIONAL\",\n              value: right,\n              meta: {\n                syntax: \"SUFFIX_KEY_QUESTION_MARK\"\n              }\n            };\n          }\n          return {\n            type: \"RECORD_ENTRY\",\n            key: result.key,\n            quoteStyle: \"none\",\n            value: right,\n            readonly: false\n          };\n        }, \"JsdocTypeKeyValue\"),\n        JsdocTypeObject: /* @__PURE__ */ __name((result, transform2) => {\n          const entries = [];\n          for (const field of result.elements) {\n            if (field.type === \"JsdocTypeObjectField\" || field.type === \"JsdocTypeJsdocObjectField\") {\n              entries.push(transform2(field));\n            }\n          }\n          return {\n            type: \"RECORD\",\n            entries\n          };\n        }, \"JsdocTypeObject\"),\n        JsdocTypeSpecialNamePath: /* @__PURE__ */ __name((result) => {\n          if (result.specialType !== \"module\") {\n            throw new Error(`jsdoctypeparser does not support type ${result.specialType} at this point.`);\n          }\n          return {\n            type: \"MODULE\",\n            value: {\n              type: \"FILE_PATH\",\n              quoteStyle: getQuoteStyle(result.meta.quote),\n              path: result.value\n            }\n          };\n        }, \"JsdocTypeSpecialNamePath\"),\n        JsdocTypeNamePath: /* @__PURE__ */ __name((result, transform2) => {\n          let hasEventPrefix = false;\n          let name;\n          let quoteStyle;\n          if (result.right.type === \"JsdocTypeSpecialNamePath\" && result.right.specialType === \"event\") {\n            hasEventPrefix = true;\n            name = result.right.value;\n            quoteStyle = getQuoteStyle(result.right.meta.quote);\n          } else {\n            name = result.right.value;\n            quoteStyle = getQuoteStyle(result.right.meta.quote);\n          }\n          const transformed = {\n            type: getMemberType(result.pathType),\n            owner: transform2(result.left),\n            name,\n            quoteStyle,\n            hasEventPrefix\n          };\n          if (transformed.owner.type === \"MODULE\") {\n            const tModule = transformed.owner;\n            transformed.owner = transformed.owner.value;\n            tModule.value = transformed;\n            return tModule;\n          } else {\n            return transformed;\n          }\n        }, \"JsdocTypeNamePath\"),\n        JsdocTypeUnion: /* @__PURE__ */ __name((result, transform2) => nestResults(\"UNION\", result.elements.map(transform2)), \"JsdocTypeUnion\"),\n        JsdocTypeParenthesis: /* @__PURE__ */ __name((result, transform2) => ({\n          type: \"PARENTHESIS\",\n          value: transform2(assertRootResult(result.element))\n        }), \"JsdocTypeParenthesis\"),\n        JsdocTypeNull: /* @__PURE__ */ __name(() => ({\n          type: \"NAME\",\n          name: \"null\"\n        }), \"JsdocTypeNull\"),\n        JsdocTypeUnknown: /* @__PURE__ */ __name(() => ({\n          type: \"UNKNOWN\"\n        }), \"JsdocTypeUnknown\"),\n        JsdocTypeStringValue: /* @__PURE__ */ __name((result) => ({\n          type: \"STRING_VALUE\",\n          quoteStyle: getQuoteStyle(result.meta.quote),\n          string: result.value\n        }), \"JsdocTypeStringValue\"),\n        JsdocTypeIntersection: /* @__PURE__ */ __name((result, transform2) => nestResults(\"INTERSECTION\", result.elements.map(transform2)), \"JsdocTypeIntersection\"),\n        JsdocTypeNumber: /* @__PURE__ */ __name((result) => ({\n          type: \"NUMBER_VALUE\",\n          number: result.value.toString()\n        }), \"JsdocTypeNumber\"),\n        JsdocTypeSymbol: notAvailableTransform,\n        JsdocTypeProperty: notAvailableTransform,\n        JsdocTypePredicate: notAvailableTransform,\n        JsdocTypeMappedType: notAvailableTransform,\n        JsdocTypeIndexSignature: notAvailableTransform,\n        JsdocTypeAsserts: notAvailableTransform,\n        JsdocTypeReadonlyArray: notAvailableTransform,\n        JsdocTypeAssertsPlain: notAvailableTransform,\n        JsdocTypeConditional: notAvailableTransform,\n        JsdocTypeTypeParameter: notAvailableTransform\n      };\n      function jtpTransform(result) {\n        return transform(jtpRules, result);\n      }\n      __name(jtpTransform, \"jtpTransform\");\n      function identityTransformRules() {\n        return {\n          JsdocTypeIntersection: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeIntersection\",\n            elements: result.elements.map(transform2)\n          }), \"JsdocTypeIntersection\"),\n          JsdocTypeGeneric: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeGeneric\",\n            left: transform2(result.left),\n            elements: result.elements.map(transform2),\n            meta: {\n              dot: result.meta.dot,\n              brackets: result.meta.brackets\n            }\n          }), \"JsdocTypeGeneric\"),\n          JsdocTypeNullable: /* @__PURE__ */ __name((result) => result, \"JsdocTypeNullable\"),\n          JsdocTypeUnion: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeUnion\",\n            elements: result.elements.map(transform2)\n          }), \"JsdocTypeUnion\"),\n          JsdocTypeUnknown: /* @__PURE__ */ __name((result) => result, \"JsdocTypeUnknown\"),\n          JsdocTypeUndefined: /* @__PURE__ */ __name((result) => result, \"JsdocTypeUndefined\"),\n          JsdocTypeTypeof: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeTypeof\",\n            element: transform2(result.element)\n          }), \"JsdocTypeTypeof\"),\n          JsdocTypeSymbol: /* @__PURE__ */ __name((result, transform2) => {\n            const transformed = {\n              type: \"JsdocTypeSymbol\",\n              value: result.value\n            };\n            if (result.element !== void 0) {\n              transformed.element = transform2(result.element);\n            }\n            return transformed;\n          }, \"JsdocTypeSymbol\"),\n          JsdocTypeOptional: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeOptional\",\n            element: transform2(result.element),\n            meta: {\n              position: result.meta.position\n            }\n          }), \"JsdocTypeOptional\"),\n          JsdocTypeObject: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeObject\",\n            meta: {\n              separator: \"comma\"\n            },\n            elements: result.elements.map(transform2)\n          }), \"JsdocTypeObject\"),\n          JsdocTypeNumber: /* @__PURE__ */ __name((result) => result, \"JsdocTypeNumber\"),\n          JsdocTypeNull: /* @__PURE__ */ __name((result) => result, \"JsdocTypeNull\"),\n          JsdocTypeNotNullable: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeNotNullable\",\n            element: transform2(result.element),\n            meta: {\n              position: result.meta.position\n            }\n          }), \"JsdocTypeNotNullable\"),\n          JsdocTypeSpecialNamePath: /* @__PURE__ */ __name((result) => result, \"JsdocTypeSpecialNamePath\"),\n          JsdocTypeObjectField: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeObjectField\",\n            key: result.key,\n            right: result.right === void 0 ? void 0 : transform2(result.right),\n            optional: result.optional,\n            readonly: result.readonly,\n            meta: result.meta\n          }), \"JsdocTypeObjectField\"),\n          JsdocTypeJsdocObjectField: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeJsdocObjectField\",\n            left: transform2(result.left),\n            right: transform2(result.right)\n          }), \"JsdocTypeJsdocObjectField\"),\n          JsdocTypeKeyValue: /* @__PURE__ */ __name((result, transform2) => {\n            return {\n              type: \"JsdocTypeKeyValue\",\n              key: result.key,\n              right: result.right === void 0 ? void 0 : transform2(result.right),\n              optional: result.optional,\n              variadic: result.variadic\n            };\n          }, \"JsdocTypeKeyValue\"),\n          JsdocTypeImport: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeImport\",\n            element: transform2(result.element)\n          }), \"JsdocTypeImport\"),\n          JsdocTypeAny: /* @__PURE__ */ __name((result) => result, \"JsdocTypeAny\"),\n          JsdocTypeStringValue: /* @__PURE__ */ __name((result) => result, \"JsdocTypeStringValue\"),\n          JsdocTypeNamePath: /* @__PURE__ */ __name((result) => result, \"JsdocTypeNamePath\"),\n          JsdocTypeVariadic: /* @__PURE__ */ __name((result, transform2) => {\n            const transformed = {\n              type: \"JsdocTypeVariadic\",\n              meta: {\n                position: result.meta.position,\n                squareBrackets: result.meta.squareBrackets\n              }\n            };\n            if (result.element !== void 0) {\n              transformed.element = transform2(result.element);\n            }\n            return transformed;\n          }, \"JsdocTypeVariadic\"),\n          JsdocTypeTuple: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeTuple\",\n            elements: result.elements.map(transform2)\n          }), \"JsdocTypeTuple\"),\n          JsdocTypeName: /* @__PURE__ */ __name((result) => result, \"JsdocTypeName\"),\n          JsdocTypeFunction: /* @__PURE__ */ __name((result, transform2) => {\n            const transformed = {\n              type: \"JsdocTypeFunction\",\n              arrow: result.arrow,\n              parameters: result.parameters.map(transform2),\n              constructor: result.constructor,\n              parenthesis: result.parenthesis\n            };\n            if (result.returnType !== void 0) {\n              transformed.returnType = transform2(result.returnType);\n            }\n            return transformed;\n          }, \"JsdocTypeFunction\"),\n          JsdocTypeKeyof: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeKeyof\",\n            element: transform2(result.element)\n          }), \"JsdocTypeKeyof\"),\n          JsdocTypeParenthesis: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeParenthesis\",\n            element: transform2(result.element)\n          }), \"JsdocTypeParenthesis\"),\n          JsdocTypeProperty: /* @__PURE__ */ __name((result) => result, \"JsdocTypeProperty\"),\n          JsdocTypePredicate: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypePredicate\",\n            left: transform2(result.left),\n            right: transform2(result.right)\n          }), \"JsdocTypePredicate\"),\n          JsdocTypeIndexSignature: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeIndexSignature\",\n            key: result.key,\n            right: transform2(result.right)\n          }), \"JsdocTypeIndexSignature\"),\n          JsdocTypeMappedType: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeMappedType\",\n            key: result.key,\n            right: transform2(result.right)\n          }), \"JsdocTypeMappedType\"),\n          JsdocTypeAsserts: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeAsserts\",\n            left: transform2(result.left),\n            right: transform2(result.right)\n          }), \"JsdocTypeAsserts\"),\n          JsdocTypeReadonlyArray: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeReadonlyArray\",\n            element: transform2(result.element)\n          }), \"JsdocTypeReadonlyArray\"),\n          JsdocTypeAssertsPlain: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeAssertsPlain\",\n            element: transform2(result.element)\n          }), \"JsdocTypeAssertsPlain\"),\n          JsdocTypeConditional: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeConditional\",\n            checksType: transform2(result.checksType),\n            extendsType: transform2(result.extendsType),\n            trueType: transform2(result.trueType),\n            falseType: transform2(result.falseType)\n          }), \"JsdocTypeConditional\"),\n          JsdocTypeTypeParameter: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeTypeParameter\",\n            name: transform2(result.name),\n            constraint: result.constraint !== void 0 ? transform2(result.constraint) : void 0,\n            defaultValue: result.defaultValue !== void 0 ? transform2(result.defaultValue) : void 0\n          }), \"JsdocTypeTypeParameter\")\n        };\n      }\n      __name(identityTransformRules, \"identityTransformRules\");\n      const visitorKeys = {\n        JsdocTypeAny: [],\n        JsdocTypeFunction: [\"parameters\", \"returnType\"],\n        JsdocTypeGeneric: [\"left\", \"elements\"],\n        JsdocTypeImport: [],\n        JsdocTypeIndexSignature: [\"right\"],\n        JsdocTypeIntersection: [\"elements\"],\n        JsdocTypeKeyof: [\"element\"],\n        JsdocTypeKeyValue: [\"right\"],\n        JsdocTypeMappedType: [\"right\"],\n        JsdocTypeName: [],\n        JsdocTypeNamePath: [\"left\", \"right\"],\n        JsdocTypeNotNullable: [\"element\"],\n        JsdocTypeNull: [],\n        JsdocTypeNullable: [\"element\"],\n        JsdocTypeNumber: [],\n        JsdocTypeObject: [\"elements\"],\n        JsdocTypeObjectField: [\"right\"],\n        JsdocTypeJsdocObjectField: [\"left\", \"right\"],\n        JsdocTypeOptional: [\"element\"],\n        JsdocTypeParenthesis: [\"element\"],\n        JsdocTypeSpecialNamePath: [],\n        JsdocTypeStringValue: [],\n        JsdocTypeSymbol: [\"element\"],\n        JsdocTypeTuple: [\"elements\"],\n        JsdocTypeTypeof: [\"element\"],\n        JsdocTypeUndefined: [],\n        JsdocTypeUnion: [\"elements\"],\n        JsdocTypeUnknown: [],\n        JsdocTypeVariadic: [\"element\"],\n        JsdocTypeProperty: [],\n        JsdocTypePredicate: [\"left\", \"right\"],\n        JsdocTypeAsserts: [\"left\", \"right\"],\n        JsdocTypeReadonlyArray: [\"element\"],\n        JsdocTypeAssertsPlain: [\"element\"],\n        JsdocTypeConditional: [\"checksType\", \"extendsType\", \"trueType\", \"falseType\"],\n        JsdocTypeTypeParameter: [\"name\", \"constraint\", \"defaultValue\"]\n      };\n      function _traverse(node, parentNode, property, onEnter, onLeave) {\n        onEnter === null || onEnter === void 0 ? void 0 : onEnter(node, parentNode, property);\n        const keysToVisit = visitorKeys[node.type];\n        for (const key of keysToVisit) {\n          const value = node[key];\n          if (value !== void 0) {\n            if (Array.isArray(value)) {\n              for (const element of value) {\n                _traverse(element, node, key, onEnter, onLeave);\n              }\n            } else {\n              _traverse(value, node, key, onEnter, onLeave);\n            }\n          }\n        }\n        onLeave === null || onLeave === void 0 ? void 0 : onLeave(node, parentNode, property);\n      }\n      __name(_traverse, \"_traverse\");\n      function traverse(node, onEnter, onLeave) {\n        _traverse(node, void 0, void 0, onEnter, onLeave);\n      }\n      __name(traverse, \"traverse\");\n      exports2.catharsisTransform = catharsisTransform;\n      exports2.identityTransformRules = identityTransformRules;\n      exports2.jtpTransform = jtpTransform;\n      exports2.parse = parse3;\n      exports2.stringify = stringify2;\n      exports2.stringifyRules = stringifyRules2;\n      exports2.transform = transform;\n      exports2.traverse = traverse;\n      exports2.tryParse = tryParse;\n      exports2.visitorKeys = visitorKeys;\n    });\n  }\n});\n\n// src/docs-tools/argTypes/convert/flow/convert.ts\nimport { UnknownArgTypesError } from \"storybook/internal/preview-errors\";\nvar isLiteral = /* @__PURE__ */ __name((type) => type.name === \"literal\", \"isLiteral\");\nvar toEnumOption = /* @__PURE__ */ __name((element) => element.value.replace(/['|\"]/g, \"\"), \"toEnumOption\");\nvar convertSig = /* @__PURE__ */ __name((type) => {\n  switch (type.type) {\n    case \"function\":\n      return { name: \"function\" };\n    case \"object\":\n      const values = {};\n      type.signature.properties.forEach((prop) => {\n        values[prop.key] = convert(prop.value);\n      });\n      return {\n        name: \"object\",\n        value: values\n      };\n    default:\n      throw new UnknownArgTypesError({ type, language: \"Flow\" });\n  }\n}, \"convertSig\");\nvar convert = /* @__PURE__ */ __name((type) => {\n  const { name, raw } = type;\n  const base = {};\n  if (typeof raw !== \"undefined\") {\n    base.raw = raw;\n  }\n  switch (type.name) {\n    case \"literal\":\n      return { ...base, name: \"other\", value: type.value };\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n    case \"boolean\": {\n      return { ...base, name };\n    }\n    case \"Array\": {\n      return { ...base, name: \"array\", value: type.elements.map(convert) };\n    }\n    case \"signature\":\n      return { ...base, ...convertSig(type) };\n    case \"union\":\n      if (type.elements?.every(isLiteral)) {\n        return { ...base, name: \"enum\", value: type.elements?.map(toEnumOption) };\n      }\n      return { ...base, name, value: type.elements?.map(convert) };\n    case \"intersection\":\n      return { ...base, name, value: type.elements?.map(convert) };\n    default:\n      return { ...base, name: \"other\", value: name };\n  }\n}, \"convert\");\n\n// src/docs-tools/argTypes/convert/utils.ts\nvar QUOTE_REGEX = /^['\"]|['\"]$/g;\nvar trimQuotes = /* @__PURE__ */ __name((str2) => str2.replace(QUOTE_REGEX, \"\"), \"trimQuotes\");\nvar includesQuotes = /* @__PURE__ */ __name((str2) => QUOTE_REGEX.test(str2), \"includesQuotes\");\nvar parseLiteral = /* @__PURE__ */ __name((str2) => {\n  const trimmedValue = trimQuotes(str2);\n  return includesQuotes(str2) || Number.isNaN(Number(trimmedValue)) ? trimmedValue : Number(trimmedValue);\n}, \"parseLiteral\");\n\n// src/docs-tools/argTypes/convert/proptypes/convert.ts\nvar SIGNATURE_REGEXP = /^\\(.*\\) => /;\nvar convert2 = /* @__PURE__ */ __name((type) => {\n  const { name, raw, computed, value } = type;\n  const base = {};\n  if (typeof raw !== \"undefined\") {\n    base.raw = raw;\n  }\n  switch (name) {\n    case \"enum\": {\n      const values2 = computed ? value : value.map((v) => parseLiteral(v.value));\n      return { ...base, name, value: values2 };\n    }\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n      return { ...base, name };\n    case \"func\":\n      return { ...base, name: \"function\" };\n    case \"bool\":\n    case \"boolean\":\n      return { ...base, name: \"boolean\" };\n    case \"arrayOf\":\n    case \"array\":\n      return { ...base, name: \"array\", value: value && convert2(value) };\n    case \"object\":\n      return { ...base, name };\n    case \"objectOf\":\n      return { ...base, name, value: convert2(value) };\n    case \"shape\":\n    case \"exact\":\n      const values = mapValues(value, (field) => convert2(field));\n      return { ...base, name: \"object\", value: values };\n    case \"union\":\n      return { ...base, name: \"union\", value: value.map((v) => convert2(v)) };\n    case \"instanceOf\":\n    case \"element\":\n    case \"elementType\":\n    default: {\n      if (name?.indexOf(\"|\") > 0) {\n        try {\n          const literalValues = name.split(\"|\").map((v) => JSON.parse(v));\n          return { ...base, name: \"enum\", value: literalValues };\n        } catch (err) {\n        }\n      }\n      const otherVal = value ? `${name}(${value})` : name;\n      const otherName = SIGNATURE_REGEXP.test(name) ? \"function\" : \"other\";\n      return { ...base, name: otherName, value: otherVal };\n    }\n  }\n}, \"convert\");\n\n// src/docs-tools/argTypes/convert/typescript/convert.ts\nimport { UnknownArgTypesError as UnknownArgTypesError2 } from \"storybook/internal/preview-errors\";\nvar convertSig2 = /* @__PURE__ */ __name((type) => {\n  switch (type.type) {\n    case \"function\":\n      return { name: \"function\" };\n    case \"object\":\n      const values = {};\n      type.signature.properties.forEach((prop) => {\n        values[prop.key] = convert3(prop.value);\n      });\n      return {\n        name: \"object\",\n        value: values\n      };\n    default:\n      throw new UnknownArgTypesError2({ type, language: \"Typescript\" });\n  }\n}, \"convertSig\");\nvar convert3 = /* @__PURE__ */ __name((type) => {\n  const { name, raw } = type;\n  const base = {};\n  if (typeof raw !== \"undefined\") {\n    base.raw = raw;\n  }\n  switch (type.name) {\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n    case \"boolean\": {\n      return { ...base, name };\n    }\n    case \"Array\": {\n      return { ...base, name: \"array\", value: type.elements.map(convert3) };\n    }\n    case \"signature\":\n      return { ...base, ...convertSig2(type) };\n    case \"union\":\n      let result;\n      if (type.elements?.every((element) => element.name === \"literal\")) {\n        result = {\n          ...base,\n          name: \"enum\",\n          // @ts-expect-error fix types\n          value: type.elements?.map((v) => parseLiteral(v.value))\n        };\n      } else {\n        result = { ...base, name, value: type.elements?.map(convert3) };\n      }\n      return result;\n    case \"intersection\":\n      return { ...base, name, value: type.elements?.map(convert3) };\n    default:\n      return { ...base, name: \"other\", value: name };\n  }\n}, \"convert\");\n\n// src/docs-tools/argTypes/convert/index.ts\nvar convert4 = /* @__PURE__ */ __name((docgenInfo) => {\n  const { type, tsType, flowType } = docgenInfo;\n  try {\n    if (type != null) {\n      return convert2(type);\n    }\n    if (tsType != null) {\n      return convert3(tsType);\n    }\n    if (flowType != null) {\n      return convert(flowType);\n    }\n  } catch (err) {\n    console.error(err);\n  }\n  return null;\n}, \"convert\");\n\n// src/docs-tools/argTypes/docgen/types.ts\nvar TypeSystem = /* @__PURE__ */ ((TypeSystem2) => {\n  TypeSystem2[\"JAVASCRIPT\"] = \"JavaScript\";\n  TypeSystem2[\"FLOW\"] = \"Flow\";\n  TypeSystem2[\"TYPESCRIPT\"] = \"TypeScript\";\n  TypeSystem2[\"UNKNOWN\"] = \"Unknown\";\n  return TypeSystem2;\n})(TypeSystem || {});\n\n// src/docs-tools/argTypes/docgen/utils/defaultValue.ts\nvar BLACKLIST = [\"null\", \"undefined\"];\nfunction isDefaultValueBlacklisted(value) {\n  return BLACKLIST.some((x) => x === value);\n}\n__name(isDefaultValueBlacklisted, \"isDefaultValueBlacklisted\");\n\n// src/docs-tools/argTypes/docgen/utils/string.ts\nvar str = /* @__PURE__ */ __name((obj) => {\n  if (!obj) {\n    return \"\";\n  }\n  if (typeof obj === \"string\") {\n    return obj;\n  }\n  throw new Error(`Description: expected string, got: ${JSON.stringify(obj)}`);\n}, \"str\");\n\n// src/docs-tools/argTypes/docgen/utils/docgenInfo.ts\nfunction hasDocgen(component) {\n  return !!component.__docgenInfo;\n}\n__name(hasDocgen, \"hasDocgen\");\nfunction isValidDocgenSection(docgenSection) {\n  return docgenSection != null && Object.keys(docgenSection).length > 0;\n}\n__name(isValidDocgenSection, \"isValidDocgenSection\");\nfunction getDocgenSection(component, section) {\n  return hasDocgen(component) ? component.__docgenInfo[section] : null;\n}\n__name(getDocgenSection, \"getDocgenSection\");\nfunction getDocgenDescription(component) {\n  return hasDocgen(component) ? str(component.__docgenInfo.description) : \"\";\n}\n__name(getDocgenDescription, \"getDocgenDescription\");\n\n// ../node_modules/comment-parser/es6/primitives.js\nvar Markers;\n(function(Markers2) {\n  Markers2[\"start\"] = \"/**\";\n  Markers2[\"nostart\"] = \"/***\";\n  Markers2[\"delim\"] = \"*\";\n  Markers2[\"end\"] = \"*/\";\n})(Markers = Markers || (Markers = {}));\n\n// ../node_modules/comment-parser/es6/util.js\nfunction isSpace(source) {\n  return /^\\s+$/.test(source);\n}\n__name(isSpace, \"isSpace\");\nfunction splitCR(source) {\n  const matches = source.match(/\\r+$/);\n  return matches == null ? [\"\", source] : [source.slice(-matches[0].length), source.slice(0, -matches[0].length)];\n}\n__name(splitCR, \"splitCR\");\nfunction splitSpace(source) {\n  const matches = source.match(/^\\s+/);\n  return matches == null ? [\"\", source] : [source.slice(0, matches[0].length), source.slice(matches[0].length)];\n}\n__name(splitSpace, \"splitSpace\");\nfunction splitLines(source) {\n  return source.split(/\\n/);\n}\n__name(splitLines, \"splitLines\");\nfunction seedSpec(spec = {}) {\n  return Object.assign({ tag: \"\", name: \"\", type: \"\", optional: false, description: \"\", problems: [], source: [] }, spec);\n}\n__name(seedSpec, \"seedSpec\");\nfunction seedTokens(tokens = {}) {\n  return Object.assign({ start: \"\", delimiter: \"\", postDelimiter: \"\", tag: \"\", postTag: \"\", name: \"\", postName: \"\", type: \"\", postType: \"\", description: \"\", end: \"\", lineEnd: \"\" }, tokens);\n}\n__name(seedTokens, \"seedTokens\");\n\n// ../node_modules/comment-parser/es6/parser/block-parser.js\nvar reTag = /^@\\S+/;\nfunction getParser({ fence = \"```\" } = {}) {\n  const fencer = getFencer(fence);\n  const toggleFence = /* @__PURE__ */ __name((source, isFenced) => fencer(source) ? !isFenced : isFenced, \"toggleFence\");\n  return /* @__PURE__ */ __name(function parseBlock(source) {\n    const sections = [[]];\n    let isFenced = false;\n    for (const line of source) {\n      if (reTag.test(line.tokens.description) && !isFenced) {\n        sections.push([line]);\n      } else {\n        sections[sections.length - 1].push(line);\n      }\n      isFenced = toggleFence(line.tokens.description, isFenced);\n    }\n    return sections;\n  }, \"parseBlock\");\n}\n__name(getParser, \"getParser\");\nfunction getFencer(fence) {\n  if (typeof fence === \"string\")\n    return (source) => source.split(fence).length % 2 === 0;\n  return fence;\n}\n__name(getFencer, \"getFencer\");\n\n// ../node_modules/comment-parser/es6/parser/source-parser.js\nfunction getParser2({ startLine = 0, markers = Markers } = {}) {\n  let block = null;\n  let num = startLine;\n  return /* @__PURE__ */ __name(function parseSource(source) {\n    let rest = source;\n    const tokens = seedTokens();\n    [tokens.lineEnd, rest] = splitCR(rest);\n    [tokens.start, rest] = splitSpace(rest);\n    if (block === null && rest.startsWith(markers.start) && !rest.startsWith(markers.nostart)) {\n      block = [];\n      tokens.delimiter = rest.slice(0, markers.start.length);\n      rest = rest.slice(markers.start.length);\n      [tokens.postDelimiter, rest] = splitSpace(rest);\n    }\n    if (block === null) {\n      num++;\n      return null;\n    }\n    const isClosed = rest.trimRight().endsWith(markers.end);\n    if (tokens.delimiter === \"\" && rest.startsWith(markers.delim) && !rest.startsWith(markers.end)) {\n      tokens.delimiter = markers.delim;\n      rest = rest.slice(markers.delim.length);\n      [tokens.postDelimiter, rest] = splitSpace(rest);\n    }\n    if (isClosed) {\n      const trimmed = rest.trimRight();\n      tokens.end = rest.slice(trimmed.length - markers.end.length);\n      rest = trimmed.slice(0, -markers.end.length);\n    }\n    tokens.description = rest;\n    block.push({ number: num, source, tokens });\n    num++;\n    if (isClosed) {\n      const result = block.slice();\n      block = null;\n      return result;\n    }\n    return null;\n  }, \"parseSource\");\n}\n__name(getParser2, \"getParser\");\n\n// ../node_modules/comment-parser/es6/parser/spec-parser.js\nfunction getParser3({ tokenizers }) {\n  return /* @__PURE__ */ __name(function parseSpec(source) {\n    var _a;\n    let spec = seedSpec({ source });\n    for (const tokenize of tokenizers) {\n      spec = tokenize(spec);\n      if ((_a = spec.problems[spec.problems.length - 1]) === null || _a === void 0 ? void 0 : _a.critical)\n        break;\n    }\n    return spec;\n  }, \"parseSpec\");\n}\n__name(getParser3, \"getParser\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/tag.js\nfunction tagTokenizer() {\n  return (spec) => {\n    const { tokens } = spec.source[0];\n    const match = tokens.description.match(/\\s*(@(\\S+))(\\s*)/);\n    if (match === null) {\n      spec.problems.push({\n        code: \"spec:tag:prefix\",\n        message: 'tag should start with \"@\" symbol',\n        line: spec.source[0].number,\n        critical: true\n      });\n      return spec;\n    }\n    tokens.tag = match[1];\n    tokens.postTag = match[3];\n    tokens.description = tokens.description.slice(match[0].length);\n    spec.tag = match[2];\n    return spec;\n  };\n}\n__name(tagTokenizer, \"tagTokenizer\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/type.js\nfunction typeTokenizer(spacing = \"compact\") {\n  const join2 = getJoiner(spacing);\n  return (spec) => {\n    let curlies = 0;\n    let lines = [];\n    for (const [i, { tokens }] of spec.source.entries()) {\n      let type = \"\";\n      if (i === 0 && tokens.description[0] !== \"{\")\n        return spec;\n      for (const ch of tokens.description) {\n        if (ch === \"{\")\n          curlies++;\n        if (ch === \"}\")\n          curlies--;\n        type += ch;\n        if (curlies === 0)\n          break;\n      }\n      lines.push([tokens, type]);\n      if (curlies === 0)\n        break;\n    }\n    if (curlies !== 0) {\n      spec.problems.push({\n        code: \"spec:type:unpaired-curlies\",\n        message: \"unpaired curlies\",\n        line: spec.source[0].number,\n        critical: true\n      });\n      return spec;\n    }\n    const parts = [];\n    const offset = lines[0][0].postDelimiter.length;\n    for (const [i, [tokens, type]] of lines.entries()) {\n      tokens.type = type;\n      if (i > 0) {\n        tokens.type = tokens.postDelimiter.slice(offset) + type;\n        tokens.postDelimiter = tokens.postDelimiter.slice(0, offset);\n      }\n      [tokens.postType, tokens.description] = splitSpace(tokens.description.slice(type.length));\n      parts.push(tokens.type);\n    }\n    parts[0] = parts[0].slice(1);\n    parts[parts.length - 1] = parts[parts.length - 1].slice(0, -1);\n    spec.type = join2(parts);\n    return spec;\n  };\n}\n__name(typeTokenizer, \"typeTokenizer\");\nvar trim = /* @__PURE__ */ __name((x) => x.trim(), \"trim\");\nfunction getJoiner(spacing) {\n  if (spacing === \"compact\")\n    return (t) => t.map(trim).join(\"\");\n  else if (spacing === \"preserve\")\n    return (t) => t.join(\"\\n\");\n  else\n    return spacing;\n}\n__name(getJoiner, \"getJoiner\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/name.js\nvar isQuoted = /* @__PURE__ */ __name((s) => s && s.startsWith('\"') && s.endsWith('\"'), \"isQuoted\");\nfunction nameTokenizer() {\n  const typeEnd = /* @__PURE__ */ __name((num, { tokens }, i) => tokens.type === \"\" ? num : i, \"typeEnd\");\n  return (spec) => {\n    const { tokens } = spec.source[spec.source.reduce(typeEnd, 0)];\n    const source = tokens.description.trimLeft();\n    const quotedGroups = source.split('\"');\n    if (quotedGroups.length > 1 && quotedGroups[0] === \"\" && quotedGroups.length % 2 === 1) {\n      spec.name = quotedGroups[1];\n      tokens.name = `\"${quotedGroups[1]}\"`;\n      [tokens.postName, tokens.description] = splitSpace(source.slice(tokens.name.length));\n      return spec;\n    }\n    let brackets = 0;\n    let name = \"\";\n    let optional = false;\n    let defaultValue;\n    for (const ch of source) {\n      if (brackets === 0 && isSpace(ch))\n        break;\n      if (ch === \"[\")\n        brackets++;\n      if (ch === \"]\")\n        brackets--;\n      name += ch;\n    }\n    if (brackets !== 0) {\n      spec.problems.push({\n        code: \"spec:name:unpaired-brackets\",\n        message: \"unpaired brackets\",\n        line: spec.source[0].number,\n        critical: true\n      });\n      return spec;\n    }\n    const nameToken = name;\n    if (name[0] === \"[\" && name[name.length - 1] === \"]\") {\n      optional = true;\n      name = name.slice(1, -1);\n      const parts = name.split(\"=\");\n      name = parts[0].trim();\n      if (parts[1] !== void 0)\n        defaultValue = parts.slice(1).join(\"=\").trim();\n      if (name === \"\") {\n        spec.problems.push({\n          code: \"spec:name:empty-name\",\n          message: \"empty name\",\n          line: spec.source[0].number,\n          critical: true\n        });\n        return spec;\n      }\n      if (defaultValue === \"\") {\n        spec.problems.push({\n          code: \"spec:name:empty-default\",\n          message: \"empty default value\",\n          line: spec.source[0].number,\n          critical: true\n        });\n        return spec;\n      }\n      if (!isQuoted(defaultValue) && /=(?!>)/.test(defaultValue)) {\n        spec.problems.push({\n          code: \"spec:name:invalid-default\",\n          message: \"invalid default value syntax\",\n          line: spec.source[0].number,\n          critical: true\n        });\n        return spec;\n      }\n    }\n    spec.optional = optional;\n    spec.name = name;\n    tokens.name = nameToken;\n    if (defaultValue !== void 0)\n      spec.default = defaultValue;\n    [tokens.postName, tokens.description] = splitSpace(source.slice(tokens.name.length));\n    return spec;\n  };\n}\n__name(nameTokenizer, \"nameTokenizer\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/description.js\nfunction descriptionTokenizer(spacing = \"compact\", markers = Markers) {\n  const join2 = getJoiner2(spacing);\n  return (spec) => {\n    spec.description = join2(spec.source, markers);\n    return spec;\n  };\n}\n__name(descriptionTokenizer, \"descriptionTokenizer\");\nfunction getJoiner2(spacing) {\n  if (spacing === \"compact\")\n    return compactJoiner;\n  if (spacing === \"preserve\")\n    return preserveJoiner;\n  return spacing;\n}\n__name(getJoiner2, \"getJoiner\");\nfunction compactJoiner(lines, markers = Markers) {\n  return lines.map(({ tokens: { description } }) => description.trim()).filter((description) => description !== \"\").join(\" \");\n}\n__name(compactJoiner, \"compactJoiner\");\nvar lineNo = /* @__PURE__ */ __name((num, { tokens }, i) => tokens.type === \"\" ? num : i, \"lineNo\");\nvar getDescription = /* @__PURE__ */ __name(({ tokens }) => (tokens.delimiter === \"\" ? tokens.start : tokens.postDelimiter.slice(1)) + tokens.description, \"getDescription\");\nfunction preserveJoiner(lines, markers = Markers) {\n  if (lines.length === 0)\n    return \"\";\n  if (lines[0].tokens.description === \"\" && lines[0].tokens.delimiter === markers.start)\n    lines = lines.slice(1);\n  const lastLine = lines[lines.length - 1];\n  if (lastLine !== void 0 && lastLine.tokens.description === \"\" && lastLine.tokens.end.endsWith(markers.end))\n    lines = lines.slice(0, -1);\n  lines = lines.slice(lines.reduce(lineNo, 0));\n  return lines.map(getDescription).join(\"\\n\");\n}\n__name(preserveJoiner, \"preserveJoiner\");\n\n// ../node_modules/comment-parser/es6/parser/index.js\nfunction getParser4({ startLine = 0, fence = \"```\", spacing = \"compact\", markers = Markers, tokenizers = [\n  tagTokenizer(),\n  typeTokenizer(spacing),\n  nameTokenizer(),\n  descriptionTokenizer(spacing)\n] } = {}) {\n  if (startLine < 0 || startLine % 1 > 0)\n    throw new Error(\"Invalid startLine\");\n  const parseSource = getParser2({ startLine, markers });\n  const parseBlock = getParser({ fence });\n  const parseSpec = getParser3({ tokenizers });\n  const joinDescription = getJoiner2(spacing);\n  return function(source) {\n    const blocks = [];\n    for (const line of splitLines(source)) {\n      const lines = parseSource(line);\n      if (lines === null)\n        continue;\n      const sections = parseBlock(lines);\n      const specs = sections.slice(1).map(parseSpec);\n      blocks.push({\n        description: joinDescription(sections[0], markers),\n        tags: specs,\n        source: lines,\n        problems: specs.reduce((acc, spec) => acc.concat(spec.problems), [])\n      });\n    }\n    return blocks;\n  };\n}\n__name(getParser4, \"getParser\");\n\n// ../node_modules/comment-parser/es6/stringifier/index.js\nfunction join(tokens) {\n  return tokens.start + tokens.delimiter + tokens.postDelimiter + tokens.tag + tokens.postTag + tokens.type + tokens.postType + tokens.name + tokens.postName + tokens.description + tokens.end + tokens.lineEnd;\n}\n__name(join, \"join\");\nfunction getStringifier() {\n  return (block) => block.source.map(({ tokens }) => join(tokens)).join(\"\\n\");\n}\n__name(getStringifier, \"getStringifier\");\n\n// ../node_modules/comment-parser/es6/stringifier/inspect.js\nvar zeroWidth = {\n  line: 0,\n  start: 0,\n  delimiter: 0,\n  postDelimiter: 0,\n  tag: 0,\n  postTag: 0,\n  name: 0,\n  postName: 0,\n  type: 0,\n  postType: 0,\n  description: 0,\n  end: 0,\n  lineEnd: 0\n};\nvar fields = Object.keys(zeroWidth);\n\n// ../node_modules/comment-parser/es6/index.js\nfunction parse(source, options = {}) {\n  return getParser4(options)(source);\n}\n__name(parse, \"parse\");\nvar stringify = getStringifier();\n\n// src/docs-tools/argTypes/jsdocParser.ts\nvar import_jsdoc_type_pratt_parser = __toESM(require_dist(), 1);\nfunction containsJsDoc(value) {\n  return value != null && value.includes(\"@\");\n}\n__name(containsJsDoc, \"containsJsDoc\");\nfunction parse2(content) {\n  const contentString = content ?? \"\";\n  const mappedLines = contentString.split(\"\\n\").map((line) => ` * ${line}`).join(\"\\n\");\n  const normalisedContent = \"/**\\n\" + mappedLines + \"\\n*/\";\n  const ast = parse(normalisedContent, {\n    spacing: \"preserve\"\n  });\n  if (!ast || ast.length === 0) {\n    throw new Error(\"Cannot parse JSDoc tags.\");\n  }\n  return ast[0];\n}\n__name(parse2, \"parse\");\nvar DEFAULT_OPTIONS = {\n  tags: [\"param\", \"arg\", \"argument\", \"returns\", \"ignore\", \"deprecated\"]\n};\nvar parseJsDoc = /* @__PURE__ */ __name((value, options = DEFAULT_OPTIONS) => {\n  if (!containsJsDoc(value)) {\n    return {\n      includesJsDoc: false,\n      ignore: false\n    };\n  }\n  const jsDocAst = parse2(value);\n  const extractedTags = extractJsDocTags(jsDocAst, options.tags);\n  if (extractedTags.ignore) {\n    return {\n      includesJsDoc: true,\n      ignore: true\n    };\n  }\n  return {\n    includesJsDoc: true,\n    ignore: false,\n    // Always use the parsed description to ensure JSDoc is removed from the description.\n    description: jsDocAst.description.trim(),\n    extractedTags\n  };\n}, \"parseJsDoc\");\nfunction extractJsDocTags(ast, tags) {\n  const extractedTags = {\n    params: null,\n    deprecated: null,\n    returns: null,\n    ignore: false\n  };\n  for (const tagSpec of ast.tags) {\n    if (tags !== void 0 && !tags.includes(tagSpec.tag)) {\n      continue;\n    }\n    if (tagSpec.tag === \"ignore\") {\n      extractedTags.ignore = true;\n      break;\n    } else {\n      switch (tagSpec.tag) {\n        // arg & argument are aliases for param.\n        case \"param\":\n        case \"arg\":\n        case \"argument\": {\n          const paramTag = extractParam(tagSpec);\n          if (paramTag != null) {\n            if (extractedTags.params == null) {\n              extractedTags.params = [];\n            }\n            extractedTags.params.push(paramTag);\n          }\n          break;\n        }\n        case \"deprecated\": {\n          const deprecatedTag = extractDeprecated(tagSpec);\n          if (deprecatedTag != null) {\n            extractedTags.deprecated = deprecatedTag;\n          }\n          break;\n        }\n        case \"returns\": {\n          const returnsTag = extractReturns(tagSpec);\n          if (returnsTag != null) {\n            extractedTags.returns = returnsTag;\n          }\n          break;\n        }\n        default:\n          break;\n      }\n    }\n  }\n  return extractedTags;\n}\n__name(extractJsDocTags, \"extractJsDocTags\");\nfunction normaliseParamName(name) {\n  return name.replace(/[\\.-]$/, \"\");\n}\n__name(normaliseParamName, \"normaliseParamName\");\nfunction extractParam(tag) {\n  if (!tag.name || tag.name === \"-\") {\n    return null;\n  }\n  const type = extractType(tag.type);\n  return {\n    name: tag.name,\n    type,\n    description: normaliseDescription(tag.description),\n    getPrettyName: /* @__PURE__ */ __name(() => {\n      return normaliseParamName(tag.name);\n    }, \"getPrettyName\"),\n    getTypeName: /* @__PURE__ */ __name(() => {\n      return type ? extractTypeName(type) : null;\n    }, \"getTypeName\")\n  };\n}\n__name(extractParam, \"extractParam\");\nfunction extractDeprecated(tag) {\n  if (tag.name) {\n    return joinNameAndDescription(tag.name, tag.description);\n  }\n  return null;\n}\n__name(extractDeprecated, \"extractDeprecated\");\nfunction joinNameAndDescription(name, desc) {\n  const joined = name === \"\" ? desc : `${name} ${desc}`;\n  return normaliseDescription(joined);\n}\n__name(joinNameAndDescription, \"joinNameAndDescription\");\nfunction normaliseDescription(text) {\n  const normalised = text.replace(/^- /g, \"\").trim();\n  return normalised === \"\" ? null : normalised;\n}\n__name(normaliseDescription, \"normaliseDescription\");\nfunction extractReturns(tag) {\n  const type = extractType(tag.type);\n  if (type) {\n    return {\n      type,\n      description: joinNameAndDescription(tag.name, tag.description),\n      getTypeName: /* @__PURE__ */ __name(() => {\n        return extractTypeName(type);\n      }, \"getTypeName\")\n    };\n  }\n  return null;\n}\n__name(extractReturns, \"extractReturns\");\nvar jsdocStringifyRules = (0, import_jsdoc_type_pratt_parser.stringifyRules)();\nvar originalJsdocStringifyObject = jsdocStringifyRules.JsdocTypeObject;\njsdocStringifyRules.JsdocTypeAny = () => \"any\";\njsdocStringifyRules.JsdocTypeObject = (result, transform) => `(${originalJsdocStringifyObject(result, transform)})`;\njsdocStringifyRules.JsdocTypeOptional = (result, transform) => transform(result.element);\njsdocStringifyRules.JsdocTypeNullable = (result, transform) => transform(result.element);\njsdocStringifyRules.JsdocTypeNotNullable = (result, transform) => transform(result.element);\njsdocStringifyRules.JsdocTypeUnion = (result, transform) => result.elements.map(transform).join(\"|\");\nfunction extractType(typeString) {\n  try {\n    return (0, import_jsdoc_type_pratt_parser.parse)(typeString, \"typescript\");\n  } catch (_err) {\n    return null;\n  }\n}\n__name(extractType, \"extractType\");\nfunction extractTypeName(type) {\n  return (0, import_jsdoc_type_pratt_parser.transform)(jsdocStringifyRules, type);\n}\n__name(extractTypeName, \"extractTypeName\");\n\n// src/docs-tools/argTypes/utils.ts\nvar MAX_TYPE_SUMMARY_LENGTH = 90;\nvar MAX_DEFAULT_VALUE_SUMMARY_LENGTH = 50;\nfunction isTooLongForTypeSummary(value) {\n  return value.length > MAX_TYPE_SUMMARY_LENGTH;\n}\n__name(isTooLongForTypeSummary, \"isTooLongForTypeSummary\");\nfunction isTooLongForDefaultValueSummary(value) {\n  return value.length > MAX_DEFAULT_VALUE_SUMMARY_LENGTH;\n}\n__name(isTooLongForDefaultValueSummary, \"isTooLongForDefaultValueSummary\");\nfunction createSummaryValue(summary, detail) {\n  if (summary === detail) {\n    return { summary };\n  }\n  return { summary, detail };\n}\n__name(createSummaryValue, \"createSummaryValue\");\nvar normalizeNewlines = /* @__PURE__ */ __name((string) => string.replace(/\\\\r\\\\n/g, \"\\\\n\"), \"normalizeNewlines\");\n\n// src/docs-tools/argTypes/docgen/flow/createDefaultValue.ts\nfunction createDefaultValue(defaultValue, type) {\n  if (defaultValue != null) {\n    const { value } = defaultValue;\n    if (!isDefaultValueBlacklisted(value)) {\n      return !isTooLongForDefaultValueSummary(value) ? createSummaryValue(value) : createSummaryValue(type?.name, value);\n    }\n  }\n  return null;\n}\n__name(createDefaultValue, \"createDefaultValue\");\n\n// src/docs-tools/argTypes/docgen/flow/createType.ts\nfunction generateUnionElement({ name, value, elements, raw }) {\n  if (value != null) {\n    return value;\n  }\n  if (elements != null) {\n    return elements.map(generateUnionElement).join(\" | \");\n  }\n  if (raw != null) {\n    return raw;\n  }\n  return name;\n}\n__name(generateUnionElement, \"generateUnionElement\");\nfunction generateUnion({ name, raw, elements }) {\n  if (elements != null) {\n    return createSummaryValue(elements.map(generateUnionElement).join(\" | \"));\n  }\n  if (raw != null) {\n    return createSummaryValue(raw.replace(/^\\|\\s*/, \"\"));\n  }\n  return createSummaryValue(name);\n}\n__name(generateUnion, \"generateUnion\");\nfunction generateFuncSignature({ type, raw }) {\n  if (raw != null) {\n    return createSummaryValue(raw);\n  }\n  return createSummaryValue(type);\n}\n__name(generateFuncSignature, \"generateFuncSignature\");\nfunction generateObjectSignature({ type, raw }) {\n  if (raw != null) {\n    return !isTooLongForTypeSummary(raw) ? createSummaryValue(raw) : createSummaryValue(type, raw);\n  }\n  return createSummaryValue(type);\n}\n__name(generateObjectSignature, \"generateObjectSignature\");\nfunction generateSignature(flowType) {\n  const { type } = flowType;\n  return type === \"object\" ? generateObjectSignature(flowType) : generateFuncSignature(flowType);\n}\n__name(generateSignature, \"generateSignature\");\nfunction generateDefault({ name, raw }) {\n  if (raw != null) {\n    return !isTooLongForTypeSummary(raw) ? createSummaryValue(raw) : createSummaryValue(name, raw);\n  }\n  return createSummaryValue(name);\n}\n__name(generateDefault, \"generateDefault\");\nfunction createType(type) {\n  if (type == null) {\n    return null;\n  }\n  switch (type.name) {\n    case \"union\" /* UNION */:\n      return generateUnion(type);\n    case \"signature\" /* SIGNATURE */:\n      return generateSignature(type);\n    default:\n      return generateDefault(type);\n  }\n}\n__name(createType, \"createType\");\n\n// src/docs-tools/argTypes/docgen/flow/createPropDef.ts\nvar createFlowPropDef = /* @__PURE__ */ __name((propName, docgenInfo) => {\n  const { flowType, description, required, defaultValue } = docgenInfo;\n  return {\n    name: propName,\n    type: createType(flowType),\n    required,\n    description,\n    defaultValue: createDefaultValue(defaultValue ?? null, flowType ?? null)\n  };\n}, \"createFlowPropDef\");\n\n// src/docs-tools/argTypes/docgen/typeScript/createDefaultValue.ts\nfunction createDefaultValue2({ defaultValue }) {\n  if (defaultValue != null) {\n    const { value } = defaultValue;\n    if (!isDefaultValueBlacklisted(value)) {\n      return createSummaryValue(value);\n    }\n  }\n  return null;\n}\n__name(createDefaultValue2, \"createDefaultValue\");\n\n// src/docs-tools/argTypes/docgen/typeScript/createType.ts\nfunction createType2({ tsType, required }) {\n  if (tsType == null) {\n    return null;\n  }\n  let typeName = tsType.name;\n  if (!required) {\n    typeName = typeName.replace(\" | undefined\", \"\");\n  }\n  return createSummaryValue(\n    [\"Array\", \"Record\", \"signature\"].includes(tsType.name) ? tsType.raw : typeName\n  );\n}\n__name(createType2, \"createType\");\n\n// src/docs-tools/argTypes/docgen/typeScript/createPropDef.ts\nvar createTsPropDef = /* @__PURE__ */ __name((propName, docgenInfo) => {\n  const { description, required } = docgenInfo;\n  return {\n    name: propName,\n    type: createType2(docgenInfo),\n    required,\n    description,\n    defaultValue: createDefaultValue2(docgenInfo)\n  };\n}, \"createTsPropDef\");\n\n// src/docs-tools/argTypes/docgen/createPropDef.ts\nfunction createType3(type) {\n  return type != null ? createSummaryValue(type.name) : null;\n}\n__name(createType3, \"createType\");\nfunction isReactDocgenTypescript(defaultValue) {\n  const { computed, func } = defaultValue;\n  return typeof computed === \"undefined\" && typeof func === \"undefined\";\n}\n__name(isReactDocgenTypescript, \"isReactDocgenTypescript\");\nfunction isStringValued(type) {\n  if (!type) {\n    return false;\n  }\n  if (type.name === \"string\") {\n    return true;\n  }\n  if (type.name === \"enum\") {\n    return Array.isArray(type.value) && type.value.every(\n      ({ value: tv }) => typeof tv === \"string\" && tv[0] === '\"' && tv[tv.length - 1] === '\"'\n    );\n  }\n  return false;\n}\n__name(isStringValued, \"isStringValued\");\nfunction createDefaultValue3(defaultValue, type) {\n  if (defaultValue != null) {\n    const { value } = defaultValue;\n    if (!isDefaultValueBlacklisted(value)) {\n      if (isReactDocgenTypescript(defaultValue) && isStringValued(type)) {\n        return createSummaryValue(JSON.stringify(value));\n      }\n      return createSummaryValue(value);\n    }\n  }\n  return null;\n}\n__name(createDefaultValue3, \"createDefaultValue\");\nfunction createBasicPropDef(name, type, docgenInfo) {\n  const { description, required, defaultValue } = docgenInfo;\n  return {\n    name,\n    type: createType3(type),\n    required,\n    description,\n    defaultValue: createDefaultValue3(defaultValue, type)\n  };\n}\n__name(createBasicPropDef, \"createBasicPropDef\");\nfunction applyJsDocResult(propDef, jsDocParsingResult) {\n  if (jsDocParsingResult?.includesJsDoc) {\n    const { description, extractedTags } = jsDocParsingResult;\n    if (description != null) {\n      propDef.description = jsDocParsingResult.description;\n    }\n    const value = {\n      ...extractedTags,\n      params: extractedTags?.params?.map(\n        (x) => ({\n          name: x.getPrettyName(),\n          description: x.description\n        })\n      )\n    };\n    if (Object.values(value).filter(Boolean).length > 0) {\n      propDef.jsDocTags = value;\n    }\n  }\n  return propDef;\n}\n__name(applyJsDocResult, \"applyJsDocResult\");\nvar javaScriptFactory = /* @__PURE__ */ __name((propName, docgenInfo, jsDocParsingResult) => {\n  const propDef = createBasicPropDef(propName, docgenInfo.type, docgenInfo);\n  propDef.sbType = convert4(docgenInfo);\n  return applyJsDocResult(propDef, jsDocParsingResult);\n}, \"javaScriptFactory\");\nvar tsFactory = /* @__PURE__ */ __name((propName, docgenInfo, jsDocParsingResult) => {\n  const propDef = createTsPropDef(propName, docgenInfo);\n  propDef.sbType = convert4(docgenInfo);\n  return applyJsDocResult(propDef, jsDocParsingResult);\n}, \"tsFactory\");\nvar flowFactory = /* @__PURE__ */ __name((propName, docgenInfo, jsDocParsingResult) => {\n  const propDef = createFlowPropDef(propName, docgenInfo);\n  propDef.sbType = convert4(docgenInfo);\n  return applyJsDocResult(propDef, jsDocParsingResult);\n}, \"flowFactory\");\nvar unknownFactory = /* @__PURE__ */ __name((propName, docgenInfo, jsDocParsingResult) => {\n  const propDef = createBasicPropDef(propName, { name: \"unknown\" }, docgenInfo);\n  return applyJsDocResult(propDef, jsDocParsingResult);\n}, \"unknownFactory\");\nvar getPropDefFactory = /* @__PURE__ */ __name((typeSystem) => {\n  switch (typeSystem) {\n    case \"JavaScript\" /* JAVASCRIPT */:\n      return javaScriptFactory;\n    case \"TypeScript\" /* TYPESCRIPT */:\n      return tsFactory;\n    case \"Flow\" /* FLOW */:\n      return flowFactory;\n    default:\n      return unknownFactory;\n  }\n}, \"getPropDefFactory\");\n\n// src/docs-tools/argTypes/docgen/extractDocgenProps.ts\nvar getTypeSystem = /* @__PURE__ */ __name((docgenInfo) => {\n  if (docgenInfo.type != null) {\n    return \"JavaScript\" /* JAVASCRIPT */;\n  }\n  if (docgenInfo.flowType != null) {\n    return \"Flow\" /* FLOW */;\n  }\n  if (docgenInfo.tsType != null) {\n    return \"TypeScript\" /* TYPESCRIPT */;\n  }\n  return \"Unknown\" /* UNKNOWN */;\n}, \"getTypeSystem\");\nvar extractComponentSectionArray = /* @__PURE__ */ __name((docgenSection) => {\n  const typeSystem = getTypeSystem(docgenSection[0]);\n  const createPropDef = getPropDefFactory(typeSystem);\n  return docgenSection.map((item) => {\n    let sanitizedItem = item;\n    if (item.type?.elements) {\n      sanitizedItem = {\n        ...item,\n        type: {\n          ...item.type,\n          value: item.type.elements\n        }\n      };\n    }\n    return extractProp(sanitizedItem.name, sanitizedItem, typeSystem, createPropDef);\n  });\n}, \"extractComponentSectionArray\");\nvar extractComponentSectionObject = /* @__PURE__ */ __name((docgenSection) => {\n  const docgenPropsKeys = Object.keys(docgenSection);\n  const typeSystem = getTypeSystem(docgenSection[docgenPropsKeys[0]]);\n  const createPropDef = getPropDefFactory(typeSystem);\n  return docgenPropsKeys.map((propName) => {\n    const docgenInfo = docgenSection[propName];\n    return docgenInfo != null ? extractProp(propName, docgenInfo, typeSystem, createPropDef) : null;\n  }).filter(Boolean);\n}, \"extractComponentSectionObject\");\nvar extractComponentProps = /* @__PURE__ */ __name((component, section) => {\n  const docgenSection = getDocgenSection(component, section);\n  if (!isValidDocgenSection(docgenSection)) {\n    return [];\n  }\n  return Array.isArray(docgenSection) ? extractComponentSectionArray(docgenSection) : extractComponentSectionObject(docgenSection);\n}, \"extractComponentProps\");\nfunction extractProp(propName, docgenInfo, typeSystem, createPropDef) {\n  const jsDocParsingResult = parseJsDoc(docgenInfo.description);\n  const isIgnored = jsDocParsingResult.includesJsDoc && jsDocParsingResult.ignore;\n  if (!isIgnored) {\n    const propDef = createPropDef(propName, docgenInfo, jsDocParsingResult);\n    return {\n      propDef,\n      jsDocTags: jsDocParsingResult.extractedTags,\n      docgenInfo,\n      typeSystem\n    };\n  }\n  return null;\n}\n__name(extractProp, \"extractProp\");\nfunction extractComponentDescription(component) {\n  return component != null ? getDocgenDescription(component) : \"\";\n}\n__name(extractComponentDescription, \"extractComponentDescription\");\n\n// src/preview-api/modules/store/parameters.ts\nvar combineParameters = /* @__PURE__ */ __name((...parameterSets) => {\n  const mergeKeys = {};\n  const definedParametersSets = parameterSets.filter(Boolean);\n  const combined = definedParametersSets.reduce((acc, parameters) => {\n    Object.entries(parameters).forEach(([key, value]) => {\n      const existing = acc[key];\n      if (Array.isArray(value) || typeof existing === \"undefined\") {\n        acc[key] = value;\n      } else if (isPlainObject(value) && isPlainObject(existing)) {\n        mergeKeys[key] = true;\n      } else if (typeof value !== \"undefined\") {\n        acc[key] = value;\n      }\n    });\n    return acc;\n  }, {});\n  Object.keys(mergeKeys).forEach((key) => {\n    const mergeValues = definedParametersSets.filter(Boolean).map((p) => p[key]).filter((value) => typeof value !== \"undefined\");\n    if (mergeValues.every((value) => isPlainObject(value))) {\n      combined[key] = combineParameters(...mergeValues);\n    } else {\n      combined[key] = mergeValues[mergeValues.length - 1];\n    }\n  });\n  return combined;\n}, \"combineParameters\");\n\n// src/docs-tools/argTypes/enhanceArgTypes.ts\nvar enhanceArgTypes = /* @__PURE__ */ __name((context) => {\n  const {\n    component,\n    argTypes: userArgTypes,\n    parameters: { docs = {} }\n  } = context;\n  const { extractArgTypes } = docs;\n  if (!extractArgTypes || !component) {\n    return userArgTypes;\n  }\n  const extractedArgTypes = extractArgTypes(component);\n  return extractedArgTypes ? combineParameters(extractedArgTypes, userArgTypes) : userArgTypes;\n}, \"enhanceArgTypes\");\n\n// src/docs-tools/shared.ts\nvar ADDON_ID = \"storybook/docs\";\nvar PANEL_ID = `${ADDON_ID}/panel`;\nvar PARAM_KEY = `docs`;\nvar SNIPPET_RENDERED = `${ADDON_ID}/snippet-rendered`;\nvar SourceType = /* @__PURE__ */ ((SourceType2) => {\n  SourceType2[\"AUTO\"] = \"auto\";\n  SourceType2[\"CODE\"] = \"code\";\n  SourceType2[\"DYNAMIC\"] = \"dynamic\";\n  return SourceType2;\n})(SourceType || {});\n\nexport {\n  combineParameters,\n  convert4 as convert,\n  TypeSystem,\n  isDefaultValueBlacklisted,\n  str,\n  hasDocgen,\n  isValidDocgenSection,\n  getDocgenSection,\n  getDocgenDescription,\n  parseJsDoc,\n  MAX_TYPE_SUMMARY_LENGTH,\n  MAX_DEFAULT_VALUE_SUMMARY_LENGTH,\n  isTooLongForTypeSummary,\n  isTooLongForDefaultValueSummary,\n  createSummaryValue,\n  normalizeNewlines,\n  extractComponentSectionArray,\n  extractComponentSectionObject,\n  extractComponentProps,\n  extractComponentDescription,\n  enhanceArgTypes,\n  ADDON_ID,\n  PANEL_ID,\n  PARAM_KEY,\n  SNIPPET_RENDERED,\n  SourceType\n};\n",
      "start": 1762256767098,
      "end": 1762256767126,
      "sourcemaps": null
    },
    {
      "name": "storybook:mock-loader",
      "start": 1762256767126,
      "end": 1762256767126,
      "order": "normal-pre"
    },
    {
      "name": "vite-plugin-svelte",
      "start": 1762256767126,
      "end": 1762256767126,
      "order": "pre"
    },
    {
      "name": "plugin-csf",
      "start": 1762256767126,
      "end": 1762256767126,
      "order": "pre"
    },
    {
      "name": "vite:esbuild",
      "start": 1762256767126,
      "end": 1762256767126,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1762256767126,
      "end": 1762256767126,
      "order": "normal-normal"
    },
    {
      "name": "storybook:mock-loader-preview",
      "start": 1762256767126,
      "end": 1762256767126,
      "order": "normal"
    },
    {
      "name": "storybook:svelte-docgen-plugin",
      "start": 1762256767126,
      "end": 1762256767126,
      "order": "normal"
    },
    {
      "name": "storybook:addon-svelte-csf",
      "start": 1762256767126,
      "end": 1762256767126,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1762256767126,
      "end": 1762256767126,
      "order": "normal-normal"
    },
    {
      "name": "vite:build-html",
      "start": 1762256767126,
      "end": 1762256767126,
      "order": "normal-normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1762256767126,
      "end": 1762256767126,
      "order": "normal-normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1762256767126,
      "end": 1762256767126,
      "order": "normal-normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1762256767131,
      "end": 1762256767131,
      "order": "normal-normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1762256767131,
      "end": 1762256767131,
      "order": "normal-normal"
    },
    {
      "name": "vite-plugin-svelte-module",
      "start": 1762256767131,
      "end": 1762256767131,
      "order": "post"
    },
    {
      "name": "storybook:inject-export-order-plugin",
      "start": 1762256767131,
      "end": 1762256767131,
      "order": "post"
    },
    {
      "name": "storybook:strip-hmr-boundary-plugin",
      "start": 1762256767131,
      "end": 1762256767131,
      "order": "post"
    },
    {
      "name": "storybook:external-globals-plugin",
      "result": "import {\n  mapValues\n} from \"./chunk-UTNZYD2N.js\";\nimport {\n  isPlainObject\n} from \"./chunk-FSBVR7H5.js\";\nimport {\n  __commonJS,\n  __name,\n  __toESM\n} from \"./chunk-MM7DTO55.js\";\n\n// ../node_modules/jsdoc-type-pratt-parser/dist/index.js\nvar require_dist = __commonJS({\n  \"../node_modules/jsdoc-type-pratt-parser/dist/index.js\"(exports, module) {\n    (function(global, factory) {\n      typeof exports === \"object\" && typeof module !== \"undefined\" ? factory(exports) : typeof define === \"function\" && define.amd ? define([\"exports\"], factory) : (global = typeof globalThis !== \"undefined\" ? globalThis : global || self, factory(global.jtpp = {}));\n    })(exports, function(exports2) {\n      \"use strict\";\n      function tokenToString(token) {\n        if (token.text !== void 0 && token.text !== \"\") {\n          return `'${token.type}' with value '${token.text}'`;\n        } else {\n          return `'${token.type}'`;\n        }\n      }\n      __name(tokenToString, \"tokenToString\");\n      const _NoParsletFoundError = class _NoParsletFoundError extends Error {\n        constructor(token) {\n          super(`No parslet found for token: ${tokenToString(token)}`);\n          this.token = token;\n          Object.setPrototypeOf(this, _NoParsletFoundError.prototype);\n        }\n        getToken() {\n          return this.token;\n        }\n      };\n      __name(_NoParsletFoundError, \"NoParsletFoundError\");\n      let NoParsletFoundError = _NoParsletFoundError;\n      const _EarlyEndOfParseError = class _EarlyEndOfParseError extends Error {\n        constructor(token) {\n          super(`The parsing ended early. The next token was: ${tokenToString(token)}`);\n          this.token = token;\n          Object.setPrototypeOf(this, _EarlyEndOfParseError.prototype);\n        }\n        getToken() {\n          return this.token;\n        }\n      };\n      __name(_EarlyEndOfParseError, \"EarlyEndOfParseError\");\n      let EarlyEndOfParseError = _EarlyEndOfParseError;\n      const _UnexpectedTypeError = class _UnexpectedTypeError extends Error {\n        constructor(result, message) {\n          let error = `Unexpected type: '${result.type}'.`;\n          if (message !== void 0) {\n            error += ` Message: ${message}`;\n          }\n          super(error);\n          Object.setPrototypeOf(this, _UnexpectedTypeError.prototype);\n        }\n      };\n      __name(_UnexpectedTypeError, \"UnexpectedTypeError\");\n      let UnexpectedTypeError = _UnexpectedTypeError;\n      function makePunctuationRule(type) {\n        return (text) => {\n          if (text.startsWith(type)) {\n            return { type, text: type };\n          } else {\n            return null;\n          }\n        };\n      }\n      __name(makePunctuationRule, \"makePunctuationRule\");\n      function getQuoted(text) {\n        let position = 0;\n        let char;\n        const mark = text[0];\n        let escaped = false;\n        if (mark !== \"'\" && mark !== '\"') {\n          return null;\n        }\n        while (position < text.length) {\n          position++;\n          char = text[position];\n          if (!escaped && char === mark) {\n            position++;\n            break;\n          }\n          escaped = !escaped && char === \"\\\\\";\n        }\n        if (char !== mark) {\n          throw new Error(\"Unterminated String\");\n        }\n        return text.slice(0, position);\n      }\n      __name(getQuoted, \"getQuoted\");\n      const identifierStartRegex = new RegExp(\"[$_\\\\p{ID_Start}]|\\\\\\\\u\\\\p{Hex_Digit}{4}|\\\\\\\\u\\\\{0*(?:\\\\p{Hex_Digit}{1,5}|10\\\\p{Hex_Digit}{4})\\\\}\", \"u\");\n      const identifierContinueRegex = new RegExp(\"[$\\\\-\\\\p{ID_Continue}\\\\u200C\\\\u200D]|\\\\\\\\u\\\\p{Hex_Digit}{4}|\\\\\\\\u\\\\{0*(?:\\\\p{Hex_Digit}{1,5}|10\\\\p{Hex_Digit}{4})\\\\}\", \"u\");\n      function getIdentifier(text) {\n        let char = text[0];\n        if (!identifierStartRegex.test(char)) {\n          return null;\n        }\n        let position = 1;\n        do {\n          char = text[position];\n          if (!identifierContinueRegex.test(char)) {\n            break;\n          }\n          position++;\n        } while (position < text.length);\n        return text.slice(0, position);\n      }\n      __name(getIdentifier, \"getIdentifier\");\n      const numberRegex = /^(NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity))/;\n      function getNumber(text) {\n        var _a, _b;\n        return (_b = (_a = numberRegex.exec(text)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;\n      }\n      __name(getNumber, \"getNumber\");\n      const identifierRule = /* @__PURE__ */ __name((text) => {\n        const value = getIdentifier(text);\n        if (value == null) {\n          return null;\n        }\n        return {\n          type: \"Identifier\",\n          text: value\n        };\n      }, \"identifierRule\");\n      function makeKeyWordRule(type) {\n        return (text) => {\n          if (!text.startsWith(type)) {\n            return null;\n          }\n          const prepends = text[type.length];\n          if (prepends !== void 0 && identifierContinueRegex.test(prepends)) {\n            return null;\n          }\n          return {\n            type,\n            text: type\n          };\n        };\n      }\n      __name(makeKeyWordRule, \"makeKeyWordRule\");\n      const stringValueRule = /* @__PURE__ */ __name((text) => {\n        const value = getQuoted(text);\n        if (value == null) {\n          return null;\n        }\n        return {\n          type: \"StringValue\",\n          text: value\n        };\n      }, \"stringValueRule\");\n      const eofRule = /* @__PURE__ */ __name((text) => {\n        if (text.length > 0) {\n          return null;\n        }\n        return {\n          type: \"EOF\",\n          text: \"\"\n        };\n      }, \"eofRule\");\n      const numberRule = /* @__PURE__ */ __name((text) => {\n        const value = getNumber(text);\n        if (value === null) {\n          return null;\n        }\n        return {\n          type: \"Number\",\n          text: value\n        };\n      }, \"numberRule\");\n      const rules = [\n        eofRule,\n        makePunctuationRule(\"=>\"),\n        makePunctuationRule(\"(\"),\n        makePunctuationRule(\")\"),\n        makePunctuationRule(\"{\"),\n        makePunctuationRule(\"}\"),\n        makePunctuationRule(\"[\"),\n        makePunctuationRule(\"]\"),\n        makePunctuationRule(\"|\"),\n        makePunctuationRule(\"&\"),\n        makePunctuationRule(\"<\"),\n        makePunctuationRule(\">\"),\n        makePunctuationRule(\",\"),\n        makePunctuationRule(\";\"),\n        makePunctuationRule(\"*\"),\n        makePunctuationRule(\"?\"),\n        makePunctuationRule(\"!\"),\n        makePunctuationRule(\"=\"),\n        makePunctuationRule(\":\"),\n        makePunctuationRule(\"...\"),\n        makePunctuationRule(\".\"),\n        makePunctuationRule(\"#\"),\n        makePunctuationRule(\"~\"),\n        makePunctuationRule(\"/\"),\n        makePunctuationRule(\"@\"),\n        makeKeyWordRule(\"undefined\"),\n        makeKeyWordRule(\"null\"),\n        makeKeyWordRule(\"function\"),\n        makeKeyWordRule(\"this\"),\n        makeKeyWordRule(\"new\"),\n        makeKeyWordRule(\"module\"),\n        makeKeyWordRule(\"event\"),\n        makeKeyWordRule(\"extends\"),\n        makeKeyWordRule(\"external\"),\n        makeKeyWordRule(\"infer\"),\n        makeKeyWordRule(\"typeof\"),\n        makeKeyWordRule(\"keyof\"),\n        makeKeyWordRule(\"readonly\"),\n        makeKeyWordRule(\"import\"),\n        makeKeyWordRule(\"is\"),\n        makeKeyWordRule(\"in\"),\n        makeKeyWordRule(\"asserts\"),\n        numberRule,\n        identifierRule,\n        stringValueRule\n      ];\n      const breakingWhitespaceRegex = /^\\s*\\n\\s*/;\n      const _Lexer = class _Lexer {\n        static create(text) {\n          const current = this.read(text);\n          text = current.text;\n          const next = this.read(text);\n          text = next.text;\n          return new _Lexer(text, void 0, current.token, next.token);\n        }\n        constructor(text, previous, current, next) {\n          this.text = \"\";\n          this.text = text;\n          this.previous = previous;\n          this.current = current;\n          this.next = next;\n        }\n        static read(text, startOfLine = false) {\n          startOfLine = startOfLine || breakingWhitespaceRegex.test(text);\n          text = text.trim();\n          for (const rule of rules) {\n            const partial = rule(text);\n            if (partial !== null) {\n              const token = Object.assign(Object.assign({}, partial), { startOfLine });\n              text = text.slice(token.text.length);\n              return { text, token };\n            }\n          }\n          throw new Error(\"Unexpected Token \" + text);\n        }\n        advance() {\n          const next = _Lexer.read(this.text);\n          return new _Lexer(next.text, this.current, this.next, next.token);\n        }\n      };\n      __name(_Lexer, \"Lexer\");\n      let Lexer = _Lexer;\n      function assertRootResult(result) {\n        if (result === void 0) {\n          throw new Error(\"Unexpected undefined\");\n        }\n        if (result.type === \"JsdocTypeKeyValue\" || result.type === \"JsdocTypeParameterList\" || result.type === \"JsdocTypeProperty\" || result.type === \"JsdocTypeReadonlyProperty\" || result.type === \"JsdocTypeObjectField\" || result.type === \"JsdocTypeJsdocObjectField\" || result.type === \"JsdocTypeIndexSignature\" || result.type === \"JsdocTypeMappedType\" || result.type === \"JsdocTypeTypeParameter\") {\n          throw new UnexpectedTypeError(result);\n        }\n        return result;\n      }\n      __name(assertRootResult, \"assertRootResult\");\n      function assertPlainKeyValueOrRootResult(result) {\n        if (result.type === \"JsdocTypeKeyValue\") {\n          return assertPlainKeyValueResult(result);\n        }\n        return assertRootResult(result);\n      }\n      __name(assertPlainKeyValueOrRootResult, \"assertPlainKeyValueOrRootResult\");\n      function assertPlainKeyValueOrNameResult(result) {\n        if (result.type === \"JsdocTypeName\") {\n          return result;\n        }\n        return assertPlainKeyValueResult(result);\n      }\n      __name(assertPlainKeyValueOrNameResult, \"assertPlainKeyValueOrNameResult\");\n      function assertPlainKeyValueResult(result) {\n        if (result.type !== \"JsdocTypeKeyValue\") {\n          throw new UnexpectedTypeError(result);\n        }\n        return result;\n      }\n      __name(assertPlainKeyValueResult, \"assertPlainKeyValueResult\");\n      function assertNumberOrVariadicNameResult(result) {\n        var _a;\n        if (result.type === \"JsdocTypeVariadic\") {\n          if (((_a = result.element) === null || _a === void 0 ? void 0 : _a.type) === \"JsdocTypeName\") {\n            return result;\n          }\n          throw new UnexpectedTypeError(result);\n        }\n        if (result.type !== \"JsdocTypeNumber\" && result.type !== \"JsdocTypeName\") {\n          throw new UnexpectedTypeError(result);\n        }\n        return result;\n      }\n      __name(assertNumberOrVariadicNameResult, \"assertNumberOrVariadicNameResult\");\n      function assertArrayOrTupleResult(result) {\n        if (result.type === \"JsdocTypeTuple\") {\n          return result;\n        }\n        if (result.type === \"JsdocTypeGeneric\" && result.meta.brackets === \"square\") {\n          return result;\n        }\n        throw new UnexpectedTypeError(result);\n      }\n      __name(assertArrayOrTupleResult, \"assertArrayOrTupleResult\");\n      function isSquaredProperty(result) {\n        return result.type === \"JsdocTypeIndexSignature\" || result.type === \"JsdocTypeMappedType\";\n      }\n      __name(isSquaredProperty, \"isSquaredProperty\");\n      var Precedence;\n      (function(Precedence2) {\n        Precedence2[Precedence2[\"ALL\"] = 0] = \"ALL\";\n        Precedence2[Precedence2[\"PARAMETER_LIST\"] = 1] = \"PARAMETER_LIST\";\n        Precedence2[Precedence2[\"OBJECT\"] = 2] = \"OBJECT\";\n        Precedence2[Precedence2[\"KEY_VALUE\"] = 3] = \"KEY_VALUE\";\n        Precedence2[Precedence2[\"INDEX_BRACKETS\"] = 4] = \"INDEX_BRACKETS\";\n        Precedence2[Precedence2[\"UNION\"] = 5] = \"UNION\";\n        Precedence2[Precedence2[\"INTERSECTION\"] = 6] = \"INTERSECTION\";\n        Precedence2[Precedence2[\"PREFIX\"] = 7] = \"PREFIX\";\n        Precedence2[Precedence2[\"INFIX\"] = 8] = \"INFIX\";\n        Precedence2[Precedence2[\"TUPLE\"] = 9] = \"TUPLE\";\n        Precedence2[Precedence2[\"SYMBOL\"] = 10] = \"SYMBOL\";\n        Precedence2[Precedence2[\"OPTIONAL\"] = 11] = \"OPTIONAL\";\n        Precedence2[Precedence2[\"NULLABLE\"] = 12] = \"NULLABLE\";\n        Precedence2[Precedence2[\"KEY_OF_TYPE_OF\"] = 13] = \"KEY_OF_TYPE_OF\";\n        Precedence2[Precedence2[\"FUNCTION\"] = 14] = \"FUNCTION\";\n        Precedence2[Precedence2[\"ARROW\"] = 15] = \"ARROW\";\n        Precedence2[Precedence2[\"ARRAY_BRACKETS\"] = 16] = \"ARRAY_BRACKETS\";\n        Precedence2[Precedence2[\"GENERIC\"] = 17] = \"GENERIC\";\n        Precedence2[Precedence2[\"NAME_PATH\"] = 18] = \"NAME_PATH\";\n        Precedence2[Precedence2[\"PARENTHESIS\"] = 19] = \"PARENTHESIS\";\n        Precedence2[Precedence2[\"SPECIAL_TYPES\"] = 20] = \"SPECIAL_TYPES\";\n      })(Precedence || (Precedence = {}));\n      const _Parser = class _Parser {\n        constructor(grammar, textOrLexer, baseParser) {\n          this.grammar = grammar;\n          if (typeof textOrLexer === \"string\") {\n            this._lexer = Lexer.create(textOrLexer);\n          } else {\n            this._lexer = textOrLexer;\n          }\n          this.baseParser = baseParser;\n        }\n        get lexer() {\n          return this._lexer;\n        }\n        /**\n         * Parses a given string and throws an error if the parse ended before the end of the string.\n         */\n        parse() {\n          const result = this.parseType(Precedence.ALL);\n          if (this.lexer.current.type !== \"EOF\") {\n            throw new EarlyEndOfParseError(this.lexer.current);\n          }\n          return result;\n        }\n        /**\n         * Parses with the current lexer and asserts that the result is a {@link RootResult}.\n         */\n        parseType(precedence) {\n          return assertRootResult(this.parseIntermediateType(precedence));\n        }\n        /**\n         * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues\n         * to parse the state in the infix step.\n         */\n        parseIntermediateType(precedence) {\n          const result = this.tryParslets(null, precedence);\n          if (result === null) {\n            throw new NoParsletFoundError(this.lexer.current);\n          }\n          return this.parseInfixIntermediateType(result, precedence);\n        }\n        /**\n         * In the infix parsing step the parser continues to parse the current state with all parslets until none returns\n         * a result.\n         */\n        parseInfixIntermediateType(left, precedence) {\n          let result = this.tryParslets(left, precedence);\n          while (result !== null) {\n            left = result;\n            result = this.tryParslets(left, precedence);\n          }\n          return left;\n        }\n        /**\n         * Tries to parse the current state with all parslets in the grammar and returns the first non null result.\n         */\n        tryParslets(left, precedence) {\n          for (const parslet of this.grammar) {\n            const result = parslet(this, precedence, left);\n            if (result !== null) {\n              return result;\n            }\n          }\n          return null;\n        }\n        /**\n         * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was\n         * advanced.\n         */\n        consume(types) {\n          if (!Array.isArray(types)) {\n            types = [types];\n          }\n          if (types.includes(this.lexer.current.type)) {\n            this._lexer = this.lexer.advance();\n            return true;\n          } else {\n            return false;\n          }\n        }\n        acceptLexerState(parser) {\n          this._lexer = parser.lexer;\n        }\n      };\n      __name(_Parser, \"Parser\");\n      let Parser = _Parser;\n      function isQuestionMarkUnknownType(next) {\n        return next === \"}\" || next === \"EOF\" || next === \"|\" || next === \",\" || next === \")\" || next === \">\";\n      }\n      __name(isQuestionMarkUnknownType, \"isQuestionMarkUnknownType\");\n      const nullableParslet = /* @__PURE__ */ __name((parser, precedence, left) => {\n        const type = parser.lexer.current.type;\n        const next = parser.lexer.next.type;\n        const accept = left == null && type === \"?\" && !isQuestionMarkUnknownType(next) || left != null && type === \"?\";\n        if (!accept) {\n          return null;\n        }\n        parser.consume(\"?\");\n        if (left == null) {\n          return {\n            type: \"JsdocTypeNullable\",\n            element: parser.parseType(Precedence.NULLABLE),\n            meta: {\n              position: \"prefix\"\n            }\n          };\n        } else {\n          return {\n            type: \"JsdocTypeNullable\",\n            element: assertRootResult(left),\n            meta: {\n              position: \"suffix\"\n            }\n          };\n        }\n      }, \"nullableParslet\");\n      function composeParslet(options) {\n        const parslet = /* @__PURE__ */ __name((parser, curPrecedence, left) => {\n          const type = parser.lexer.current.type;\n          const next = parser.lexer.next.type;\n          if (left === null) {\n            if (\"parsePrefix\" in options) {\n              if (options.accept(type, next)) {\n                return options.parsePrefix(parser);\n              }\n            }\n          } else {\n            if (\"parseInfix\" in options) {\n              if (options.precedence > curPrecedence && options.accept(type, next)) {\n                return options.parseInfix(parser, left);\n              }\n            }\n          }\n          return null;\n        }, \"parslet\");\n        Object.defineProperty(parslet, \"name\", {\n          value: options.name\n        });\n        return parslet;\n      }\n      __name(composeParslet, \"composeParslet\");\n      const optionalParslet = composeParslet({\n        name: \"optionalParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"=\", \"accept\"),\n        precedence: Precedence.OPTIONAL,\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          parser.consume(\"=\");\n          return {\n            type: \"JsdocTypeOptional\",\n            element: parser.parseType(Precedence.OPTIONAL),\n            meta: {\n              position: \"prefix\"\n            }\n          };\n        }, \"parsePrefix\"),\n        parseInfix: /* @__PURE__ */ __name((parser, left) => {\n          parser.consume(\"=\");\n          return {\n            type: \"JsdocTypeOptional\",\n            element: assertRootResult(left),\n            meta: {\n              position: \"suffix\"\n            }\n          };\n        }, \"parseInfix\")\n      });\n      const numberParslet = composeParslet({\n        name: \"numberParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"Number\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          const value = parseFloat(parser.lexer.current.text);\n          parser.consume(\"Number\");\n          return {\n            type: \"JsdocTypeNumber\",\n            value\n          };\n        }, \"parsePrefix\")\n      });\n      const parenthesisParslet = composeParslet({\n        name: \"parenthesisParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"(\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          parser.consume(\"(\");\n          if (parser.consume(\")\")) {\n            return {\n              type: \"JsdocTypeParameterList\",\n              elements: []\n            };\n          }\n          const result = parser.parseIntermediateType(Precedence.ALL);\n          if (!parser.consume(\")\")) {\n            throw new Error(\"Unterminated parenthesis\");\n          }\n          if (result.type === \"JsdocTypeParameterList\") {\n            return result;\n          } else if (result.type === \"JsdocTypeKeyValue\") {\n            return {\n              type: \"JsdocTypeParameterList\",\n              elements: [result]\n            };\n          }\n          return {\n            type: \"JsdocTypeParenthesis\",\n            element: assertRootResult(result)\n          };\n        }, \"parsePrefix\")\n      });\n      const specialTypesParslet = composeParslet({\n        name: \"specialTypesParslet\",\n        accept: /* @__PURE__ */ __name((type, next) => type === \"?\" && isQuestionMarkUnknownType(next) || type === \"null\" || type === \"undefined\" || type === \"*\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          if (parser.consume(\"null\")) {\n            return {\n              type: \"JsdocTypeNull\"\n            };\n          }\n          if (parser.consume(\"undefined\")) {\n            return {\n              type: \"JsdocTypeUndefined\"\n            };\n          }\n          if (parser.consume(\"*\")) {\n            return {\n              type: \"JsdocTypeAny\"\n            };\n          }\n          if (parser.consume(\"?\")) {\n            return {\n              type: \"JsdocTypeUnknown\"\n            };\n          }\n          throw new Error(\"Unacceptable token: \" + parser.lexer.current.text);\n        }, \"parsePrefix\")\n      });\n      const notNullableParslet = composeParslet({\n        name: \"notNullableParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"!\", \"accept\"),\n        precedence: Precedence.NULLABLE,\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          parser.consume(\"!\");\n          return {\n            type: \"JsdocTypeNotNullable\",\n            element: parser.parseType(Precedence.NULLABLE),\n            meta: {\n              position: \"prefix\"\n            }\n          };\n        }, \"parsePrefix\"),\n        parseInfix: /* @__PURE__ */ __name((parser, left) => {\n          parser.consume(\"!\");\n          return {\n            type: \"JsdocTypeNotNullable\",\n            element: assertRootResult(left),\n            meta: {\n              position: \"suffix\"\n            }\n          };\n        }, \"parseInfix\")\n      });\n      function createParameterListParslet({ allowTrailingComma }) {\n        return composeParslet({\n          name: \"parameterListParslet\",\n          accept: /* @__PURE__ */ __name((type) => type === \",\", \"accept\"),\n          precedence: Precedence.PARAMETER_LIST,\n          parseInfix: /* @__PURE__ */ __name((parser, left) => {\n            const elements = [\n              assertPlainKeyValueOrRootResult(left)\n            ];\n            parser.consume(\",\");\n            do {\n              try {\n                const next = parser.parseIntermediateType(Precedence.PARAMETER_LIST);\n                elements.push(assertPlainKeyValueOrRootResult(next));\n              } catch (e) {\n                if (e instanceof NoParsletFoundError) {\n                  break;\n                } else {\n                  throw e;\n                }\n              }\n            } while (parser.consume(\",\"));\n            if (elements.length > 0 && elements.slice(0, -1).some((e) => e.type === \"JsdocTypeVariadic\")) {\n              throw new Error(\"Only the last parameter may be a rest parameter\");\n            }\n            return {\n              type: \"JsdocTypeParameterList\",\n              elements\n            };\n          }, \"parseInfix\")\n        });\n      }\n      __name(createParameterListParslet, \"createParameterListParslet\");\n      const genericParslet = composeParslet({\n        name: \"genericParslet\",\n        accept: /* @__PURE__ */ __name((type, next) => type === \"<\" || type === \".\" && next === \"<\", \"accept\"),\n        precedence: Precedence.GENERIC,\n        parseInfix: /* @__PURE__ */ __name((parser, left) => {\n          const dot = parser.consume(\".\");\n          parser.consume(\"<\");\n          const objects = [];\n          let infer = false;\n          if (parser.consume(\"infer\")) {\n            infer = true;\n            const left2 = parser.parseIntermediateType(Precedence.SYMBOL);\n            if (left2.type !== \"JsdocTypeName\") {\n              throw new UnexpectedTypeError(left2, \"A typescript asserts always has to have a name on the left side.\");\n            }\n            objects.push(left2);\n          } else {\n            do {\n              objects.push(parser.parseType(Precedence.PARAMETER_LIST));\n            } while (parser.consume(\",\"));\n          }\n          if (!parser.consume(\">\")) {\n            throw new Error(\"Unterminated generic parameter list\");\n          }\n          return Object.assign(Object.assign({ type: \"JsdocTypeGeneric\", left: assertRootResult(left), elements: objects }, infer ? { infer: true } : {}), { meta: {\n            brackets: \"angle\",\n            dot\n          } });\n        }, \"parseInfix\")\n      });\n      const unionParslet = composeParslet({\n        name: \"unionParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"|\", \"accept\"),\n        precedence: Precedence.UNION,\n        parseInfix: /* @__PURE__ */ __name((parser, left) => {\n          parser.consume(\"|\");\n          const elements = [];\n          do {\n            elements.push(parser.parseType(Precedence.UNION));\n          } while (parser.consume(\"|\"));\n          return {\n            type: \"JsdocTypeUnion\",\n            elements: [assertRootResult(left), ...elements]\n          };\n        }, \"parseInfix\")\n      });\n      const baseGrammar = [\n        nullableParslet,\n        optionalParslet,\n        numberParslet,\n        parenthesisParslet,\n        specialTypesParslet,\n        notNullableParslet,\n        createParameterListParslet({\n          allowTrailingComma: true\n        }),\n        genericParslet,\n        unionParslet,\n        optionalParslet\n      ];\n      function createNamePathParslet({ allowSquareBracketsOnAnyType, allowJsdocNamePaths, pathGrammar: pathGrammar2 }) {\n        return /* @__PURE__ */ __name(function namePathParslet(parser, precedence, left) {\n          if (left == null || precedence >= Precedence.NAME_PATH) {\n            return null;\n          }\n          const type = parser.lexer.current.type;\n          const next = parser.lexer.next.type;\n          const accept = type === \".\" && next !== \"<\" || type === \"[\" && (allowSquareBracketsOnAnyType || left.type === \"JsdocTypeName\") || allowJsdocNamePaths && (type === \"~\" || type === \"#\");\n          if (!accept) {\n            return null;\n          }\n          let pathType;\n          let brackets = false;\n          if (parser.consume(\".\")) {\n            pathType = \"property\";\n          } else if (parser.consume(\"[\")) {\n            pathType = \"property-brackets\";\n            brackets = true;\n          } else if (parser.consume(\"~\")) {\n            pathType = \"inner\";\n          } else {\n            parser.consume(\"#\");\n            pathType = \"instance\";\n          }\n          const pathParser = pathGrammar2 !== null ? new Parser(pathGrammar2, parser.lexer, parser) : parser;\n          const parsed = pathParser.parseIntermediateType(Precedence.NAME_PATH);\n          parser.acceptLexerState(pathParser);\n          let right;\n          switch (parsed.type) {\n            case \"JsdocTypeName\":\n              right = {\n                type: \"JsdocTypeProperty\",\n                value: parsed.value,\n                meta: {\n                  quote: void 0\n                }\n              };\n              break;\n            case \"JsdocTypeNumber\":\n              right = {\n                type: \"JsdocTypeProperty\",\n                value: parsed.value.toString(10),\n                meta: {\n                  quote: void 0\n                }\n              };\n              break;\n            case \"JsdocTypeStringValue\":\n              right = {\n                type: \"JsdocTypeProperty\",\n                value: parsed.value,\n                meta: {\n                  quote: parsed.meta.quote\n                }\n              };\n              break;\n            case \"JsdocTypeSpecialNamePath\":\n              if (parsed.specialType === \"event\") {\n                right = parsed;\n              } else {\n                throw new UnexpectedTypeError(parsed, \"Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'\");\n              }\n              break;\n            default:\n              throw new UnexpectedTypeError(parsed, \"Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'\");\n          }\n          if (brackets && !parser.consume(\"]\")) {\n            const token = parser.lexer.current;\n            throw new Error(`Unterminated square brackets. Next token is '${token.type}' with text '${token.text}'`);\n          }\n          return {\n            type: \"JsdocTypeNamePath\",\n            left: assertRootResult(left),\n            right,\n            pathType\n          };\n        }, \"namePathParslet\");\n      }\n      __name(createNamePathParslet, \"createNamePathParslet\");\n      function createNameParslet({ allowedAdditionalTokens }) {\n        return composeParslet({\n          name: \"nameParslet\",\n          accept: /* @__PURE__ */ __name((type) => type === \"Identifier\" || type === \"this\" || type === \"new\" || allowedAdditionalTokens.includes(type), \"accept\"),\n          parsePrefix: /* @__PURE__ */ __name((parser) => {\n            const { type, text } = parser.lexer.current;\n            parser.consume(type);\n            return {\n              type: \"JsdocTypeName\",\n              value: text\n            };\n          }, \"parsePrefix\")\n        });\n      }\n      __name(createNameParslet, \"createNameParslet\");\n      const stringValueParslet = composeParslet({\n        name: \"stringValueParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"StringValue\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          const text = parser.lexer.current.text;\n          parser.consume(\"StringValue\");\n          return {\n            type: \"JsdocTypeStringValue\",\n            value: text.slice(1, -1),\n            meta: {\n              quote: text[0] === \"'\" ? \"single\" : \"double\"\n            }\n          };\n        }, \"parsePrefix\")\n      });\n      function createSpecialNamePathParslet({ pathGrammar: pathGrammar2, allowedTypes }) {\n        return composeParslet({\n          name: \"specialNamePathParslet\",\n          accept: /* @__PURE__ */ __name((type) => allowedTypes.includes(type), \"accept\"),\n          parsePrefix: /* @__PURE__ */ __name((parser) => {\n            const type = parser.lexer.current.type;\n            parser.consume(type);\n            if (!parser.consume(\":\")) {\n              return {\n                type: \"JsdocTypeName\",\n                value: type\n              };\n            }\n            let result;\n            let token = parser.lexer.current;\n            if (parser.consume(\"StringValue\")) {\n              result = {\n                type: \"JsdocTypeSpecialNamePath\",\n                value: token.text.slice(1, -1),\n                specialType: type,\n                meta: {\n                  quote: token.text[0] === \"'\" ? \"single\" : \"double\"\n                }\n              };\n            } else {\n              let value = \"\";\n              const allowed = [\"Identifier\", \"@\", \"/\"];\n              while (allowed.some((type2) => parser.consume(type2))) {\n                value += token.text;\n                token = parser.lexer.current;\n              }\n              result = {\n                type: \"JsdocTypeSpecialNamePath\",\n                value,\n                specialType: type,\n                meta: {\n                  quote: void 0\n                }\n              };\n            }\n            const moduleParser = new Parser(pathGrammar2, parser.lexer, parser);\n            const moduleResult = moduleParser.parseInfixIntermediateType(result, Precedence.ALL);\n            parser.acceptLexerState(moduleParser);\n            return assertRootResult(moduleResult);\n          }, \"parsePrefix\")\n        });\n      }\n      __name(createSpecialNamePathParslet, \"createSpecialNamePathParslet\");\n      const basePathGrammar = [\n        createNameParslet({\n          allowedAdditionalTokens: [\"external\", \"module\"]\n        }),\n        stringValueParslet,\n        numberParslet,\n        createNamePathParslet({\n          allowSquareBracketsOnAnyType: false,\n          allowJsdocNamePaths: true,\n          pathGrammar: null\n        })\n      ];\n      const pathGrammar = [\n        ...basePathGrammar,\n        createSpecialNamePathParslet({\n          allowedTypes: [\"event\"],\n          pathGrammar: basePathGrammar\n        })\n      ];\n      function getParameters(value) {\n        let parameters;\n        if (value.type === \"JsdocTypeParameterList\") {\n          parameters = value.elements;\n        } else if (value.type === \"JsdocTypeParenthesis\") {\n          parameters = [value.element];\n        } else {\n          throw new UnexpectedTypeError(value);\n        }\n        return parameters.map((p) => assertPlainKeyValueOrRootResult(p));\n      }\n      __name(getParameters, \"getParameters\");\n      function getUnnamedParameters(value) {\n        const parameters = getParameters(value);\n        if (parameters.some((p) => p.type === \"JsdocTypeKeyValue\")) {\n          throw new Error(\"No parameter should be named\");\n        }\n        return parameters;\n      }\n      __name(getUnnamedParameters, \"getUnnamedParameters\");\n      function createFunctionParslet({ allowNamedParameters, allowNoReturnType, allowWithoutParenthesis, allowNewAsFunctionKeyword }) {\n        return composeParslet({\n          name: \"functionParslet\",\n          accept: /* @__PURE__ */ __name((type, next) => type === \"function\" || allowNewAsFunctionKeyword && type === \"new\" && next === \"(\", \"accept\"),\n          parsePrefix: /* @__PURE__ */ __name((parser) => {\n            const newKeyword = parser.consume(\"new\");\n            parser.consume(\"function\");\n            const hasParenthesis = parser.lexer.current.type === \"(\";\n            if (!hasParenthesis) {\n              if (!allowWithoutParenthesis) {\n                throw new Error(\"function is missing parameter list\");\n              }\n              return {\n                type: \"JsdocTypeName\",\n                value: \"function\"\n              };\n            }\n            let result = {\n              type: \"JsdocTypeFunction\",\n              parameters: [],\n              arrow: false,\n              constructor: newKeyword,\n              parenthesis: hasParenthesis\n            };\n            const value = parser.parseIntermediateType(Precedence.FUNCTION);\n            if (allowNamedParameters === void 0) {\n              result.parameters = getUnnamedParameters(value);\n            } else if (newKeyword && value.type === \"JsdocTypeFunction\" && value.arrow) {\n              result = value;\n              result.constructor = true;\n              return result;\n            } else {\n              result.parameters = getParameters(value);\n              for (const p of result.parameters) {\n                if (p.type === \"JsdocTypeKeyValue\" && !allowNamedParameters.includes(p.key)) {\n                  throw new Error(`only allowed named parameters are ${allowNamedParameters.join(\", \")} but got ${p.type}`);\n                }\n              }\n            }\n            if (parser.consume(\":\")) {\n              result.returnType = parser.parseType(Precedence.PREFIX);\n            } else {\n              if (!allowNoReturnType) {\n                throw new Error(\"function is missing return type\");\n              }\n            }\n            return result;\n          }, \"parsePrefix\")\n        });\n      }\n      __name(createFunctionParslet, \"createFunctionParslet\");\n      function createVariadicParslet({ allowPostfix, allowEnclosingBrackets }) {\n        return composeParslet({\n          name: \"variadicParslet\",\n          accept: /* @__PURE__ */ __name((type) => type === \"...\", \"accept\"),\n          precedence: Precedence.PREFIX,\n          parsePrefix: /* @__PURE__ */ __name((parser) => {\n            parser.consume(\"...\");\n            const brackets = allowEnclosingBrackets && parser.consume(\"[\");\n            try {\n              const element = parser.parseType(Precedence.PREFIX);\n              if (brackets && !parser.consume(\"]\")) {\n                throw new Error(\"Unterminated variadic type. Missing ']'\");\n              }\n              return {\n                type: \"JsdocTypeVariadic\",\n                element: assertRootResult(element),\n                meta: {\n                  position: \"prefix\",\n                  squareBrackets: brackets\n                }\n              };\n            } catch (e) {\n              if (e instanceof NoParsletFoundError) {\n                if (brackets) {\n                  throw new Error(\"Empty square brackets for variadic are not allowed.\");\n                }\n                return {\n                  type: \"JsdocTypeVariadic\",\n                  meta: {\n                    position: void 0,\n                    squareBrackets: false\n                  }\n                };\n              } else {\n                throw e;\n              }\n            }\n          }, \"parsePrefix\"),\n          parseInfix: allowPostfix ? (parser, left) => {\n            parser.consume(\"...\");\n            return {\n              type: \"JsdocTypeVariadic\",\n              element: assertRootResult(left),\n              meta: {\n                position: \"suffix\",\n                squareBrackets: false\n              }\n            };\n          } : void 0\n        });\n      }\n      __name(createVariadicParslet, \"createVariadicParslet\");\n      const symbolParslet = composeParslet({\n        name: \"symbolParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"(\", \"accept\"),\n        precedence: Precedence.SYMBOL,\n        parseInfix: /* @__PURE__ */ __name((parser, left) => {\n          if (left.type !== \"JsdocTypeName\") {\n            throw new Error(\"Symbol expects a name on the left side. (Reacting on '(')\");\n          }\n          parser.consume(\"(\");\n          const result = {\n            type: \"JsdocTypeSymbol\",\n            value: left.value\n          };\n          if (!parser.consume(\")\")) {\n            const next = parser.parseIntermediateType(Precedence.SYMBOL);\n            result.element = assertNumberOrVariadicNameResult(next);\n            if (!parser.consume(\")\")) {\n              throw new Error(\"Symbol does not end after value\");\n            }\n          }\n          return result;\n        }, \"parseInfix\")\n      });\n      const arrayBracketsParslet = composeParslet({\n        name: \"arrayBracketsParslet\",\n        precedence: Precedence.ARRAY_BRACKETS,\n        accept: /* @__PURE__ */ __name((type, next) => type === \"[\" && next === \"]\", \"accept\"),\n        parseInfix: /* @__PURE__ */ __name((parser, left) => {\n          parser.consume(\"[\");\n          parser.consume(\"]\");\n          return {\n            type: \"JsdocTypeGeneric\",\n            left: {\n              type: \"JsdocTypeName\",\n              value: \"Array\"\n            },\n            elements: [\n              assertRootResult(left)\n            ],\n            meta: {\n              brackets: \"square\",\n              dot: false\n            }\n          };\n        }, \"parseInfix\")\n      });\n      function createObjectParslet({ objectFieldGrammar: objectFieldGrammar2, allowKeyTypes }) {\n        return composeParslet({\n          name: \"objectParslet\",\n          accept: /* @__PURE__ */ __name((type) => type === \"{\", \"accept\"),\n          parsePrefix: /* @__PURE__ */ __name((parser) => {\n            parser.consume(\"{\");\n            const result = {\n              type: \"JsdocTypeObject\",\n              meta: {\n                separator: \"comma\"\n              },\n              elements: []\n            };\n            if (!parser.consume(\"}\")) {\n              let separator;\n              const fieldParser = new Parser(objectFieldGrammar2, parser.lexer, parser);\n              while (true) {\n                fieldParser.acceptLexerState(parser);\n                let field = fieldParser.parseIntermediateType(Precedence.OBJECT);\n                parser.acceptLexerState(fieldParser);\n                if (field === void 0 && allowKeyTypes) {\n                  field = parser.parseIntermediateType(Precedence.OBJECT);\n                }\n                let optional = false;\n                if (field.type === \"JsdocTypeNullable\") {\n                  optional = true;\n                  field = field.element;\n                }\n                if (field.type === \"JsdocTypeNumber\" || field.type === \"JsdocTypeName\" || field.type === \"JsdocTypeStringValue\") {\n                  let quote2;\n                  if (field.type === \"JsdocTypeStringValue\") {\n                    quote2 = field.meta.quote;\n                  }\n                  result.elements.push({\n                    type: \"JsdocTypeObjectField\",\n                    key: field.value.toString(),\n                    right: void 0,\n                    optional,\n                    readonly: false,\n                    meta: {\n                      quote: quote2\n                    }\n                  });\n                } else if (field.type === \"JsdocTypeObjectField\" || field.type === \"JsdocTypeJsdocObjectField\") {\n                  result.elements.push(field);\n                } else {\n                  throw new UnexpectedTypeError(field);\n                }\n                if (parser.lexer.current.startOfLine) {\n                  separator = \"linebreak\";\n                  parser.consume(\",\") || parser.consume(\";\");\n                } else if (parser.consume(\",\")) {\n                  separator = \"comma\";\n                } else if (parser.consume(\";\")) {\n                  separator = \"semicolon\";\n                } else {\n                  break;\n                }\n                const type = parser.lexer.current.type;\n                if (type === \"}\") {\n                  break;\n                }\n              }\n              result.meta.separator = separator !== null && separator !== void 0 ? separator : \"comma\";\n              if (separator === \"linebreak\") {\n                result.meta.propertyIndent = \"  \";\n              }\n              if (!parser.consume(\"}\")) {\n                throw new Error(\"Unterminated record type. Missing '}'\");\n              }\n            }\n            return result;\n          }, \"parsePrefix\")\n        });\n      }\n      __name(createObjectParslet, \"createObjectParslet\");\n      function createObjectFieldParslet({ allowSquaredProperties, allowKeyTypes, allowReadonly, allowOptional }) {\n        return composeParslet({\n          name: \"objectFieldParslet\",\n          precedence: Precedence.KEY_VALUE,\n          accept: /* @__PURE__ */ __name((type) => type === \":\", \"accept\"),\n          parseInfix: /* @__PURE__ */ __name((parser, left) => {\n            var _a;\n            let optional = false;\n            let readonlyProperty = false;\n            if (allowOptional && left.type === \"JsdocTypeNullable\") {\n              optional = true;\n              left = left.element;\n            }\n            if (allowReadonly && left.type === \"JsdocTypeReadonlyProperty\") {\n              readonlyProperty = true;\n              left = left.element;\n            }\n            const parentParser = (_a = parser.baseParser) !== null && _a !== void 0 ? _a : parser;\n            parentParser.acceptLexerState(parser);\n            if (left.type === \"JsdocTypeNumber\" || left.type === \"JsdocTypeName\" || left.type === \"JsdocTypeStringValue\" || isSquaredProperty(left)) {\n              if (isSquaredProperty(left) && !allowSquaredProperties) {\n                throw new UnexpectedTypeError(left);\n              }\n              parentParser.consume(\":\");\n              let quote2;\n              if (left.type === \"JsdocTypeStringValue\") {\n                quote2 = left.meta.quote;\n              }\n              const right = parentParser.parseType(Precedence.KEY_VALUE);\n              parser.acceptLexerState(parentParser);\n              return {\n                type: \"JsdocTypeObjectField\",\n                key: isSquaredProperty(left) ? left : left.value.toString(),\n                right,\n                optional,\n                readonly: readonlyProperty,\n                meta: {\n                  quote: quote2\n                }\n              };\n            } else {\n              if (!allowKeyTypes) {\n                throw new UnexpectedTypeError(left);\n              }\n              parentParser.consume(\":\");\n              const right = parentParser.parseType(Precedence.KEY_VALUE);\n              parser.acceptLexerState(parentParser);\n              return {\n                type: \"JsdocTypeJsdocObjectField\",\n                left: assertRootResult(left),\n                right\n              };\n            }\n          }, \"parseInfix\")\n        });\n      }\n      __name(createObjectFieldParslet, \"createObjectFieldParslet\");\n      function createKeyValueParslet({ allowOptional, allowVariadic }) {\n        return composeParslet({\n          name: \"keyValueParslet\",\n          precedence: Precedence.KEY_VALUE,\n          accept: /* @__PURE__ */ __name((type) => type === \":\", \"accept\"),\n          parseInfix: /* @__PURE__ */ __name((parser, left) => {\n            let optional = false;\n            let variadic = false;\n            if (allowOptional && left.type === \"JsdocTypeNullable\") {\n              optional = true;\n              left = left.element;\n            }\n            if (allowVariadic && left.type === \"JsdocTypeVariadic\" && left.element !== void 0) {\n              variadic = true;\n              left = left.element;\n            }\n            if (left.type !== \"JsdocTypeName\") {\n              throw new UnexpectedTypeError(left);\n            }\n            parser.consume(\":\");\n            const right = parser.parseType(Precedence.KEY_VALUE);\n            return {\n              type: \"JsdocTypeKeyValue\",\n              key: left.value,\n              right,\n              optional,\n              variadic\n            };\n          }, \"parseInfix\")\n        });\n      }\n      __name(createKeyValueParslet, \"createKeyValueParslet\");\n      const jsdocBaseGrammar = [\n        ...baseGrammar,\n        createFunctionParslet({\n          allowWithoutParenthesis: true,\n          allowNamedParameters: [\"this\", \"new\"],\n          allowNoReturnType: true,\n          allowNewAsFunctionKeyword: false\n        }),\n        stringValueParslet,\n        createSpecialNamePathParslet({\n          allowedTypes: [\"module\", \"external\", \"event\"],\n          pathGrammar\n        }),\n        createVariadicParslet({\n          allowEnclosingBrackets: true,\n          allowPostfix: true\n        }),\n        createNameParslet({\n          allowedAdditionalTokens: [\"keyof\"]\n        }),\n        symbolParslet,\n        arrayBracketsParslet,\n        createNamePathParslet({\n          allowSquareBracketsOnAnyType: false,\n          allowJsdocNamePaths: true,\n          pathGrammar\n        })\n      ];\n      const jsdocGrammar = [\n        ...jsdocBaseGrammar,\n        createObjectParslet({\n          // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here\n          // we leave out the object type deliberately\n          objectFieldGrammar: [\n            createNameParslet({\n              allowedAdditionalTokens: [\"typeof\", \"module\", \"in\"]\n            }),\n            createObjectFieldParslet({\n              allowSquaredProperties: false,\n              allowKeyTypes: true,\n              allowOptional: false,\n              allowReadonly: false\n            }),\n            ...jsdocBaseGrammar\n          ],\n          allowKeyTypes: true\n        }),\n        createKeyValueParslet({\n          allowOptional: true,\n          allowVariadic: true\n        })\n      ];\n      const typeOfParslet = composeParslet({\n        name: \"typeOfParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"typeof\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          parser.consume(\"typeof\");\n          return {\n            type: \"JsdocTypeTypeof\",\n            element: parser.parseType(Precedence.KEY_OF_TYPE_OF)\n          };\n        }, \"parsePrefix\")\n      });\n      const objectFieldGrammar$1 = [\n        createNameParslet({\n          allowedAdditionalTokens: [\"typeof\", \"module\", \"keyof\", \"event\", \"external\", \"in\"]\n        }),\n        nullableParslet,\n        optionalParslet,\n        stringValueParslet,\n        numberParslet,\n        createObjectFieldParslet({\n          allowSquaredProperties: false,\n          allowKeyTypes: false,\n          allowOptional: false,\n          allowReadonly: false\n        })\n      ];\n      const closureGrammar = [\n        ...baseGrammar,\n        createObjectParslet({\n          allowKeyTypes: false,\n          objectFieldGrammar: objectFieldGrammar$1\n        }),\n        createNameParslet({\n          allowedAdditionalTokens: [\"event\", \"external\", \"in\"]\n        }),\n        typeOfParslet,\n        createFunctionParslet({\n          allowWithoutParenthesis: false,\n          allowNamedParameters: [\"this\", \"new\"],\n          allowNoReturnType: true,\n          allowNewAsFunctionKeyword: false\n        }),\n        createVariadicParslet({\n          allowEnclosingBrackets: false,\n          allowPostfix: false\n        }),\n        // additional name parslet is needed for some special cases\n        createNameParslet({\n          allowedAdditionalTokens: [\"keyof\"]\n        }),\n        createSpecialNamePathParslet({\n          allowedTypes: [\"module\"],\n          pathGrammar\n        }),\n        createNamePathParslet({\n          allowSquareBracketsOnAnyType: false,\n          allowJsdocNamePaths: true,\n          pathGrammar\n        }),\n        createKeyValueParslet({\n          allowOptional: false,\n          allowVariadic: false\n        }),\n        symbolParslet\n      ];\n      const assertsParslet = composeParslet({\n        name: \"assertsParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"asserts\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          parser.consume(\"asserts\");\n          const left = parser.parseIntermediateType(Precedence.SYMBOL);\n          if (left.type !== \"JsdocTypeName\") {\n            throw new UnexpectedTypeError(left, \"A typescript asserts always has to have a name on the left side.\");\n          }\n          if (!parser.consume(\"is\")) {\n            return {\n              type: \"JsdocTypeAssertsPlain\",\n              element: left\n            };\n          }\n          return {\n            type: \"JsdocTypeAsserts\",\n            left,\n            right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n          };\n        }, \"parsePrefix\")\n      });\n      function createTupleParslet({ allowQuestionMark }) {\n        return composeParslet({\n          name: \"tupleParslet\",\n          accept: /* @__PURE__ */ __name((type) => type === \"[\", \"accept\"),\n          parsePrefix: /* @__PURE__ */ __name((parser) => {\n            parser.consume(\"[\");\n            const result = {\n              type: \"JsdocTypeTuple\",\n              elements: []\n            };\n            if (parser.consume(\"]\")) {\n              return result;\n            }\n            const typeList = parser.parseIntermediateType(Precedence.ALL);\n            if (typeList.type === \"JsdocTypeParameterList\") {\n              if (typeList.elements[0].type === \"JsdocTypeKeyValue\") {\n                result.elements = typeList.elements.map(assertPlainKeyValueResult);\n              } else {\n                result.elements = typeList.elements.map(assertRootResult);\n              }\n            } else {\n              if (typeList.type === \"JsdocTypeKeyValue\") {\n                result.elements = [assertPlainKeyValueResult(typeList)];\n              } else {\n                result.elements = [assertRootResult(typeList)];\n              }\n            }\n            if (!parser.consume(\"]\")) {\n              throw new Error(\"Unterminated '['\");\n            }\n            if (result.elements.some((e) => e.type === \"JsdocTypeUnknown\")) {\n              throw new Error(\"Question mark in tuple not allowed\");\n            }\n            return result;\n          }, \"parsePrefix\")\n        });\n      }\n      __name(createTupleParslet, \"createTupleParslet\");\n      const keyOfParslet = composeParslet({\n        name: \"keyOfParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"keyof\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          parser.consume(\"keyof\");\n          return {\n            type: \"JsdocTypeKeyof\",\n            element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))\n          };\n        }, \"parsePrefix\")\n      });\n      const importParslet = composeParslet({\n        name: \"importParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"import\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          parser.consume(\"import\");\n          if (!parser.consume(\"(\")) {\n            throw new Error(\"Missing parenthesis after import keyword\");\n          }\n          const path = parser.parseType(Precedence.PREFIX);\n          if (path.type !== \"JsdocTypeStringValue\") {\n            throw new Error(\"Only string values are allowed as paths for imports\");\n          }\n          if (!parser.consume(\")\")) {\n            throw new Error(\"Missing closing parenthesis after import keyword\");\n          }\n          return {\n            type: \"JsdocTypeImport\",\n            element: path\n          };\n        }, \"parsePrefix\")\n      });\n      const readonlyPropertyParslet = composeParslet({\n        name: \"readonlyPropertyParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"readonly\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          parser.consume(\"readonly\");\n          return {\n            type: \"JsdocTypeReadonlyProperty\",\n            element: parser.parseIntermediateType(Precedence.KEY_VALUE)\n          };\n        }, \"parsePrefix\")\n      });\n      const arrowFunctionParslet = composeParslet({\n        name: \"arrowFunctionParslet\",\n        precedence: Precedence.ARROW,\n        accept: /* @__PURE__ */ __name((type) => type === \"=>\", \"accept\"),\n        parseInfix: /* @__PURE__ */ __name((parser, left) => {\n          parser.consume(\"=>\");\n          return {\n            type: \"JsdocTypeFunction\",\n            parameters: getParameters(left).map(assertPlainKeyValueOrNameResult),\n            arrow: true,\n            constructor: false,\n            parenthesis: true,\n            returnType: parser.parseType(Precedence.OBJECT)\n          };\n        }, \"parseInfix\")\n      });\n      const genericArrowFunctionParslet = composeParslet({\n        name: \"genericArrowFunctionParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"<\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          const typeParameters = [];\n          parser.consume(\"<\");\n          do {\n            let defaultValue;\n            let name = parser.parseIntermediateType(Precedence.SYMBOL);\n            if (name.type === \"JsdocTypeOptional\") {\n              name = name.element;\n              defaultValue = parser.parseType(Precedence.SYMBOL);\n            }\n            if (name.type !== \"JsdocTypeName\") {\n              throw new UnexpectedTypeError(name);\n            }\n            let constraint;\n            if (parser.consume(\"extends\")) {\n              constraint = parser.parseType(Precedence.SYMBOL);\n              if (constraint.type === \"JsdocTypeOptional\") {\n                constraint = constraint.element;\n                defaultValue = parser.parseType(Precedence.SYMBOL);\n              }\n            }\n            const typeParameter = {\n              type: \"JsdocTypeTypeParameter\",\n              name\n            };\n            if (constraint !== void 0) {\n              typeParameter.constraint = constraint;\n            }\n            if (defaultValue !== void 0) {\n              typeParameter.defaultValue = defaultValue;\n            }\n            typeParameters.push(typeParameter);\n            if (parser.consume(\">\")) {\n              break;\n            }\n          } while (parser.consume(\",\"));\n          const functionBase = parser.parseIntermediateType(Precedence.SYMBOL);\n          functionBase.typeParameters = typeParameters;\n          return functionBase;\n        }, \"parsePrefix\")\n      });\n      const intersectionParslet = composeParslet({\n        name: \"intersectionParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"&\", \"accept\"),\n        precedence: Precedence.INTERSECTION,\n        parseInfix: /* @__PURE__ */ __name((parser, left) => {\n          parser.consume(\"&\");\n          const elements = [];\n          do {\n            elements.push(parser.parseType(Precedence.INTERSECTION));\n          } while (parser.consume(\"&\"));\n          return {\n            type: \"JsdocTypeIntersection\",\n            elements: [assertRootResult(left), ...elements]\n          };\n        }, \"parseInfix\")\n      });\n      const predicateParslet = composeParslet({\n        name: \"predicateParslet\",\n        precedence: Precedence.INFIX,\n        accept: /* @__PURE__ */ __name((type) => type === \"is\", \"accept\"),\n        parseInfix: /* @__PURE__ */ __name((parser, left) => {\n          if (left.type !== \"JsdocTypeName\") {\n            throw new UnexpectedTypeError(left, \"A typescript predicate always has to have a name on the left side.\");\n          }\n          parser.consume(\"is\");\n          return {\n            type: \"JsdocTypePredicate\",\n            left,\n            right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n          };\n        }, \"parseInfix\")\n      });\n      const objectSquaredPropertyParslet = composeParslet({\n        name: \"objectSquareBracketPropertyParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"[\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          if (parser.baseParser === void 0) {\n            throw new Error(\"Only allowed inside object grammar\");\n          }\n          parser.consume(\"[\");\n          const key = parser.lexer.current.text;\n          parser.consume(\"Identifier\");\n          let result;\n          if (parser.consume(\":\")) {\n            const parentParser = parser.baseParser;\n            parentParser.acceptLexerState(parser);\n            result = {\n              type: \"JsdocTypeIndexSignature\",\n              key,\n              right: parentParser.parseType(Precedence.INDEX_BRACKETS)\n            };\n            parser.acceptLexerState(parentParser);\n          } else if (parser.consume(\"in\")) {\n            const parentParser = parser.baseParser;\n            parentParser.acceptLexerState(parser);\n            result = {\n              type: \"JsdocTypeMappedType\",\n              key,\n              right: parentParser.parseType(Precedence.ARRAY_BRACKETS)\n            };\n            parser.acceptLexerState(parentParser);\n          } else {\n            throw new Error(\"Missing ':' or 'in' inside square bracketed property.\");\n          }\n          if (!parser.consume(\"]\")) {\n            throw new Error(\"Unterminated square brackets\");\n          }\n          return result;\n        }, \"parsePrefix\")\n      });\n      const readonlyArrayParslet = composeParslet({\n        name: \"readonlyArrayParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"readonly\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          parser.consume(\"readonly\");\n          return {\n            type: \"JsdocTypeReadonlyArray\",\n            element: assertArrayOrTupleResult(parser.parseIntermediateType(Precedence.ALL))\n          };\n        }, \"parsePrefix\")\n      });\n      const conditionalParslet = composeParslet({\n        name: \"conditionalParslet\",\n        precedence: Precedence.INFIX,\n        accept: /* @__PURE__ */ __name((type) => type === \"extends\", \"accept\"),\n        parseInfix: /* @__PURE__ */ __name((parser, left) => {\n          parser.consume(\"extends\");\n          const extendsType = parser.parseType(Precedence.KEY_OF_TYPE_OF).element;\n          const trueType = parser.parseType(Precedence.INFIX);\n          parser.consume(\":\");\n          return {\n            type: \"JsdocTypeConditional\",\n            checksType: assertRootResult(left),\n            extendsType,\n            trueType,\n            falseType: parser.parseType(Precedence.INFIX)\n          };\n        }, \"parseInfix\")\n      });\n      const objectFieldGrammar = [\n        readonlyPropertyParslet,\n        createNameParslet({\n          allowedAdditionalTokens: [\"typeof\", \"module\", \"keyof\", \"event\", \"external\", \"in\"]\n        }),\n        nullableParslet,\n        optionalParslet,\n        stringValueParslet,\n        numberParslet,\n        createObjectFieldParslet({\n          allowSquaredProperties: true,\n          allowKeyTypes: false,\n          allowOptional: true,\n          allowReadonly: true\n        }),\n        objectSquaredPropertyParslet\n      ];\n      const typescriptGrammar = [\n        ...baseGrammar,\n        createObjectParslet({\n          allowKeyTypes: false,\n          objectFieldGrammar\n        }),\n        readonlyArrayParslet,\n        typeOfParslet,\n        keyOfParslet,\n        importParslet,\n        stringValueParslet,\n        createFunctionParslet({\n          allowWithoutParenthesis: true,\n          allowNoReturnType: false,\n          allowNamedParameters: [\"this\", \"new\", \"args\"],\n          allowNewAsFunctionKeyword: true\n        }),\n        createTupleParslet({\n          allowQuestionMark: false\n        }),\n        createVariadicParslet({\n          allowEnclosingBrackets: false,\n          allowPostfix: false\n        }),\n        assertsParslet,\n        conditionalParslet,\n        createNameParslet({\n          allowedAdditionalTokens: [\"event\", \"external\", \"in\"]\n        }),\n        createSpecialNamePathParslet({\n          allowedTypes: [\"module\"],\n          pathGrammar\n        }),\n        arrayBracketsParslet,\n        arrowFunctionParslet,\n        genericArrowFunctionParslet,\n        createNamePathParslet({\n          allowSquareBracketsOnAnyType: true,\n          allowJsdocNamePaths: false,\n          pathGrammar\n        }),\n        intersectionParslet,\n        predicateParslet,\n        createKeyValueParslet({\n          allowVariadic: true,\n          allowOptional: true\n        })\n      ];\n      function parse3(expression, mode) {\n        switch (mode) {\n          case \"closure\":\n            return new Parser(closureGrammar, expression).parse();\n          case \"jsdoc\":\n            return new Parser(jsdocGrammar, expression).parse();\n          case \"typescript\":\n            return new Parser(typescriptGrammar, expression).parse();\n        }\n      }\n      __name(parse3, \"parse\");\n      function tryParse(expression, modes = [\"typescript\", \"closure\", \"jsdoc\"]) {\n        let error;\n        for (const mode of modes) {\n          try {\n            return parse3(expression, mode);\n          } catch (e) {\n            error = e;\n          }\n        }\n        throw error;\n      }\n      __name(tryParse, \"tryParse\");\n      function transform(rules2, parseResult) {\n        const rule = rules2[parseResult.type];\n        if (rule === void 0) {\n          throw new Error(`In this set of transform rules exists no rule for type ${parseResult.type}.`);\n        }\n        return rule(parseResult, (aParseResult) => transform(rules2, aParseResult));\n      }\n      __name(transform, \"transform\");\n      function notAvailableTransform(parseResult) {\n        throw new Error(\"This transform is not available. Are you trying the correct parsing mode?\");\n      }\n      __name(notAvailableTransform, \"notAvailableTransform\");\n      function extractSpecialParams(source) {\n        const result = {\n          params: []\n        };\n        for (const param of source.parameters) {\n          if (param.type === \"JsdocTypeKeyValue\") {\n            if (param.key === \"this\") {\n              result.this = param.right;\n            } else if (param.key === \"new\") {\n              result.new = param.right;\n            } else {\n              result.params.push(param);\n            }\n          } else {\n            result.params.push(param);\n          }\n        }\n        return result;\n      }\n      __name(extractSpecialParams, \"extractSpecialParams\");\n      function applyPosition(position, target, value) {\n        return position === \"prefix\" ? value + target : target + value;\n      }\n      __name(applyPosition, \"applyPosition\");\n      function quote(value, quote2) {\n        switch (quote2) {\n          case \"double\":\n            return `\"${value}\"`;\n          case \"single\":\n            return `'${value}'`;\n          case void 0:\n            return value;\n        }\n      }\n      __name(quote, \"quote\");\n      function stringifyRules2() {\n        return {\n          JsdocTypeParenthesis: /* @__PURE__ */ __name((result, transform2) => `(${result.element !== void 0 ? transform2(result.element) : \"\"})`, \"JsdocTypeParenthesis\"),\n          JsdocTypeKeyof: /* @__PURE__ */ __name((result, transform2) => `keyof ${transform2(result.element)}`, \"JsdocTypeKeyof\"),\n          JsdocTypeFunction: /* @__PURE__ */ __name((result, transform2) => {\n            var _a;\n            if (!result.arrow) {\n              let stringified = result.constructor ? \"new\" : \"function\";\n              if (!result.parenthesis) {\n                return stringified;\n              }\n              stringified += `(${result.parameters.map(transform2).join(\", \")})`;\n              if (result.returnType !== void 0) {\n                stringified += `: ${transform2(result.returnType)}`;\n              }\n              return stringified;\n            } else {\n              if (result.returnType === void 0) {\n                throw new Error(\"Arrow function needs a return type.\");\n              }\n              let stringified = `${result.typeParameters !== void 0 ? `<${(_a = result.typeParameters.map(transform2).join(\", \")) !== null && _a !== void 0 ? _a : \"\"}>` : \"\"}(${result.parameters.map(transform2).join(\", \")}) => ${transform2(result.returnType)}`;\n              if (result.constructor) {\n                stringified = \"new \" + stringified;\n              }\n              return stringified;\n            }\n          }, \"JsdocTypeFunction\"),\n          JsdocTypeName: /* @__PURE__ */ __name((result) => result.value, \"JsdocTypeName\"),\n          JsdocTypeTuple: /* @__PURE__ */ __name((result, transform2) => `[${result.elements.map(transform2).join(\", \")}]`, \"JsdocTypeTuple\"),\n          JsdocTypeVariadic: /* @__PURE__ */ __name((result, transform2) => result.meta.position === void 0 ? \"...\" : applyPosition(result.meta.position, transform2(result.element), \"...\"), \"JsdocTypeVariadic\"),\n          JsdocTypeNamePath: /* @__PURE__ */ __name((result, transform2) => {\n            const left = transform2(result.left);\n            const right = transform2(result.right);\n            switch (result.pathType) {\n              case \"inner\":\n                return `${left}~${right}`;\n              case \"instance\":\n                return `${left}#${right}`;\n              case \"property\":\n                return `${left}.${right}`;\n              case \"property-brackets\":\n                return `${left}[${right}]`;\n            }\n          }, \"JsdocTypeNamePath\"),\n          JsdocTypeStringValue: /* @__PURE__ */ __name((result) => quote(result.value, result.meta.quote), \"JsdocTypeStringValue\"),\n          JsdocTypeAny: /* @__PURE__ */ __name(() => \"*\", \"JsdocTypeAny\"),\n          JsdocTypeGeneric: /* @__PURE__ */ __name((result, transform2) => {\n            if (result.meta.brackets === \"square\") {\n              const element = result.elements[0];\n              const transformed = transform2(element);\n              if (element.type === \"JsdocTypeUnion\" || element.type === \"JsdocTypeIntersection\") {\n                return `(${transformed})[]`;\n              } else {\n                return `${transformed}[]`;\n              }\n            } else {\n              return `${transform2(result.left)}${result.meta.dot ? \".\" : \"\"}<${result.infer === true ? \"infer \" : \"\"}${result.elements.map(transform2).join(\", \")}>`;\n            }\n          }, \"JsdocTypeGeneric\"),\n          JsdocTypeImport: /* @__PURE__ */ __name((result, transform2) => `import(${transform2(result.element)})`, \"JsdocTypeImport\"),\n          JsdocTypeObjectField: /* @__PURE__ */ __name((result, transform2) => {\n            let text = \"\";\n            if (result.readonly) {\n              text += \"readonly \";\n            }\n            if (typeof result.key === \"string\") {\n              text += quote(result.key, result.meta.quote);\n            } else {\n              text += transform2(result.key);\n            }\n            if (result.optional) {\n              text += \"?\";\n            }\n            if (result.right === void 0) {\n              return text;\n            } else {\n              return text + `: ${transform2(result.right)}`;\n            }\n          }, \"JsdocTypeObjectField\"),\n          JsdocTypeJsdocObjectField: /* @__PURE__ */ __name((result, transform2) => {\n            return `${transform2(result.left)}: ${transform2(result.right)}`;\n          }, \"JsdocTypeJsdocObjectField\"),\n          JsdocTypeKeyValue: /* @__PURE__ */ __name((result, transform2) => {\n            let text = result.key;\n            if (result.optional) {\n              text += \"?\";\n            }\n            if (result.variadic) {\n              text = \"...\" + text;\n            }\n            if (result.right === void 0) {\n              return text;\n            } else {\n              return text + `: ${transform2(result.right)}`;\n            }\n          }, \"JsdocTypeKeyValue\"),\n          JsdocTypeSpecialNamePath: /* @__PURE__ */ __name((result) => `${result.specialType}:${quote(result.value, result.meta.quote)}`, \"JsdocTypeSpecialNamePath\"),\n          JsdocTypeNotNullable: /* @__PURE__ */ __name((result, transform2) => applyPosition(result.meta.position, transform2(result.element), \"!\"), \"JsdocTypeNotNullable\"),\n          JsdocTypeNull: /* @__PURE__ */ __name(() => \"null\", \"JsdocTypeNull\"),\n          JsdocTypeNullable: /* @__PURE__ */ __name((result, transform2) => applyPosition(result.meta.position, transform2(result.element), \"?\"), \"JsdocTypeNullable\"),\n          JsdocTypeNumber: /* @__PURE__ */ __name((result) => result.value.toString(), \"JsdocTypeNumber\"),\n          JsdocTypeObject: /* @__PURE__ */ __name((result, transform2) => {\n            var _a, _b;\n            return `{${(result.meta.separator === \"linebreak\" && result.elements.length > 1 ? \"\\n\" + ((_a = result.meta.propertyIndent) !== null && _a !== void 0 ? _a : \"\") : \"\") + result.elements.map(transform2).join(result.meta.separator === \"comma\" ? \", \" : result.meta.separator === \"linebreak\" ? \"\\n\" + ((_b = result.meta.propertyIndent) !== null && _b !== void 0 ? _b : \"\") : \"; \") + (result.meta.separator === \"linebreak\" && result.elements.length > 1 ? \"\\n\" : \"\")}}`;\n          }, \"JsdocTypeObject\"),\n          JsdocTypeOptional: /* @__PURE__ */ __name((result, transform2) => applyPosition(result.meta.position, transform2(result.element), \"=\"), \"JsdocTypeOptional\"),\n          JsdocTypeSymbol: /* @__PURE__ */ __name((result, transform2) => `${result.value}(${result.element !== void 0 ? transform2(result.element) : \"\"})`, \"JsdocTypeSymbol\"),\n          JsdocTypeTypeof: /* @__PURE__ */ __name((result, transform2) => `typeof ${transform2(result.element)}`, \"JsdocTypeTypeof\"),\n          JsdocTypeUndefined: /* @__PURE__ */ __name(() => \"undefined\", \"JsdocTypeUndefined\"),\n          JsdocTypeUnion: /* @__PURE__ */ __name((result, transform2) => result.elements.map(transform2).join(\" | \"), \"JsdocTypeUnion\"),\n          JsdocTypeUnknown: /* @__PURE__ */ __name(() => \"?\", \"JsdocTypeUnknown\"),\n          JsdocTypeIntersection: /* @__PURE__ */ __name((result, transform2) => result.elements.map(transform2).join(\" & \"), \"JsdocTypeIntersection\"),\n          JsdocTypeProperty: /* @__PURE__ */ __name((result) => quote(result.value, result.meta.quote), \"JsdocTypeProperty\"),\n          JsdocTypePredicate: /* @__PURE__ */ __name((result, transform2) => `${transform2(result.left)} is ${transform2(result.right)}`, \"JsdocTypePredicate\"),\n          JsdocTypeIndexSignature: /* @__PURE__ */ __name((result, transform2) => `[${result.key}: ${transform2(result.right)}]`, \"JsdocTypeIndexSignature\"),\n          JsdocTypeMappedType: /* @__PURE__ */ __name((result, transform2) => `[${result.key} in ${transform2(result.right)}]`, \"JsdocTypeMappedType\"),\n          JsdocTypeAsserts: /* @__PURE__ */ __name((result, transform2) => `asserts ${transform2(result.left)} is ${transform2(result.right)}`, \"JsdocTypeAsserts\"),\n          JsdocTypeReadonlyArray: /* @__PURE__ */ __name((result, transform2) => `readonly ${transform2(result.element)}`, \"JsdocTypeReadonlyArray\"),\n          JsdocTypeAssertsPlain: /* @__PURE__ */ __name((result, transform2) => `asserts ${transform2(result.element)}`, \"JsdocTypeAssertsPlain\"),\n          JsdocTypeConditional: /* @__PURE__ */ __name((result, transform2) => `${transform2(result.checksType)} extends ${transform2(result.extendsType)} ? ${transform2(result.trueType)} : ${transform2(result.falseType)}`, \"JsdocTypeConditional\"),\n          JsdocTypeTypeParameter: /* @__PURE__ */ __name((result, transform2) => `${transform2(result.name)}${result.constraint !== void 0 ? ` extends ${transform2(result.constraint)}` : \"\"}${result.defaultValue !== void 0 ? ` = ${transform2(result.defaultValue)}` : \"\"}`, \"JsdocTypeTypeParameter\")\n        };\n      }\n      __name(stringifyRules2, \"stringifyRules\");\n      const storedStringifyRules = stringifyRules2();\n      function stringify2(result) {\n        return transform(storedStringifyRules, result);\n      }\n      __name(stringify2, \"stringify\");\n      const reservedWords = [\n        \"null\",\n        \"true\",\n        \"false\",\n        \"break\",\n        \"case\",\n        \"catch\",\n        \"class\",\n        \"const\",\n        \"continue\",\n        \"debugger\",\n        \"default\",\n        \"delete\",\n        \"do\",\n        \"else\",\n        \"export\",\n        \"extends\",\n        \"finally\",\n        \"for\",\n        \"function\",\n        \"if\",\n        \"import\",\n        \"in\",\n        \"instanceof\",\n        \"new\",\n        \"return\",\n        \"super\",\n        \"switch\",\n        \"this\",\n        \"throw\",\n        \"try\",\n        \"typeof\",\n        \"var\",\n        \"void\",\n        \"while\",\n        \"with\",\n        \"yield\"\n      ];\n      function makeName(value) {\n        const result = {\n          type: \"NameExpression\",\n          name: value\n        };\n        if (reservedWords.includes(value)) {\n          result.reservedWord = true;\n        }\n        return result;\n      }\n      __name(makeName, \"makeName\");\n      const catharsisTransformRules = {\n        JsdocTypeOptional: /* @__PURE__ */ __name((result, transform2) => {\n          const transformed = transform2(result.element);\n          transformed.optional = true;\n          return transformed;\n        }, \"JsdocTypeOptional\"),\n        JsdocTypeNullable: /* @__PURE__ */ __name((result, transform2) => {\n          const transformed = transform2(result.element);\n          transformed.nullable = true;\n          return transformed;\n        }, \"JsdocTypeNullable\"),\n        JsdocTypeNotNullable: /* @__PURE__ */ __name((result, transform2) => {\n          const transformed = transform2(result.element);\n          transformed.nullable = false;\n          return transformed;\n        }, \"JsdocTypeNotNullable\"),\n        JsdocTypeVariadic: /* @__PURE__ */ __name((result, transform2) => {\n          if (result.element === void 0) {\n            throw new Error(\"dots without value are not allowed in catharsis mode\");\n          }\n          const transformed = transform2(result.element);\n          transformed.repeatable = true;\n          return transformed;\n        }, \"JsdocTypeVariadic\"),\n        JsdocTypeAny: /* @__PURE__ */ __name(() => ({\n          type: \"AllLiteral\"\n        }), \"JsdocTypeAny\"),\n        JsdocTypeNull: /* @__PURE__ */ __name(() => ({\n          type: \"NullLiteral\"\n        }), \"JsdocTypeNull\"),\n        JsdocTypeStringValue: /* @__PURE__ */ __name((result) => makeName(quote(result.value, result.meta.quote)), \"JsdocTypeStringValue\"),\n        JsdocTypeUndefined: /* @__PURE__ */ __name(() => ({\n          type: \"UndefinedLiteral\"\n        }), \"JsdocTypeUndefined\"),\n        JsdocTypeUnknown: /* @__PURE__ */ __name(() => ({\n          type: \"UnknownLiteral\"\n        }), \"JsdocTypeUnknown\"),\n        JsdocTypeFunction: /* @__PURE__ */ __name((result, transform2) => {\n          const params = extractSpecialParams(result);\n          const transformed = {\n            type: \"FunctionType\",\n            params: params.params.map(transform2)\n          };\n          if (params.this !== void 0) {\n            transformed.this = transform2(params.this);\n          }\n          if (params.new !== void 0) {\n            transformed.new = transform2(params.new);\n          }\n          if (result.returnType !== void 0) {\n            transformed.result = transform2(result.returnType);\n          }\n          return transformed;\n        }, \"JsdocTypeFunction\"),\n        JsdocTypeGeneric: /* @__PURE__ */ __name((result, transform2) => ({\n          type: \"TypeApplication\",\n          applications: result.elements.map((o) => transform2(o)),\n          expression: transform2(result.left)\n        }), \"JsdocTypeGeneric\"),\n        JsdocTypeSpecialNamePath: /* @__PURE__ */ __name((result) => makeName(result.specialType + \":\" + quote(result.value, result.meta.quote)), \"JsdocTypeSpecialNamePath\"),\n        JsdocTypeName: /* @__PURE__ */ __name((result) => {\n          if (result.value !== \"function\") {\n            return makeName(result.value);\n          } else {\n            return {\n              type: \"FunctionType\",\n              params: []\n            };\n          }\n        }, \"JsdocTypeName\"),\n        JsdocTypeNumber: /* @__PURE__ */ __name((result) => makeName(result.value.toString()), \"JsdocTypeNumber\"),\n        JsdocTypeObject: /* @__PURE__ */ __name((result, transform2) => {\n          const transformed = {\n            type: \"RecordType\",\n            fields: []\n          };\n          for (const field of result.elements) {\n            if (field.type !== \"JsdocTypeObjectField\" && field.type !== \"JsdocTypeJsdocObjectField\") {\n              transformed.fields.push({\n                type: \"FieldType\",\n                key: transform2(field),\n                value: void 0\n              });\n            } else {\n              transformed.fields.push(transform2(field));\n            }\n          }\n          return transformed;\n        }, \"JsdocTypeObject\"),\n        JsdocTypeObjectField: /* @__PURE__ */ __name((result, transform2) => {\n          if (typeof result.key !== \"string\") {\n            throw new Error(\"Index signatures and mapped types are not supported\");\n          }\n          return {\n            type: \"FieldType\",\n            key: makeName(quote(result.key, result.meta.quote)),\n            value: result.right === void 0 ? void 0 : transform2(result.right)\n          };\n        }, \"JsdocTypeObjectField\"),\n        JsdocTypeJsdocObjectField: /* @__PURE__ */ __name((result, transform2) => ({\n          type: \"FieldType\",\n          key: transform2(result.left),\n          value: transform2(result.right)\n        }), \"JsdocTypeJsdocObjectField\"),\n        JsdocTypeUnion: /* @__PURE__ */ __name((result, transform2) => ({\n          type: \"TypeUnion\",\n          elements: result.elements.map((e) => transform2(e))\n        }), \"JsdocTypeUnion\"),\n        JsdocTypeKeyValue: /* @__PURE__ */ __name((result, transform2) => {\n          return {\n            type: \"FieldType\",\n            key: makeName(result.key),\n            value: result.right === void 0 ? void 0 : transform2(result.right)\n          };\n        }, \"JsdocTypeKeyValue\"),\n        JsdocTypeNamePath: /* @__PURE__ */ __name((result, transform2) => {\n          const leftResult = transform2(result.left);\n          let rightValue;\n          if (result.right.type === \"JsdocTypeSpecialNamePath\") {\n            rightValue = transform2(result.right).name;\n          } else {\n            rightValue = quote(result.right.value, result.right.meta.quote);\n          }\n          const joiner = result.pathType === \"inner\" ? \"~\" : result.pathType === \"instance\" ? \"#\" : \".\";\n          return makeName(`${leftResult.name}${joiner}${rightValue}`);\n        }, \"JsdocTypeNamePath\"),\n        JsdocTypeSymbol: /* @__PURE__ */ __name((result) => {\n          let value = \"\";\n          let element = result.element;\n          let trailingDots = false;\n          if ((element === null || element === void 0 ? void 0 : element.type) === \"JsdocTypeVariadic\") {\n            if (element.meta.position === \"prefix\") {\n              value = \"...\";\n            } else {\n              trailingDots = true;\n            }\n            element = element.element;\n          }\n          if ((element === null || element === void 0 ? void 0 : element.type) === \"JsdocTypeName\") {\n            value += element.value;\n          } else if ((element === null || element === void 0 ? void 0 : element.type) === \"JsdocTypeNumber\") {\n            value += element.value.toString();\n          }\n          if (trailingDots) {\n            value += \"...\";\n          }\n          return makeName(`${result.value}(${value})`);\n        }, \"JsdocTypeSymbol\"),\n        JsdocTypeParenthesis: /* @__PURE__ */ __name((result, transform2) => transform2(assertRootResult(result.element)), \"JsdocTypeParenthesis\"),\n        JsdocTypeMappedType: notAvailableTransform,\n        JsdocTypeIndexSignature: notAvailableTransform,\n        JsdocTypeImport: notAvailableTransform,\n        JsdocTypeKeyof: notAvailableTransform,\n        JsdocTypeTuple: notAvailableTransform,\n        JsdocTypeTypeof: notAvailableTransform,\n        JsdocTypeIntersection: notAvailableTransform,\n        JsdocTypeProperty: notAvailableTransform,\n        JsdocTypePredicate: notAvailableTransform,\n        JsdocTypeAsserts: notAvailableTransform,\n        JsdocTypeReadonlyArray: notAvailableTransform,\n        JsdocTypeAssertsPlain: notAvailableTransform,\n        JsdocTypeConditional: notAvailableTransform,\n        JsdocTypeTypeParameter: notAvailableTransform\n      };\n      function catharsisTransform(result) {\n        return transform(catharsisTransformRules, result);\n      }\n      __name(catharsisTransform, \"catharsisTransform\");\n      function getQuoteStyle(quote2) {\n        switch (quote2) {\n          case void 0:\n            return \"none\";\n          case \"single\":\n            return \"single\";\n          case \"double\":\n            return \"double\";\n        }\n      }\n      __name(getQuoteStyle, \"getQuoteStyle\");\n      function getMemberType(type) {\n        switch (type) {\n          case \"inner\":\n            return \"INNER_MEMBER\";\n          case \"instance\":\n            return \"INSTANCE_MEMBER\";\n          case \"property\":\n            return \"MEMBER\";\n          case \"property-brackets\":\n            return \"MEMBER\";\n        }\n      }\n      __name(getMemberType, \"getMemberType\");\n      function nestResults(type, results) {\n        if (results.length === 2) {\n          return {\n            type,\n            left: results[0],\n            right: results[1]\n          };\n        } else {\n          return {\n            type,\n            left: results[0],\n            right: nestResults(type, results.slice(1))\n          };\n        }\n      }\n      __name(nestResults, \"nestResults\");\n      const jtpRules = {\n        JsdocTypeOptional: /* @__PURE__ */ __name((result, transform2) => ({\n          type: \"OPTIONAL\",\n          value: transform2(result.element),\n          meta: {\n            syntax: result.meta.position === \"prefix\" ? \"PREFIX_EQUAL_SIGN\" : \"SUFFIX_EQUALS_SIGN\"\n          }\n        }), \"JsdocTypeOptional\"),\n        JsdocTypeNullable: /* @__PURE__ */ __name((result, transform2) => ({\n          type: \"NULLABLE\",\n          value: transform2(result.element),\n          meta: {\n            syntax: result.meta.position === \"prefix\" ? \"PREFIX_QUESTION_MARK\" : \"SUFFIX_QUESTION_MARK\"\n          }\n        }), \"JsdocTypeNullable\"),\n        JsdocTypeNotNullable: /* @__PURE__ */ __name((result, transform2) => ({\n          type: \"NOT_NULLABLE\",\n          value: transform2(result.element),\n          meta: {\n            syntax: result.meta.position === \"prefix\" ? \"PREFIX_BANG\" : \"SUFFIX_BANG\"\n          }\n        }), \"JsdocTypeNotNullable\"),\n        JsdocTypeVariadic: /* @__PURE__ */ __name((result, transform2) => {\n          const transformed = {\n            type: \"VARIADIC\",\n            meta: {\n              syntax: result.meta.position === \"prefix\" ? \"PREFIX_DOTS\" : result.meta.position === \"suffix\" ? \"SUFFIX_DOTS\" : \"ONLY_DOTS\"\n            }\n          };\n          if (result.element !== void 0) {\n            transformed.value = transform2(result.element);\n          }\n          return transformed;\n        }, \"JsdocTypeVariadic\"),\n        JsdocTypeName: /* @__PURE__ */ __name((result) => ({\n          type: \"NAME\",\n          name: result.value\n        }), \"JsdocTypeName\"),\n        JsdocTypeTypeof: /* @__PURE__ */ __name((result, transform2) => ({\n          type: \"TYPE_QUERY\",\n          name: transform2(result.element)\n        }), \"JsdocTypeTypeof\"),\n        JsdocTypeTuple: /* @__PURE__ */ __name((result, transform2) => ({\n          type: \"TUPLE\",\n          entries: result.elements.map(transform2)\n        }), \"JsdocTypeTuple\"),\n        JsdocTypeKeyof: /* @__PURE__ */ __name((result, transform2) => ({\n          type: \"KEY_QUERY\",\n          value: transform2(result.element)\n        }), \"JsdocTypeKeyof\"),\n        JsdocTypeImport: /* @__PURE__ */ __name((result) => ({\n          type: \"IMPORT\",\n          path: {\n            type: \"STRING_VALUE\",\n            quoteStyle: getQuoteStyle(result.element.meta.quote),\n            string: result.element.value\n          }\n        }), \"JsdocTypeImport\"),\n        JsdocTypeUndefined: /* @__PURE__ */ __name(() => ({\n          type: \"NAME\",\n          name: \"undefined\"\n        }), \"JsdocTypeUndefined\"),\n        JsdocTypeAny: /* @__PURE__ */ __name(() => ({\n          type: \"ANY\"\n        }), \"JsdocTypeAny\"),\n        JsdocTypeFunction: /* @__PURE__ */ __name((result, transform2) => {\n          const specialParams = extractSpecialParams(result);\n          const transformed = {\n            type: result.arrow ? \"ARROW\" : \"FUNCTION\",\n            params: specialParams.params.map((param) => {\n              if (param.type === \"JsdocTypeKeyValue\") {\n                if (param.right === void 0) {\n                  throw new Error(\"Function parameter without ':' is not expected to be 'KEY_VALUE'\");\n                }\n                return {\n                  type: \"NAMED_PARAMETER\",\n                  name: param.key,\n                  typeName: transform2(param.right)\n                };\n              } else {\n                return transform2(param);\n              }\n            }),\n            new: null,\n            returns: null\n          };\n          if (specialParams.this !== void 0) {\n            transformed.this = transform2(specialParams.this);\n          } else if (!result.arrow) {\n            transformed.this = null;\n          }\n          if (specialParams.new !== void 0) {\n            transformed.new = transform2(specialParams.new);\n          }\n          if (result.returnType !== void 0) {\n            transformed.returns = transform2(result.returnType);\n          }\n          return transformed;\n        }, \"JsdocTypeFunction\"),\n        JsdocTypeGeneric: /* @__PURE__ */ __name((result, transform2) => {\n          const transformed = {\n            type: \"GENERIC\",\n            subject: transform2(result.left),\n            objects: result.elements.map(transform2),\n            meta: {\n              syntax: result.meta.brackets === \"square\" ? \"SQUARE_BRACKET\" : result.meta.dot ? \"ANGLE_BRACKET_WITH_DOT\" : \"ANGLE_BRACKET\"\n            }\n          };\n          if (result.meta.brackets === \"square\" && result.elements[0].type === \"JsdocTypeFunction\" && !result.elements[0].parenthesis) {\n            transformed.objects[0] = {\n              type: \"NAME\",\n              name: \"function\"\n            };\n          }\n          return transformed;\n        }, \"JsdocTypeGeneric\"),\n        JsdocTypeObjectField: /* @__PURE__ */ __name((result, transform2) => {\n          if (typeof result.key !== \"string\") {\n            throw new Error(\"Index signatures and mapped types are not supported\");\n          }\n          if (result.right === void 0) {\n            return {\n              type: \"RECORD_ENTRY\",\n              key: result.key,\n              quoteStyle: getQuoteStyle(result.meta.quote),\n              value: null,\n              readonly: false\n            };\n          }\n          let right = transform2(result.right);\n          if (result.optional) {\n            right = {\n              type: \"OPTIONAL\",\n              value: right,\n              meta: {\n                syntax: \"SUFFIX_KEY_QUESTION_MARK\"\n              }\n            };\n          }\n          return {\n            type: \"RECORD_ENTRY\",\n            key: result.key.toString(),\n            quoteStyle: getQuoteStyle(result.meta.quote),\n            value: right,\n            readonly: false\n          };\n        }, \"JsdocTypeObjectField\"),\n        JsdocTypeJsdocObjectField: /* @__PURE__ */ __name(() => {\n          throw new Error(\"Keys may not be typed in jsdoctypeparser.\");\n        }, \"JsdocTypeJsdocObjectField\"),\n        JsdocTypeKeyValue: /* @__PURE__ */ __name((result, transform2) => {\n          if (result.right === void 0) {\n            return {\n              type: \"RECORD_ENTRY\",\n              key: result.key,\n              quoteStyle: \"none\",\n              value: null,\n              readonly: false\n            };\n          }\n          let right = transform2(result.right);\n          if (result.optional) {\n            right = {\n              type: \"OPTIONAL\",\n              value: right,\n              meta: {\n                syntax: \"SUFFIX_KEY_QUESTION_MARK\"\n              }\n            };\n          }\n          return {\n            type: \"RECORD_ENTRY\",\n            key: result.key,\n            quoteStyle: \"none\",\n            value: right,\n            readonly: false\n          };\n        }, \"JsdocTypeKeyValue\"),\n        JsdocTypeObject: /* @__PURE__ */ __name((result, transform2) => {\n          const entries = [];\n          for (const field of result.elements) {\n            if (field.type === \"JsdocTypeObjectField\" || field.type === \"JsdocTypeJsdocObjectField\") {\n              entries.push(transform2(field));\n            }\n          }\n          return {\n            type: \"RECORD\",\n            entries\n          };\n        }, \"JsdocTypeObject\"),\n        JsdocTypeSpecialNamePath: /* @__PURE__ */ __name((result) => {\n          if (result.specialType !== \"module\") {\n            throw new Error(`jsdoctypeparser does not support type ${result.specialType} at this point.`);\n          }\n          return {\n            type: \"MODULE\",\n            value: {\n              type: \"FILE_PATH\",\n              quoteStyle: getQuoteStyle(result.meta.quote),\n              path: result.value\n            }\n          };\n        }, \"JsdocTypeSpecialNamePath\"),\n        JsdocTypeNamePath: /* @__PURE__ */ __name((result, transform2) => {\n          let hasEventPrefix = false;\n          let name;\n          let quoteStyle;\n          if (result.right.type === \"JsdocTypeSpecialNamePath\" && result.right.specialType === \"event\") {\n            hasEventPrefix = true;\n            name = result.right.value;\n            quoteStyle = getQuoteStyle(result.right.meta.quote);\n          } else {\n            name = result.right.value;\n            quoteStyle = getQuoteStyle(result.right.meta.quote);\n          }\n          const transformed = {\n            type: getMemberType(result.pathType),\n            owner: transform2(result.left),\n            name,\n            quoteStyle,\n            hasEventPrefix\n          };\n          if (transformed.owner.type === \"MODULE\") {\n            const tModule = transformed.owner;\n            transformed.owner = transformed.owner.value;\n            tModule.value = transformed;\n            return tModule;\n          } else {\n            return transformed;\n          }\n        }, \"JsdocTypeNamePath\"),\n        JsdocTypeUnion: /* @__PURE__ */ __name((result, transform2) => nestResults(\"UNION\", result.elements.map(transform2)), \"JsdocTypeUnion\"),\n        JsdocTypeParenthesis: /* @__PURE__ */ __name((result, transform2) => ({\n          type: \"PARENTHESIS\",\n          value: transform2(assertRootResult(result.element))\n        }), \"JsdocTypeParenthesis\"),\n        JsdocTypeNull: /* @__PURE__ */ __name(() => ({\n          type: \"NAME\",\n          name: \"null\"\n        }), \"JsdocTypeNull\"),\n        JsdocTypeUnknown: /* @__PURE__ */ __name(() => ({\n          type: \"UNKNOWN\"\n        }), \"JsdocTypeUnknown\"),\n        JsdocTypeStringValue: /* @__PURE__ */ __name((result) => ({\n          type: \"STRING_VALUE\",\n          quoteStyle: getQuoteStyle(result.meta.quote),\n          string: result.value\n        }), \"JsdocTypeStringValue\"),\n        JsdocTypeIntersection: /* @__PURE__ */ __name((result, transform2) => nestResults(\"INTERSECTION\", result.elements.map(transform2)), \"JsdocTypeIntersection\"),\n        JsdocTypeNumber: /* @__PURE__ */ __name((result) => ({\n          type: \"NUMBER_VALUE\",\n          number: result.value.toString()\n        }), \"JsdocTypeNumber\"),\n        JsdocTypeSymbol: notAvailableTransform,\n        JsdocTypeProperty: notAvailableTransform,\n        JsdocTypePredicate: notAvailableTransform,\n        JsdocTypeMappedType: notAvailableTransform,\n        JsdocTypeIndexSignature: notAvailableTransform,\n        JsdocTypeAsserts: notAvailableTransform,\n        JsdocTypeReadonlyArray: notAvailableTransform,\n        JsdocTypeAssertsPlain: notAvailableTransform,\n        JsdocTypeConditional: notAvailableTransform,\n        JsdocTypeTypeParameter: notAvailableTransform\n      };\n      function jtpTransform(result) {\n        return transform(jtpRules, result);\n      }\n      __name(jtpTransform, \"jtpTransform\");\n      function identityTransformRules() {\n        return {\n          JsdocTypeIntersection: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeIntersection\",\n            elements: result.elements.map(transform2)\n          }), \"JsdocTypeIntersection\"),\n          JsdocTypeGeneric: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeGeneric\",\n            left: transform2(result.left),\n            elements: result.elements.map(transform2),\n            meta: {\n              dot: result.meta.dot,\n              brackets: result.meta.brackets\n            }\n          }), \"JsdocTypeGeneric\"),\n          JsdocTypeNullable: /* @__PURE__ */ __name((result) => result, \"JsdocTypeNullable\"),\n          JsdocTypeUnion: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeUnion\",\n            elements: result.elements.map(transform2)\n          }), \"JsdocTypeUnion\"),\n          JsdocTypeUnknown: /* @__PURE__ */ __name((result) => result, \"JsdocTypeUnknown\"),\n          JsdocTypeUndefined: /* @__PURE__ */ __name((result) => result, \"JsdocTypeUndefined\"),\n          JsdocTypeTypeof: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeTypeof\",\n            element: transform2(result.element)\n          }), \"JsdocTypeTypeof\"),\n          JsdocTypeSymbol: /* @__PURE__ */ __name((result, transform2) => {\n            const transformed = {\n              type: \"JsdocTypeSymbol\",\n              value: result.value\n            };\n            if (result.element !== void 0) {\n              transformed.element = transform2(result.element);\n            }\n            return transformed;\n          }, \"JsdocTypeSymbol\"),\n          JsdocTypeOptional: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeOptional\",\n            element: transform2(result.element),\n            meta: {\n              position: result.meta.position\n            }\n          }), \"JsdocTypeOptional\"),\n          JsdocTypeObject: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeObject\",\n            meta: {\n              separator: \"comma\"\n            },\n            elements: result.elements.map(transform2)\n          }), \"JsdocTypeObject\"),\n          JsdocTypeNumber: /* @__PURE__ */ __name((result) => result, \"JsdocTypeNumber\"),\n          JsdocTypeNull: /* @__PURE__ */ __name((result) => result, \"JsdocTypeNull\"),\n          JsdocTypeNotNullable: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeNotNullable\",\n            element: transform2(result.element),\n            meta: {\n              position: result.meta.position\n            }\n          }), \"JsdocTypeNotNullable\"),\n          JsdocTypeSpecialNamePath: /* @__PURE__ */ __name((result) => result, \"JsdocTypeSpecialNamePath\"),\n          JsdocTypeObjectField: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeObjectField\",\n            key: result.key,\n            right: result.right === void 0 ? void 0 : transform2(result.right),\n            optional: result.optional,\n            readonly: result.readonly,\n            meta: result.meta\n          }), \"JsdocTypeObjectField\"),\n          JsdocTypeJsdocObjectField: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeJsdocObjectField\",\n            left: transform2(result.left),\n            right: transform2(result.right)\n          }), \"JsdocTypeJsdocObjectField\"),\n          JsdocTypeKeyValue: /* @__PURE__ */ __name((result, transform2) => {\n            return {\n              type: \"JsdocTypeKeyValue\",\n              key: result.key,\n              right: result.right === void 0 ? void 0 : transform2(result.right),\n              optional: result.optional,\n              variadic: result.variadic\n            };\n          }, \"JsdocTypeKeyValue\"),\n          JsdocTypeImport: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeImport\",\n            element: transform2(result.element)\n          }), \"JsdocTypeImport\"),\n          JsdocTypeAny: /* @__PURE__ */ __name((result) => result, \"JsdocTypeAny\"),\n          JsdocTypeStringValue: /* @__PURE__ */ __name((result) => result, \"JsdocTypeStringValue\"),\n          JsdocTypeNamePath: /* @__PURE__ */ __name((result) => result, \"JsdocTypeNamePath\"),\n          JsdocTypeVariadic: /* @__PURE__ */ __name((result, transform2) => {\n            const transformed = {\n              type: \"JsdocTypeVariadic\",\n              meta: {\n                position: result.meta.position,\n                squareBrackets: result.meta.squareBrackets\n              }\n            };\n            if (result.element !== void 0) {\n              transformed.element = transform2(result.element);\n            }\n            return transformed;\n          }, \"JsdocTypeVariadic\"),\n          JsdocTypeTuple: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeTuple\",\n            elements: result.elements.map(transform2)\n          }), \"JsdocTypeTuple\"),\n          JsdocTypeName: /* @__PURE__ */ __name((result) => result, \"JsdocTypeName\"),\n          JsdocTypeFunction: /* @__PURE__ */ __name((result, transform2) => {\n            const transformed = {\n              type: \"JsdocTypeFunction\",\n              arrow: result.arrow,\n              parameters: result.parameters.map(transform2),\n              constructor: result.constructor,\n              parenthesis: result.parenthesis\n            };\n            if (result.returnType !== void 0) {\n              transformed.returnType = transform2(result.returnType);\n            }\n            return transformed;\n          }, \"JsdocTypeFunction\"),\n          JsdocTypeKeyof: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeKeyof\",\n            element: transform2(result.element)\n          }), \"JsdocTypeKeyof\"),\n          JsdocTypeParenthesis: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeParenthesis\",\n            element: transform2(result.element)\n          }), \"JsdocTypeParenthesis\"),\n          JsdocTypeProperty: /* @__PURE__ */ __name((result) => result, \"JsdocTypeProperty\"),\n          JsdocTypePredicate: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypePredicate\",\n            left: transform2(result.left),\n            right: transform2(result.right)\n          }), \"JsdocTypePredicate\"),\n          JsdocTypeIndexSignature: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeIndexSignature\",\n            key: result.key,\n            right: transform2(result.right)\n          }), \"JsdocTypeIndexSignature\"),\n          JsdocTypeMappedType: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeMappedType\",\n            key: result.key,\n            right: transform2(result.right)\n          }), \"JsdocTypeMappedType\"),\n          JsdocTypeAsserts: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeAsserts\",\n            left: transform2(result.left),\n            right: transform2(result.right)\n          }), \"JsdocTypeAsserts\"),\n          JsdocTypeReadonlyArray: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeReadonlyArray\",\n            element: transform2(result.element)\n          }), \"JsdocTypeReadonlyArray\"),\n          JsdocTypeAssertsPlain: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeAssertsPlain\",\n            element: transform2(result.element)\n          }), \"JsdocTypeAssertsPlain\"),\n          JsdocTypeConditional: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeConditional\",\n            checksType: transform2(result.checksType),\n            extendsType: transform2(result.extendsType),\n            trueType: transform2(result.trueType),\n            falseType: transform2(result.falseType)\n          }), \"JsdocTypeConditional\"),\n          JsdocTypeTypeParameter: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeTypeParameter\",\n            name: transform2(result.name),\n            constraint: result.constraint !== void 0 ? transform2(result.constraint) : void 0,\n            defaultValue: result.defaultValue !== void 0 ? transform2(result.defaultValue) : void 0\n          }), \"JsdocTypeTypeParameter\")\n        };\n      }\n      __name(identityTransformRules, \"identityTransformRules\");\n      const visitorKeys = {\n        JsdocTypeAny: [],\n        JsdocTypeFunction: [\"parameters\", \"returnType\"],\n        JsdocTypeGeneric: [\"left\", \"elements\"],\n        JsdocTypeImport: [],\n        JsdocTypeIndexSignature: [\"right\"],\n        JsdocTypeIntersection: [\"elements\"],\n        JsdocTypeKeyof: [\"element\"],\n        JsdocTypeKeyValue: [\"right\"],\n        JsdocTypeMappedType: [\"right\"],\n        JsdocTypeName: [],\n        JsdocTypeNamePath: [\"left\", \"right\"],\n        JsdocTypeNotNullable: [\"element\"],\n        JsdocTypeNull: [],\n        JsdocTypeNullable: [\"element\"],\n        JsdocTypeNumber: [],\n        JsdocTypeObject: [\"elements\"],\n        JsdocTypeObjectField: [\"right\"],\n        JsdocTypeJsdocObjectField: [\"left\", \"right\"],\n        JsdocTypeOptional: [\"element\"],\n        JsdocTypeParenthesis: [\"element\"],\n        JsdocTypeSpecialNamePath: [],\n        JsdocTypeStringValue: [],\n        JsdocTypeSymbol: [\"element\"],\n        JsdocTypeTuple: [\"elements\"],\n        JsdocTypeTypeof: [\"element\"],\n        JsdocTypeUndefined: [],\n        JsdocTypeUnion: [\"elements\"],\n        JsdocTypeUnknown: [],\n        JsdocTypeVariadic: [\"element\"],\n        JsdocTypeProperty: [],\n        JsdocTypePredicate: [\"left\", \"right\"],\n        JsdocTypeAsserts: [\"left\", \"right\"],\n        JsdocTypeReadonlyArray: [\"element\"],\n        JsdocTypeAssertsPlain: [\"element\"],\n        JsdocTypeConditional: [\"checksType\", \"extendsType\", \"trueType\", \"falseType\"],\n        JsdocTypeTypeParameter: [\"name\", \"constraint\", \"defaultValue\"]\n      };\n      function _traverse(node, parentNode, property, onEnter, onLeave) {\n        onEnter === null || onEnter === void 0 ? void 0 : onEnter(node, parentNode, property);\n        const keysToVisit = visitorKeys[node.type];\n        for (const key of keysToVisit) {\n          const value = node[key];\n          if (value !== void 0) {\n            if (Array.isArray(value)) {\n              for (const element of value) {\n                _traverse(element, node, key, onEnter, onLeave);\n              }\n            } else {\n              _traverse(value, node, key, onEnter, onLeave);\n            }\n          }\n        }\n        onLeave === null || onLeave === void 0 ? void 0 : onLeave(node, parentNode, property);\n      }\n      __name(_traverse, \"_traverse\");\n      function traverse(node, onEnter, onLeave) {\n        _traverse(node, void 0, void 0, onEnter, onLeave);\n      }\n      __name(traverse, \"traverse\");\n      exports2.catharsisTransform = catharsisTransform;\n      exports2.identityTransformRules = identityTransformRules;\n      exports2.jtpTransform = jtpTransform;\n      exports2.parse = parse3;\n      exports2.stringify = stringify2;\n      exports2.stringifyRules = stringifyRules2;\n      exports2.transform = transform;\n      exports2.traverse = traverse;\n      exports2.tryParse = tryParse;\n      exports2.visitorKeys = visitorKeys;\n    });\n  }\n});\n\n// src/docs-tools/argTypes/convert/flow/convert.ts\nconst { UnknownArgTypesError } = __STORYBOOK_MODULE_CORE_EVENTS_PREVIEW_ERRORS__;\nvar isLiteral = /* @__PURE__ */ __name((type) => type.name === \"literal\", \"isLiteral\");\nvar toEnumOption = /* @__PURE__ */ __name((element) => element.value.replace(/['|\"]/g, \"\"), \"toEnumOption\");\nvar convertSig = /* @__PURE__ */ __name((type) => {\n  switch (type.type) {\n    case \"function\":\n      return { name: \"function\" };\n    case \"object\":\n      const values = {};\n      type.signature.properties.forEach((prop) => {\n        values[prop.key] = convert(prop.value);\n      });\n      return {\n        name: \"object\",\n        value: values\n      };\n    default:\n      throw new UnknownArgTypesError({ type, language: \"Flow\" });\n  }\n}, \"convertSig\");\nvar convert = /* @__PURE__ */ __name((type) => {\n  const { name, raw } = type;\n  const base = {};\n  if (typeof raw !== \"undefined\") {\n    base.raw = raw;\n  }\n  switch (type.name) {\n    case \"literal\":\n      return { ...base, name: \"other\", value: type.value };\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n    case \"boolean\": {\n      return { ...base, name };\n    }\n    case \"Array\": {\n      return { ...base, name: \"array\", value: type.elements.map(convert) };\n    }\n    case \"signature\":\n      return { ...base, ...convertSig(type) };\n    case \"union\":\n      if (type.elements?.every(isLiteral)) {\n        return { ...base, name: \"enum\", value: type.elements?.map(toEnumOption) };\n      }\n      return { ...base, name, value: type.elements?.map(convert) };\n    case \"intersection\":\n      return { ...base, name, value: type.elements?.map(convert) };\n    default:\n      return { ...base, name: \"other\", value: name };\n  }\n}, \"convert\");\n\n// src/docs-tools/argTypes/convert/utils.ts\nvar QUOTE_REGEX = /^['\"]|['\"]$/g;\nvar trimQuotes = /* @__PURE__ */ __name((str2) => str2.replace(QUOTE_REGEX, \"\"), \"trimQuotes\");\nvar includesQuotes = /* @__PURE__ */ __name((str2) => QUOTE_REGEX.test(str2), \"includesQuotes\");\nvar parseLiteral = /* @__PURE__ */ __name((str2) => {\n  const trimmedValue = trimQuotes(str2);\n  return includesQuotes(str2) || Number.isNaN(Number(trimmedValue)) ? trimmedValue : Number(trimmedValue);\n}, \"parseLiteral\");\n\n// src/docs-tools/argTypes/convert/proptypes/convert.ts\nvar SIGNATURE_REGEXP = /^\\(.*\\) => /;\nvar convert2 = /* @__PURE__ */ __name((type) => {\n  const { name, raw, computed, value } = type;\n  const base = {};\n  if (typeof raw !== \"undefined\") {\n    base.raw = raw;\n  }\n  switch (name) {\n    case \"enum\": {\n      const values2 = computed ? value : value.map((v) => parseLiteral(v.value));\n      return { ...base, name, value: values2 };\n    }\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n      return { ...base, name };\n    case \"func\":\n      return { ...base, name: \"function\" };\n    case \"bool\":\n    case \"boolean\":\n      return { ...base, name: \"boolean\" };\n    case \"arrayOf\":\n    case \"array\":\n      return { ...base, name: \"array\", value: value && convert2(value) };\n    case \"object\":\n      return { ...base, name };\n    case \"objectOf\":\n      return { ...base, name, value: convert2(value) };\n    case \"shape\":\n    case \"exact\":\n      const values = mapValues(value, (field) => convert2(field));\n      return { ...base, name: \"object\", value: values };\n    case \"union\":\n      return { ...base, name: \"union\", value: value.map((v) => convert2(v)) };\n    case \"instanceOf\":\n    case \"element\":\n    case \"elementType\":\n    default: {\n      if (name?.indexOf(\"|\") > 0) {\n        try {\n          const literalValues = name.split(\"|\").map((v) => JSON.parse(v));\n          return { ...base, name: \"enum\", value: literalValues };\n        } catch (err) {\n        }\n      }\n      const otherVal = value ? `${name}(${value})` : name;\n      const otherName = SIGNATURE_REGEXP.test(name) ? \"function\" : \"other\";\n      return { ...base, name: otherName, value: otherVal };\n    }\n  }\n}, \"convert\");\n\n// src/docs-tools/argTypes/convert/typescript/convert.ts\nconst { UnknownArgTypesError: UnknownArgTypesError2 } = __STORYBOOK_MODULE_CORE_EVENTS_PREVIEW_ERRORS__;\nvar convertSig2 = /* @__PURE__ */ __name((type) => {\n  switch (type.type) {\n    case \"function\":\n      return { name: \"function\" };\n    case \"object\":\n      const values = {};\n      type.signature.properties.forEach((prop) => {\n        values[prop.key] = convert3(prop.value);\n      });\n      return {\n        name: \"object\",\n        value: values\n      };\n    default:\n      throw new UnknownArgTypesError2({ type, language: \"Typescript\" });\n  }\n}, \"convertSig\");\nvar convert3 = /* @__PURE__ */ __name((type) => {\n  const { name, raw } = type;\n  const base = {};\n  if (typeof raw !== \"undefined\") {\n    base.raw = raw;\n  }\n  switch (type.name) {\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n    case \"boolean\": {\n      return { ...base, name };\n    }\n    case \"Array\": {\n      return { ...base, name: \"array\", value: type.elements.map(convert3) };\n    }\n    case \"signature\":\n      return { ...base, ...convertSig2(type) };\n    case \"union\":\n      let result;\n      if (type.elements?.every((element) => element.name === \"literal\")) {\n        result = {\n          ...base,\n          name: \"enum\",\n          // @ts-expect-error fix types\n          value: type.elements?.map((v) => parseLiteral(v.value))\n        };\n      } else {\n        result = { ...base, name, value: type.elements?.map(convert3) };\n      }\n      return result;\n    case \"intersection\":\n      return { ...base, name, value: type.elements?.map(convert3) };\n    default:\n      return { ...base, name: \"other\", value: name };\n  }\n}, \"convert\");\n\n// src/docs-tools/argTypes/convert/index.ts\nvar convert4 = /* @__PURE__ */ __name((docgenInfo) => {\n  const { type, tsType, flowType } = docgenInfo;\n  try {\n    if (type != null) {\n      return convert2(type);\n    }\n    if (tsType != null) {\n      return convert3(tsType);\n    }\n    if (flowType != null) {\n      return convert(flowType);\n    }\n  } catch (err) {\n    console.error(err);\n  }\n  return null;\n}, \"convert\");\n\n// src/docs-tools/argTypes/docgen/types.ts\nvar TypeSystem = /* @__PURE__ */ ((TypeSystem2) => {\n  TypeSystem2[\"JAVASCRIPT\"] = \"JavaScript\";\n  TypeSystem2[\"FLOW\"] = \"Flow\";\n  TypeSystem2[\"TYPESCRIPT\"] = \"TypeScript\";\n  TypeSystem2[\"UNKNOWN\"] = \"Unknown\";\n  return TypeSystem2;\n})(TypeSystem || {});\n\n// src/docs-tools/argTypes/docgen/utils/defaultValue.ts\nvar BLACKLIST = [\"null\", \"undefined\"];\nfunction isDefaultValueBlacklisted(value) {\n  return BLACKLIST.some((x) => x === value);\n}\n__name(isDefaultValueBlacklisted, \"isDefaultValueBlacklisted\");\n\n// src/docs-tools/argTypes/docgen/utils/string.ts\nvar str = /* @__PURE__ */ __name((obj) => {\n  if (!obj) {\n    return \"\";\n  }\n  if (typeof obj === \"string\") {\n    return obj;\n  }\n  throw new Error(`Description: expected string, got: ${JSON.stringify(obj)}`);\n}, \"str\");\n\n// src/docs-tools/argTypes/docgen/utils/docgenInfo.ts\nfunction hasDocgen(component) {\n  return !!component.__docgenInfo;\n}\n__name(hasDocgen, \"hasDocgen\");\nfunction isValidDocgenSection(docgenSection) {\n  return docgenSection != null && Object.keys(docgenSection).length > 0;\n}\n__name(isValidDocgenSection, \"isValidDocgenSection\");\nfunction getDocgenSection(component, section) {\n  return hasDocgen(component) ? component.__docgenInfo[section] : null;\n}\n__name(getDocgenSection, \"getDocgenSection\");\nfunction getDocgenDescription(component) {\n  return hasDocgen(component) ? str(component.__docgenInfo.description) : \"\";\n}\n__name(getDocgenDescription, \"getDocgenDescription\");\n\n// ../node_modules/comment-parser/es6/primitives.js\nvar Markers;\n(function(Markers2) {\n  Markers2[\"start\"] = \"/**\";\n  Markers2[\"nostart\"] = \"/***\";\n  Markers2[\"delim\"] = \"*\";\n  Markers2[\"end\"] = \"*/\";\n})(Markers = Markers || (Markers = {}));\n\n// ../node_modules/comment-parser/es6/util.js\nfunction isSpace(source) {\n  return /^\\s+$/.test(source);\n}\n__name(isSpace, \"isSpace\");\nfunction splitCR(source) {\n  const matches = source.match(/\\r+$/);\n  return matches == null ? [\"\", source] : [source.slice(-matches[0].length), source.slice(0, -matches[0].length)];\n}\n__name(splitCR, \"splitCR\");\nfunction splitSpace(source) {\n  const matches = source.match(/^\\s+/);\n  return matches == null ? [\"\", source] : [source.slice(0, matches[0].length), source.slice(matches[0].length)];\n}\n__name(splitSpace, \"splitSpace\");\nfunction splitLines(source) {\n  return source.split(/\\n/);\n}\n__name(splitLines, \"splitLines\");\nfunction seedSpec(spec = {}) {\n  return Object.assign({ tag: \"\", name: \"\", type: \"\", optional: false, description: \"\", problems: [], source: [] }, spec);\n}\n__name(seedSpec, \"seedSpec\");\nfunction seedTokens(tokens = {}) {\n  return Object.assign({ start: \"\", delimiter: \"\", postDelimiter: \"\", tag: \"\", postTag: \"\", name: \"\", postName: \"\", type: \"\", postType: \"\", description: \"\", end: \"\", lineEnd: \"\" }, tokens);\n}\n__name(seedTokens, \"seedTokens\");\n\n// ../node_modules/comment-parser/es6/parser/block-parser.js\nvar reTag = /^@\\S+/;\nfunction getParser({ fence = \"```\" } = {}) {\n  const fencer = getFencer(fence);\n  const toggleFence = /* @__PURE__ */ __name((source, isFenced) => fencer(source) ? !isFenced : isFenced, \"toggleFence\");\n  return /* @__PURE__ */ __name(function parseBlock(source) {\n    const sections = [[]];\n    let isFenced = false;\n    for (const line of source) {\n      if (reTag.test(line.tokens.description) && !isFenced) {\n        sections.push([line]);\n      } else {\n        sections[sections.length - 1].push(line);\n      }\n      isFenced = toggleFence(line.tokens.description, isFenced);\n    }\n    return sections;\n  }, \"parseBlock\");\n}\n__name(getParser, \"getParser\");\nfunction getFencer(fence) {\n  if (typeof fence === \"string\")\n    return (source) => source.split(fence).length % 2 === 0;\n  return fence;\n}\n__name(getFencer, \"getFencer\");\n\n// ../node_modules/comment-parser/es6/parser/source-parser.js\nfunction getParser2({ startLine = 0, markers = Markers } = {}) {\n  let block = null;\n  let num = startLine;\n  return /* @__PURE__ */ __name(function parseSource(source) {\n    let rest = source;\n    const tokens = seedTokens();\n    [tokens.lineEnd, rest] = splitCR(rest);\n    [tokens.start, rest] = splitSpace(rest);\n    if (block === null && rest.startsWith(markers.start) && !rest.startsWith(markers.nostart)) {\n      block = [];\n      tokens.delimiter = rest.slice(0, markers.start.length);\n      rest = rest.slice(markers.start.length);\n      [tokens.postDelimiter, rest] = splitSpace(rest);\n    }\n    if (block === null) {\n      num++;\n      return null;\n    }\n    const isClosed = rest.trimRight().endsWith(markers.end);\n    if (tokens.delimiter === \"\" && rest.startsWith(markers.delim) && !rest.startsWith(markers.end)) {\n      tokens.delimiter = markers.delim;\n      rest = rest.slice(markers.delim.length);\n      [tokens.postDelimiter, rest] = splitSpace(rest);\n    }\n    if (isClosed) {\n      const trimmed = rest.trimRight();\n      tokens.end = rest.slice(trimmed.length - markers.end.length);\n      rest = trimmed.slice(0, -markers.end.length);\n    }\n    tokens.description = rest;\n    block.push({ number: num, source, tokens });\n    num++;\n    if (isClosed) {\n      const result = block.slice();\n      block = null;\n      return result;\n    }\n    return null;\n  }, \"parseSource\");\n}\n__name(getParser2, \"getParser\");\n\n// ../node_modules/comment-parser/es6/parser/spec-parser.js\nfunction getParser3({ tokenizers }) {\n  return /* @__PURE__ */ __name(function parseSpec(source) {\n    var _a;\n    let spec = seedSpec({ source });\n    for (const tokenize of tokenizers) {\n      spec = tokenize(spec);\n      if ((_a = spec.problems[spec.problems.length - 1]) === null || _a === void 0 ? void 0 : _a.critical)\n        break;\n    }\n    return spec;\n  }, \"parseSpec\");\n}\n__name(getParser3, \"getParser\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/tag.js\nfunction tagTokenizer() {\n  return (spec) => {\n    const { tokens } = spec.source[0];\n    const match = tokens.description.match(/\\s*(@(\\S+))(\\s*)/);\n    if (match === null) {\n      spec.problems.push({\n        code: \"spec:tag:prefix\",\n        message: 'tag should start with \"@\" symbol',\n        line: spec.source[0].number,\n        critical: true\n      });\n      return spec;\n    }\n    tokens.tag = match[1];\n    tokens.postTag = match[3];\n    tokens.description = tokens.description.slice(match[0].length);\n    spec.tag = match[2];\n    return spec;\n  };\n}\n__name(tagTokenizer, \"tagTokenizer\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/type.js\nfunction typeTokenizer(spacing = \"compact\") {\n  const join2 = getJoiner(spacing);\n  return (spec) => {\n    let curlies = 0;\n    let lines = [];\n    for (const [i, { tokens }] of spec.source.entries()) {\n      let type = \"\";\n      if (i === 0 && tokens.description[0] !== \"{\")\n        return spec;\n      for (const ch of tokens.description) {\n        if (ch === \"{\")\n          curlies++;\n        if (ch === \"}\")\n          curlies--;\n        type += ch;\n        if (curlies === 0)\n          break;\n      }\n      lines.push([tokens, type]);\n      if (curlies === 0)\n        break;\n    }\n    if (curlies !== 0) {\n      spec.problems.push({\n        code: \"spec:type:unpaired-curlies\",\n        message: \"unpaired curlies\",\n        line: spec.source[0].number,\n        critical: true\n      });\n      return spec;\n    }\n    const parts = [];\n    const offset = lines[0][0].postDelimiter.length;\n    for (const [i, [tokens, type]] of lines.entries()) {\n      tokens.type = type;\n      if (i > 0) {\n        tokens.type = tokens.postDelimiter.slice(offset) + type;\n        tokens.postDelimiter = tokens.postDelimiter.slice(0, offset);\n      }\n      [tokens.postType, tokens.description] = splitSpace(tokens.description.slice(type.length));\n      parts.push(tokens.type);\n    }\n    parts[0] = parts[0].slice(1);\n    parts[parts.length - 1] = parts[parts.length - 1].slice(0, -1);\n    spec.type = join2(parts);\n    return spec;\n  };\n}\n__name(typeTokenizer, \"typeTokenizer\");\nvar trim = /* @__PURE__ */ __name((x) => x.trim(), \"trim\");\nfunction getJoiner(spacing) {\n  if (spacing === \"compact\")\n    return (t) => t.map(trim).join(\"\");\n  else if (spacing === \"preserve\")\n    return (t) => t.join(\"\\n\");\n  else\n    return spacing;\n}\n__name(getJoiner, \"getJoiner\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/name.js\nvar isQuoted = /* @__PURE__ */ __name((s) => s && s.startsWith('\"') && s.endsWith('\"'), \"isQuoted\");\nfunction nameTokenizer() {\n  const typeEnd = /* @__PURE__ */ __name((num, { tokens }, i) => tokens.type === \"\" ? num : i, \"typeEnd\");\n  return (spec) => {\n    const { tokens } = spec.source[spec.source.reduce(typeEnd, 0)];\n    const source = tokens.description.trimLeft();\n    const quotedGroups = source.split('\"');\n    if (quotedGroups.length > 1 && quotedGroups[0] === \"\" && quotedGroups.length % 2 === 1) {\n      spec.name = quotedGroups[1];\n      tokens.name = `\"${quotedGroups[1]}\"`;\n      [tokens.postName, tokens.description] = splitSpace(source.slice(tokens.name.length));\n      return spec;\n    }\n    let brackets = 0;\n    let name = \"\";\n    let optional = false;\n    let defaultValue;\n    for (const ch of source) {\n      if (brackets === 0 && isSpace(ch))\n        break;\n      if (ch === \"[\")\n        brackets++;\n      if (ch === \"]\")\n        brackets--;\n      name += ch;\n    }\n    if (brackets !== 0) {\n      spec.problems.push({\n        code: \"spec:name:unpaired-brackets\",\n        message: \"unpaired brackets\",\n        line: spec.source[0].number,\n        critical: true\n      });\n      return spec;\n    }\n    const nameToken = name;\n    if (name[0] === \"[\" && name[name.length - 1] === \"]\") {\n      optional = true;\n      name = name.slice(1, -1);\n      const parts = name.split(\"=\");\n      name = parts[0].trim();\n      if (parts[1] !== void 0)\n        defaultValue = parts.slice(1).join(\"=\").trim();\n      if (name === \"\") {\n        spec.problems.push({\n          code: \"spec:name:empty-name\",\n          message: \"empty name\",\n          line: spec.source[0].number,\n          critical: true\n        });\n        return spec;\n      }\n      if (defaultValue === \"\") {\n        spec.problems.push({\n          code: \"spec:name:empty-default\",\n          message: \"empty default value\",\n          line: spec.source[0].number,\n          critical: true\n        });\n        return spec;\n      }\n      if (!isQuoted(defaultValue) && /=(?!>)/.test(defaultValue)) {\n        spec.problems.push({\n          code: \"spec:name:invalid-default\",\n          message: \"invalid default value syntax\",\n          line: spec.source[0].number,\n          critical: true\n        });\n        return spec;\n      }\n    }\n    spec.optional = optional;\n    spec.name = name;\n    tokens.name = nameToken;\n    if (defaultValue !== void 0)\n      spec.default = defaultValue;\n    [tokens.postName, tokens.description] = splitSpace(source.slice(tokens.name.length));\n    return spec;\n  };\n}\n__name(nameTokenizer, \"nameTokenizer\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/description.js\nfunction descriptionTokenizer(spacing = \"compact\", markers = Markers) {\n  const join2 = getJoiner2(spacing);\n  return (spec) => {\n    spec.description = join2(spec.source, markers);\n    return spec;\n  };\n}\n__name(descriptionTokenizer, \"descriptionTokenizer\");\nfunction getJoiner2(spacing) {\n  if (spacing === \"compact\")\n    return compactJoiner;\n  if (spacing === \"preserve\")\n    return preserveJoiner;\n  return spacing;\n}\n__name(getJoiner2, \"getJoiner\");\nfunction compactJoiner(lines, markers = Markers) {\n  return lines.map(({ tokens: { description } }) => description.trim()).filter((description) => description !== \"\").join(\" \");\n}\n__name(compactJoiner, \"compactJoiner\");\nvar lineNo = /* @__PURE__ */ __name((num, { tokens }, i) => tokens.type === \"\" ? num : i, \"lineNo\");\nvar getDescription = /* @__PURE__ */ __name(({ tokens }) => (tokens.delimiter === \"\" ? tokens.start : tokens.postDelimiter.slice(1)) + tokens.description, \"getDescription\");\nfunction preserveJoiner(lines, markers = Markers) {\n  if (lines.length === 0)\n    return \"\";\n  if (lines[0].tokens.description === \"\" && lines[0].tokens.delimiter === markers.start)\n    lines = lines.slice(1);\n  const lastLine = lines[lines.length - 1];\n  if (lastLine !== void 0 && lastLine.tokens.description === \"\" && lastLine.tokens.end.endsWith(markers.end))\n    lines = lines.slice(0, -1);\n  lines = lines.slice(lines.reduce(lineNo, 0));\n  return lines.map(getDescription).join(\"\\n\");\n}\n__name(preserveJoiner, \"preserveJoiner\");\n\n// ../node_modules/comment-parser/es6/parser/index.js\nfunction getParser4({ startLine = 0, fence = \"```\", spacing = \"compact\", markers = Markers, tokenizers = [\n  tagTokenizer(),\n  typeTokenizer(spacing),\n  nameTokenizer(),\n  descriptionTokenizer(spacing)\n] } = {}) {\n  if (startLine < 0 || startLine % 1 > 0)\n    throw new Error(\"Invalid startLine\");\n  const parseSource = getParser2({ startLine, markers });\n  const parseBlock = getParser({ fence });\n  const parseSpec = getParser3({ tokenizers });\n  const joinDescription = getJoiner2(spacing);\n  return function(source) {\n    const blocks = [];\n    for (const line of splitLines(source)) {\n      const lines = parseSource(line);\n      if (lines === null)\n        continue;\n      const sections = parseBlock(lines);\n      const specs = sections.slice(1).map(parseSpec);\n      blocks.push({\n        description: joinDescription(sections[0], markers),\n        tags: specs,\n        source: lines,\n        problems: specs.reduce((acc, spec) => acc.concat(spec.problems), [])\n      });\n    }\n    return blocks;\n  };\n}\n__name(getParser4, \"getParser\");\n\n// ../node_modules/comment-parser/es6/stringifier/index.js\nfunction join(tokens) {\n  return tokens.start + tokens.delimiter + tokens.postDelimiter + tokens.tag + tokens.postTag + tokens.type + tokens.postType + tokens.name + tokens.postName + tokens.description + tokens.end + tokens.lineEnd;\n}\n__name(join, \"join\");\nfunction getStringifier() {\n  return (block) => block.source.map(({ tokens }) => join(tokens)).join(\"\\n\");\n}\n__name(getStringifier, \"getStringifier\");\n\n// ../node_modules/comment-parser/es6/stringifier/inspect.js\nvar zeroWidth = {\n  line: 0,\n  start: 0,\n  delimiter: 0,\n  postDelimiter: 0,\n  tag: 0,\n  postTag: 0,\n  name: 0,\n  postName: 0,\n  type: 0,\n  postType: 0,\n  description: 0,\n  end: 0,\n  lineEnd: 0\n};\nvar fields = Object.keys(zeroWidth);\n\n// ../node_modules/comment-parser/es6/index.js\nfunction parse(source, options = {}) {\n  return getParser4(options)(source);\n}\n__name(parse, \"parse\");\nvar stringify = getStringifier();\n\n// src/docs-tools/argTypes/jsdocParser.ts\nvar import_jsdoc_type_pratt_parser = __toESM(require_dist(), 1);\nfunction containsJsDoc(value) {\n  return value != null && value.includes(\"@\");\n}\n__name(containsJsDoc, \"containsJsDoc\");\nfunction parse2(content) {\n  const contentString = content ?? \"\";\n  const mappedLines = contentString.split(\"\\n\").map((line) => ` * ${line}`).join(\"\\n\");\n  const normalisedContent = \"/**\\n\" + mappedLines + \"\\n*/\";\n  const ast = parse(normalisedContent, {\n    spacing: \"preserve\"\n  });\n  if (!ast || ast.length === 0) {\n    throw new Error(\"Cannot parse JSDoc tags.\");\n  }\n  return ast[0];\n}\n__name(parse2, \"parse\");\nvar DEFAULT_OPTIONS = {\n  tags: [\"param\", \"arg\", \"argument\", \"returns\", \"ignore\", \"deprecated\"]\n};\nvar parseJsDoc = /* @__PURE__ */ __name((value, options = DEFAULT_OPTIONS) => {\n  if (!containsJsDoc(value)) {\n    return {\n      includesJsDoc: false,\n      ignore: false\n    };\n  }\n  const jsDocAst = parse2(value);\n  const extractedTags = extractJsDocTags(jsDocAst, options.tags);\n  if (extractedTags.ignore) {\n    return {\n      includesJsDoc: true,\n      ignore: true\n    };\n  }\n  return {\n    includesJsDoc: true,\n    ignore: false,\n    // Always use the parsed description to ensure JSDoc is removed from the description.\n    description: jsDocAst.description.trim(),\n    extractedTags\n  };\n}, \"parseJsDoc\");\nfunction extractJsDocTags(ast, tags) {\n  const extractedTags = {\n    params: null,\n    deprecated: null,\n    returns: null,\n    ignore: false\n  };\n  for (const tagSpec of ast.tags) {\n    if (tags !== void 0 && !tags.includes(tagSpec.tag)) {\n      continue;\n    }\n    if (tagSpec.tag === \"ignore\") {\n      extractedTags.ignore = true;\n      break;\n    } else {\n      switch (tagSpec.tag) {\n        // arg & argument are aliases for param.\n        case \"param\":\n        case \"arg\":\n        case \"argument\": {\n          const paramTag = extractParam(tagSpec);\n          if (paramTag != null) {\n            if (extractedTags.params == null) {\n              extractedTags.params = [];\n            }\n            extractedTags.params.push(paramTag);\n          }\n          break;\n        }\n        case \"deprecated\": {\n          const deprecatedTag = extractDeprecated(tagSpec);\n          if (deprecatedTag != null) {\n            extractedTags.deprecated = deprecatedTag;\n          }\n          break;\n        }\n        case \"returns\": {\n          const returnsTag = extractReturns(tagSpec);\n          if (returnsTag != null) {\n            extractedTags.returns = returnsTag;\n          }\n          break;\n        }\n        default:\n          break;\n      }\n    }\n  }\n  return extractedTags;\n}\n__name(extractJsDocTags, \"extractJsDocTags\");\nfunction normaliseParamName(name) {\n  return name.replace(/[\\.-]$/, \"\");\n}\n__name(normaliseParamName, \"normaliseParamName\");\nfunction extractParam(tag) {\n  if (!tag.name || tag.name === \"-\") {\n    return null;\n  }\n  const type = extractType(tag.type);\n  return {\n    name: tag.name,\n    type,\n    description: normaliseDescription(tag.description),\n    getPrettyName: /* @__PURE__ */ __name(() => {\n      return normaliseParamName(tag.name);\n    }, \"getPrettyName\"),\n    getTypeName: /* @__PURE__ */ __name(() => {\n      return type ? extractTypeName(type) : null;\n    }, \"getTypeName\")\n  };\n}\n__name(extractParam, \"extractParam\");\nfunction extractDeprecated(tag) {\n  if (tag.name) {\n    return joinNameAndDescription(tag.name, tag.description);\n  }\n  return null;\n}\n__name(extractDeprecated, \"extractDeprecated\");\nfunction joinNameAndDescription(name, desc) {\n  const joined = name === \"\" ? desc : `${name} ${desc}`;\n  return normaliseDescription(joined);\n}\n__name(joinNameAndDescription, \"joinNameAndDescription\");\nfunction normaliseDescription(text) {\n  const normalised = text.replace(/^- /g, \"\").trim();\n  return normalised === \"\" ? null : normalised;\n}\n__name(normaliseDescription, \"normaliseDescription\");\nfunction extractReturns(tag) {\n  const type = extractType(tag.type);\n  if (type) {\n    return {\n      type,\n      description: joinNameAndDescription(tag.name, tag.description),\n      getTypeName: /* @__PURE__ */ __name(() => {\n        return extractTypeName(type);\n      }, \"getTypeName\")\n    };\n  }\n  return null;\n}\n__name(extractReturns, \"extractReturns\");\nvar jsdocStringifyRules = (0, import_jsdoc_type_pratt_parser.stringifyRules)();\nvar originalJsdocStringifyObject = jsdocStringifyRules.JsdocTypeObject;\njsdocStringifyRules.JsdocTypeAny = () => \"any\";\njsdocStringifyRules.JsdocTypeObject = (result, transform) => `(${originalJsdocStringifyObject(result, transform)})`;\njsdocStringifyRules.JsdocTypeOptional = (result, transform) => transform(result.element);\njsdocStringifyRules.JsdocTypeNullable = (result, transform) => transform(result.element);\njsdocStringifyRules.JsdocTypeNotNullable = (result, transform) => transform(result.element);\njsdocStringifyRules.JsdocTypeUnion = (result, transform) => result.elements.map(transform).join(\"|\");\nfunction extractType(typeString) {\n  try {\n    return (0, import_jsdoc_type_pratt_parser.parse)(typeString, \"typescript\");\n  } catch (_err) {\n    return null;\n  }\n}\n__name(extractType, \"extractType\");\nfunction extractTypeName(type) {\n  return (0, import_jsdoc_type_pratt_parser.transform)(jsdocStringifyRules, type);\n}\n__name(extractTypeName, \"extractTypeName\");\n\n// src/docs-tools/argTypes/utils.ts\nvar MAX_TYPE_SUMMARY_LENGTH = 90;\nvar MAX_DEFAULT_VALUE_SUMMARY_LENGTH = 50;\nfunction isTooLongForTypeSummary(value) {\n  return value.length > MAX_TYPE_SUMMARY_LENGTH;\n}\n__name(isTooLongForTypeSummary, \"isTooLongForTypeSummary\");\nfunction isTooLongForDefaultValueSummary(value) {\n  return value.length > MAX_DEFAULT_VALUE_SUMMARY_LENGTH;\n}\n__name(isTooLongForDefaultValueSummary, \"isTooLongForDefaultValueSummary\");\nfunction createSummaryValue(summary, detail) {\n  if (summary === detail) {\n    return { summary };\n  }\n  return { summary, detail };\n}\n__name(createSummaryValue, \"createSummaryValue\");\nvar normalizeNewlines = /* @__PURE__ */ __name((string) => string.replace(/\\\\r\\\\n/g, \"\\\\n\"), \"normalizeNewlines\");\n\n// src/docs-tools/argTypes/docgen/flow/createDefaultValue.ts\nfunction createDefaultValue(defaultValue, type) {\n  if (defaultValue != null) {\n    const { value } = defaultValue;\n    if (!isDefaultValueBlacklisted(value)) {\n      return !isTooLongForDefaultValueSummary(value) ? createSummaryValue(value) : createSummaryValue(type?.name, value);\n    }\n  }\n  return null;\n}\n__name(createDefaultValue, \"createDefaultValue\");\n\n// src/docs-tools/argTypes/docgen/flow/createType.ts\nfunction generateUnionElement({ name, value, elements, raw }) {\n  if (value != null) {\n    return value;\n  }\n  if (elements != null) {\n    return elements.map(generateUnionElement).join(\" | \");\n  }\n  if (raw != null) {\n    return raw;\n  }\n  return name;\n}\n__name(generateUnionElement, \"generateUnionElement\");\nfunction generateUnion({ name, raw, elements }) {\n  if (elements != null) {\n    return createSummaryValue(elements.map(generateUnionElement).join(\" | \"));\n  }\n  if (raw != null) {\n    return createSummaryValue(raw.replace(/^\\|\\s*/, \"\"));\n  }\n  return createSummaryValue(name);\n}\n__name(generateUnion, \"generateUnion\");\nfunction generateFuncSignature({ type, raw }) {\n  if (raw != null) {\n    return createSummaryValue(raw);\n  }\n  return createSummaryValue(type);\n}\n__name(generateFuncSignature, \"generateFuncSignature\");\nfunction generateObjectSignature({ type, raw }) {\n  if (raw != null) {\n    return !isTooLongForTypeSummary(raw) ? createSummaryValue(raw) : createSummaryValue(type, raw);\n  }\n  return createSummaryValue(type);\n}\n__name(generateObjectSignature, \"generateObjectSignature\");\nfunction generateSignature(flowType) {\n  const { type } = flowType;\n  return type === \"object\" ? generateObjectSignature(flowType) : generateFuncSignature(flowType);\n}\n__name(generateSignature, \"generateSignature\");\nfunction generateDefault({ name, raw }) {\n  if (raw != null) {\n    return !isTooLongForTypeSummary(raw) ? createSummaryValue(raw) : createSummaryValue(name, raw);\n  }\n  return createSummaryValue(name);\n}\n__name(generateDefault, \"generateDefault\");\nfunction createType(type) {\n  if (type == null) {\n    return null;\n  }\n  switch (type.name) {\n    case \"union\" /* UNION */:\n      return generateUnion(type);\n    case \"signature\" /* SIGNATURE */:\n      return generateSignature(type);\n    default:\n      return generateDefault(type);\n  }\n}\n__name(createType, \"createType\");\n\n// src/docs-tools/argTypes/docgen/flow/createPropDef.ts\nvar createFlowPropDef = /* @__PURE__ */ __name((propName, docgenInfo) => {\n  const { flowType, description, required, defaultValue } = docgenInfo;\n  return {\n    name: propName,\n    type: createType(flowType),\n    required,\n    description,\n    defaultValue: createDefaultValue(defaultValue ?? null, flowType ?? null)\n  };\n}, \"createFlowPropDef\");\n\n// src/docs-tools/argTypes/docgen/typeScript/createDefaultValue.ts\nfunction createDefaultValue2({ defaultValue }) {\n  if (defaultValue != null) {\n    const { value } = defaultValue;\n    if (!isDefaultValueBlacklisted(value)) {\n      return createSummaryValue(value);\n    }\n  }\n  return null;\n}\n__name(createDefaultValue2, \"createDefaultValue\");\n\n// src/docs-tools/argTypes/docgen/typeScript/createType.ts\nfunction createType2({ tsType, required }) {\n  if (tsType == null) {\n    return null;\n  }\n  let typeName = tsType.name;\n  if (!required) {\n    typeName = typeName.replace(\" | undefined\", \"\");\n  }\n  return createSummaryValue(\n    [\"Array\", \"Record\", \"signature\"].includes(tsType.name) ? tsType.raw : typeName\n  );\n}\n__name(createType2, \"createType\");\n\n// src/docs-tools/argTypes/docgen/typeScript/createPropDef.ts\nvar createTsPropDef = /* @__PURE__ */ __name((propName, docgenInfo) => {\n  const { description, required } = docgenInfo;\n  return {\n    name: propName,\n    type: createType2(docgenInfo),\n    required,\n    description,\n    defaultValue: createDefaultValue2(docgenInfo)\n  };\n}, \"createTsPropDef\");\n\n// src/docs-tools/argTypes/docgen/createPropDef.ts\nfunction createType3(type) {\n  return type != null ? createSummaryValue(type.name) : null;\n}\n__name(createType3, \"createType\");\nfunction isReactDocgenTypescript(defaultValue) {\n  const { computed, func } = defaultValue;\n  return typeof computed === \"undefined\" && typeof func === \"undefined\";\n}\n__name(isReactDocgenTypescript, \"isReactDocgenTypescript\");\nfunction isStringValued(type) {\n  if (!type) {\n    return false;\n  }\n  if (type.name === \"string\") {\n    return true;\n  }\n  if (type.name === \"enum\") {\n    return Array.isArray(type.value) && type.value.every(\n      ({ value: tv }) => typeof tv === \"string\" && tv[0] === '\"' && tv[tv.length - 1] === '\"'\n    );\n  }\n  return false;\n}\n__name(isStringValued, \"isStringValued\");\nfunction createDefaultValue3(defaultValue, type) {\n  if (defaultValue != null) {\n    const { value } = defaultValue;\n    if (!isDefaultValueBlacklisted(value)) {\n      if (isReactDocgenTypescript(defaultValue) && isStringValued(type)) {\n        return createSummaryValue(JSON.stringify(value));\n      }\n      return createSummaryValue(value);\n    }\n  }\n  return null;\n}\n__name(createDefaultValue3, \"createDefaultValue\");\nfunction createBasicPropDef(name, type, docgenInfo) {\n  const { description, required, defaultValue } = docgenInfo;\n  return {\n    name,\n    type: createType3(type),\n    required,\n    description,\n    defaultValue: createDefaultValue3(defaultValue, type)\n  };\n}\n__name(createBasicPropDef, \"createBasicPropDef\");\nfunction applyJsDocResult(propDef, jsDocParsingResult) {\n  if (jsDocParsingResult?.includesJsDoc) {\n    const { description, extractedTags } = jsDocParsingResult;\n    if (description != null) {\n      propDef.description = jsDocParsingResult.description;\n    }\n    const value = {\n      ...extractedTags,\n      params: extractedTags?.params?.map(\n        (x) => ({\n          name: x.getPrettyName(),\n          description: x.description\n        })\n      )\n    };\n    if (Object.values(value).filter(Boolean).length > 0) {\n      propDef.jsDocTags = value;\n    }\n  }\n  return propDef;\n}\n__name(applyJsDocResult, \"applyJsDocResult\");\nvar javaScriptFactory = /* @__PURE__ */ __name((propName, docgenInfo, jsDocParsingResult) => {\n  const propDef = createBasicPropDef(propName, docgenInfo.type, docgenInfo);\n  propDef.sbType = convert4(docgenInfo);\n  return applyJsDocResult(propDef, jsDocParsingResult);\n}, \"javaScriptFactory\");\nvar tsFactory = /* @__PURE__ */ __name((propName, docgenInfo, jsDocParsingResult) => {\n  const propDef = createTsPropDef(propName, docgenInfo);\n  propDef.sbType = convert4(docgenInfo);\n  return applyJsDocResult(propDef, jsDocParsingResult);\n}, \"tsFactory\");\nvar flowFactory = /* @__PURE__ */ __name((propName, docgenInfo, jsDocParsingResult) => {\n  const propDef = createFlowPropDef(propName, docgenInfo);\n  propDef.sbType = convert4(docgenInfo);\n  return applyJsDocResult(propDef, jsDocParsingResult);\n}, \"flowFactory\");\nvar unknownFactory = /* @__PURE__ */ __name((propName, docgenInfo, jsDocParsingResult) => {\n  const propDef = createBasicPropDef(propName, { name: \"unknown\" }, docgenInfo);\n  return applyJsDocResult(propDef, jsDocParsingResult);\n}, \"unknownFactory\");\nvar getPropDefFactory = /* @__PURE__ */ __name((typeSystem) => {\n  switch (typeSystem) {\n    case \"JavaScript\" /* JAVASCRIPT */:\n      return javaScriptFactory;\n    case \"TypeScript\" /* TYPESCRIPT */:\n      return tsFactory;\n    case \"Flow\" /* FLOW */:\n      return flowFactory;\n    default:\n      return unknownFactory;\n  }\n}, \"getPropDefFactory\");\n\n// src/docs-tools/argTypes/docgen/extractDocgenProps.ts\nvar getTypeSystem = /* @__PURE__ */ __name((docgenInfo) => {\n  if (docgenInfo.type != null) {\n    return \"JavaScript\" /* JAVASCRIPT */;\n  }\n  if (docgenInfo.flowType != null) {\n    return \"Flow\" /* FLOW */;\n  }\n  if (docgenInfo.tsType != null) {\n    return \"TypeScript\" /* TYPESCRIPT */;\n  }\n  return \"Unknown\" /* UNKNOWN */;\n}, \"getTypeSystem\");\nvar extractComponentSectionArray = /* @__PURE__ */ __name((docgenSection) => {\n  const typeSystem = getTypeSystem(docgenSection[0]);\n  const createPropDef = getPropDefFactory(typeSystem);\n  return docgenSection.map((item) => {\n    let sanitizedItem = item;\n    if (item.type?.elements) {\n      sanitizedItem = {\n        ...item,\n        type: {\n          ...item.type,\n          value: item.type.elements\n        }\n      };\n    }\n    return extractProp(sanitizedItem.name, sanitizedItem, typeSystem, createPropDef);\n  });\n}, \"extractComponentSectionArray\");\nvar extractComponentSectionObject = /* @__PURE__ */ __name((docgenSection) => {\n  const docgenPropsKeys = Object.keys(docgenSection);\n  const typeSystem = getTypeSystem(docgenSection[docgenPropsKeys[0]]);\n  const createPropDef = getPropDefFactory(typeSystem);\n  return docgenPropsKeys.map((propName) => {\n    const docgenInfo = docgenSection[propName];\n    return docgenInfo != null ? extractProp(propName, docgenInfo, typeSystem, createPropDef) : null;\n  }).filter(Boolean);\n}, \"extractComponentSectionObject\");\nvar extractComponentProps = /* @__PURE__ */ __name((component, section) => {\n  const docgenSection = getDocgenSection(component, section);\n  if (!isValidDocgenSection(docgenSection)) {\n    return [];\n  }\n  return Array.isArray(docgenSection) ? extractComponentSectionArray(docgenSection) : extractComponentSectionObject(docgenSection);\n}, \"extractComponentProps\");\nfunction extractProp(propName, docgenInfo, typeSystem, createPropDef) {\n  const jsDocParsingResult = parseJsDoc(docgenInfo.description);\n  const isIgnored = jsDocParsingResult.includesJsDoc && jsDocParsingResult.ignore;\n  if (!isIgnored) {\n    const propDef = createPropDef(propName, docgenInfo, jsDocParsingResult);\n    return {\n      propDef,\n      jsDocTags: jsDocParsingResult.extractedTags,\n      docgenInfo,\n      typeSystem\n    };\n  }\n  return null;\n}\n__name(extractProp, \"extractProp\");\nfunction extractComponentDescription(component) {\n  return component != null ? getDocgenDescription(component) : \"\";\n}\n__name(extractComponentDescription, \"extractComponentDescription\");\n\n// src/preview-api/modules/store/parameters.ts\nvar combineParameters = /* @__PURE__ */ __name((...parameterSets) => {\n  const mergeKeys = {};\n  const definedParametersSets = parameterSets.filter(Boolean);\n  const combined = definedParametersSets.reduce((acc, parameters) => {\n    Object.entries(parameters).forEach(([key, value]) => {\n      const existing = acc[key];\n      if (Array.isArray(value) || typeof existing === \"undefined\") {\n        acc[key] = value;\n      } else if (isPlainObject(value) && isPlainObject(existing)) {\n        mergeKeys[key] = true;\n      } else if (typeof value !== \"undefined\") {\n        acc[key] = value;\n      }\n    });\n    return acc;\n  }, {});\n  Object.keys(mergeKeys).forEach((key) => {\n    const mergeValues = definedParametersSets.filter(Boolean).map((p) => p[key]).filter((value) => typeof value !== \"undefined\");\n    if (mergeValues.every((value) => isPlainObject(value))) {\n      combined[key] = combineParameters(...mergeValues);\n    } else {\n      combined[key] = mergeValues[mergeValues.length - 1];\n    }\n  });\n  return combined;\n}, \"combineParameters\");\n\n// src/docs-tools/argTypes/enhanceArgTypes.ts\nvar enhanceArgTypes = /* @__PURE__ */ __name((context) => {\n  const {\n    component,\n    argTypes: userArgTypes,\n    parameters: { docs = {} }\n  } = context;\n  const { extractArgTypes } = docs;\n  if (!extractArgTypes || !component) {\n    return userArgTypes;\n  }\n  const extractedArgTypes = extractArgTypes(component);\n  return extractedArgTypes ? combineParameters(extractedArgTypes, userArgTypes) : userArgTypes;\n}, \"enhanceArgTypes\");\n\n// src/docs-tools/shared.ts\nvar ADDON_ID = \"storybook/docs\";\nvar PANEL_ID = `${ADDON_ID}/panel`;\nvar PARAM_KEY = `docs`;\nvar SNIPPET_RENDERED = `${ADDON_ID}/snippet-rendered`;\nvar SourceType = /* @__PURE__ */ ((SourceType2) => {\n  SourceType2[\"AUTO\"] = \"auto\";\n  SourceType2[\"CODE\"] = \"code\";\n  SourceType2[\"DYNAMIC\"] = \"dynamic\";\n  return SourceType2;\n})(SourceType || {});\n\nexport {\n  combineParameters,\n  convert4 as convert,\n  TypeSystem,\n  isDefaultValueBlacklisted,\n  str,\n  hasDocgen,\n  isValidDocgenSection,\n  getDocgenSection,\n  getDocgenDescription,\n  parseJsDoc,\n  MAX_TYPE_SUMMARY_LENGTH,\n  MAX_DEFAULT_VALUE_SUMMARY_LENGTH,\n  isTooLongForTypeSummary,\n  isTooLongForDefaultValueSummary,\n  createSummaryValue,\n  normalizeNewlines,\n  extractComponentSectionArray,\n  extractComponentSectionObject,\n  extractComponentProps,\n  extractComponentDescription,\n  enhanceArgTypes,\n  ADDON_ID,\n  PANEL_ID,\n  PARAM_KEY,\n  SNIPPET_RENDERED,\n  SourceType\n};\n",
      "start": 1762256767131,
      "end": 1762256767132,
      "order": "post",
      "sourcemaps": null
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1762256767132,
      "end": 1762256767133,
      "order": "normal-normal"
    },
    {
      "name": "vite:reporter",
      "start": 1762256767133,
      "end": 1762256767133,
      "order": "normal"
    }
  ]
}
