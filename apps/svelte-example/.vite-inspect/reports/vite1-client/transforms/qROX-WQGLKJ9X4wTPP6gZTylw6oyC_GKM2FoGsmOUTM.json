{
  "resolvedId": "/Users/teimurgasanov/Projects/avatune/node_modules/storybook/dist/_browser-chunks/chunk-JVSKG4YS.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import {\n  __name\n} from \"./chunk-MM7DTO55.js\";\n\n// ../node_modules/tinyrainbow/dist/chunk-BVHSVHOK.js\nvar f = {\n  reset: [0, 0],\n  bold: [1, 22, \"\\x1B[22m\\x1B[1m\"],\n  dim: [2, 22, \"\\x1B[22m\\x1B[2m\"],\n  italic: [3, 23],\n  underline: [4, 24],\n  inverse: [7, 27],\n  hidden: [8, 28],\n  strikethrough: [9, 29],\n  black: [30, 39],\n  red: [31, 39],\n  green: [32, 39],\n  yellow: [33, 39],\n  blue: [34, 39],\n  magenta: [35, 39],\n  cyan: [36, 39],\n  white: [37, 39],\n  gray: [90, 39],\n  bgBlack: [40, 49],\n  bgRed: [41, 49],\n  bgGreen: [42, 49],\n  bgYellow: [43, 49],\n  bgBlue: [44, 49],\n  bgMagenta: [45, 49],\n  bgCyan: [46, 49],\n  bgWhite: [47, 49],\n  blackBright: [90, 39],\n  redBright: [91, 39],\n  greenBright: [92, 39],\n  yellowBright: [93, 39],\n  blueBright: [94, 39],\n  magentaBright: [95, 39],\n  cyanBright: [96, 39],\n  whiteBright: [97, 39],\n  bgBlackBright: [100, 49],\n  bgRedBright: [101, 49],\n  bgGreenBright: [102, 49],\n  bgYellowBright: [103, 49],\n  bgBlueBright: [104, 49],\n  bgMagentaBright: [105, 49],\n  bgCyanBright: [106, 49],\n  bgWhiteBright: [107, 49]\n};\nvar h = Object.entries(f);\nfunction a(n) {\n  return String(n);\n}\n__name(a, \"a\");\na.open = \"\";\na.close = \"\";\nvar B = h.reduce(\n  (n, [e]) => (n[e] = a, n),\n  { isColorSupported: false }\n);\nfunction C(n = false) {\n  let e = typeof process != \"undefined\" ? process : void 0, i = (e == null ? void 0 : e.env) || {}, g = (e == null ? void 0 : e.argv) || [];\n  return !(\"NO_COLOR\" in i || g.includes(\"--no-color\")) && (\"FORCE_COLOR\" in i || g.includes(\"--color\") || (e == null ? void 0 : e.platform) === \"win32\" || n && i.TERM !== \"dumb\" || \"CI\" in i) || typeof window != \"undefined\" && !!window.chrome;\n}\n__name(C, \"C\");\nfunction p(n = false) {\n  let e = C(n), i = /* @__PURE__ */ __name((r, t, c, o) => {\n    let l = \"\", s2 = 0;\n    do\n      l += r.substring(s2, o) + c, s2 = o + t.length, o = r.indexOf(t, s2);\n    while (~o);\n    return l + r.substring(s2);\n  }, \"i\"), g = /* @__PURE__ */ __name((r, t, c = r) => {\n    let o = /* @__PURE__ */ __name((l) => {\n      let s2 = String(l), b = s2.indexOf(t, r.length);\n      return ~b ? r + i(s2, t, c, b) + t : r + s2 + t;\n    }, \"o\");\n    return o.open = r, o.close = t, o;\n  }, \"g\"), u = {\n    isColorSupported: e\n  }, d = /* @__PURE__ */ __name((r) => `\\x1B[${r}m`, \"d\");\n  for (let [r, t] of h)\n    u[r] = e ? g(\n      d(t[0]),\n      d(t[1]),\n      t[2]\n    ) : a;\n  return u;\n}\n__name(p, \"p\");\n\n// ../node_modules/tinyrainbow/dist/browser.js\nvar s = p();\n\n// ../node_modules/@vitest/pretty-format/dist/index.js\nfunction _mergeNamespaces(n, m2) {\n  m2.forEach(function(e) {\n    e && typeof e !== \"string\" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n      if (k !== \"default\" && !(k in n)) {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: /* @__PURE__ */ __name(function() {\n            return e[k];\n          }, \"get\")\n        });\n      }\n    });\n  });\n  return Object.freeze(n);\n}\n__name(_mergeNamespaces, \"_mergeNamespaces\");\nfunction getKeysOfEnumerableProperties(object, compareKeys) {\n  const rawKeys = Object.keys(object);\n  const keys = compareKeys === null ? rawKeys : rawKeys.sort(compareKeys);\n  if (Object.getOwnPropertySymbols) {\n    for (const symbol of Object.getOwnPropertySymbols(object)) {\n      if (Object.getOwnPropertyDescriptor(object, symbol).enumerable) {\n        keys.push(symbol);\n      }\n    }\n  }\n  return keys;\n}\n__name(getKeysOfEnumerableProperties, \"getKeysOfEnumerableProperties\");\nfunction printIteratorEntries(iterator, config, indentation, depth, refs, printer2, separator = \": \") {\n  let result = \"\";\n  let width = 0;\n  let current = iterator.next();\n  if (!current.done) {\n    result += config.spacingOuter;\n    const indentationNext = indentation + config.indent;\n    while (!current.done) {\n      result += indentationNext;\n      if (width++ === config.maxWidth) {\n        result += \"\\u2026\";\n        break;\n      }\n      const name = printer2(current.value[0], config, indentationNext, depth, refs);\n      const value = printer2(current.value[1], config, indentationNext, depth, refs);\n      result += name + separator + value;\n      current = iterator.next();\n      if (!current.done) {\n        result += `,${config.spacingInner}`;\n      } else if (!config.min) {\n        result += \",\";\n      }\n    }\n    result += config.spacingOuter + indentation;\n  }\n  return result;\n}\n__name(printIteratorEntries, \"printIteratorEntries\");\nfunction printIteratorValues(iterator, config, indentation, depth, refs, printer2) {\n  let result = \"\";\n  let width = 0;\n  let current = iterator.next();\n  if (!current.done) {\n    result += config.spacingOuter;\n    const indentationNext = indentation + config.indent;\n    while (!current.done) {\n      result += indentationNext;\n      if (width++ === config.maxWidth) {\n        result += \"\\u2026\";\n        break;\n      }\n      result += printer2(current.value, config, indentationNext, depth, refs);\n      current = iterator.next();\n      if (!current.done) {\n        result += `,${config.spacingInner}`;\n      } else if (!config.min) {\n        result += \",\";\n      }\n    }\n    result += config.spacingOuter + indentation;\n  }\n  return result;\n}\n__name(printIteratorValues, \"printIteratorValues\");\nfunction printListItems(list, config, indentation, depth, refs, printer2) {\n  let result = \"\";\n  list = list instanceof ArrayBuffer ? new DataView(list) : list;\n  const isDataView = /* @__PURE__ */ __name((l) => l instanceof DataView, \"isDataView\");\n  const length = isDataView(list) ? list.byteLength : list.length;\n  if (length > 0) {\n    result += config.spacingOuter;\n    const indentationNext = indentation + config.indent;\n    for (let i = 0; i < length; i++) {\n      result += indentationNext;\n      if (i === config.maxWidth) {\n        result += \"\\u2026\";\n        break;\n      }\n      if (isDataView(list) || i in list) {\n        result += printer2(isDataView(list) ? list.getInt8(i) : list[i], config, indentationNext, depth, refs);\n      }\n      if (i < length - 1) {\n        result += `,${config.spacingInner}`;\n      } else if (!config.min) {\n        result += \",\";\n      }\n    }\n    result += config.spacingOuter + indentation;\n  }\n  return result;\n}\n__name(printListItems, \"printListItems\");\nfunction printObjectProperties(val, config, indentation, depth, refs, printer2) {\n  let result = \"\";\n  const keys = getKeysOfEnumerableProperties(val, config.compareKeys);\n  if (keys.length > 0) {\n    result += config.spacingOuter;\n    const indentationNext = indentation + config.indent;\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const name = printer2(key, config, indentationNext, depth, refs);\n      const value = printer2(val[key], config, indentationNext, depth, refs);\n      result += `${indentationNext + name}: ${value}`;\n      if (i < keys.length - 1) {\n        result += `,${config.spacingInner}`;\n      } else if (!config.min) {\n        result += \",\";\n      }\n    }\n    result += config.spacingOuter + indentation;\n  }\n  return result;\n}\n__name(printObjectProperties, \"printObjectProperties\");\nvar asymmetricMatcher = typeof Symbol === \"function\" && Symbol.for ? Symbol.for(\"jest.asymmetricMatcher\") : 1267621;\nvar SPACE$2 = \" \";\nvar serialize$5 = /* @__PURE__ */ __name((val, config, indentation, depth, refs, printer2) => {\n  const stringedValue = val.toString();\n  if (stringedValue === \"ArrayContaining\" || stringedValue === \"ArrayNotContaining\") {\n    if (++depth > config.maxDepth) {\n      return `[${stringedValue}]`;\n    }\n    return `${stringedValue + SPACE$2}[${printListItems(val.sample, config, indentation, depth, refs, printer2)}]`;\n  }\n  if (stringedValue === \"ObjectContaining\" || stringedValue === \"ObjectNotContaining\") {\n    if (++depth > config.maxDepth) {\n      return `[${stringedValue}]`;\n    }\n    return `${stringedValue + SPACE$2}{${printObjectProperties(val.sample, config, indentation, depth, refs, printer2)}}`;\n  }\n  if (stringedValue === \"StringMatching\" || stringedValue === \"StringNotMatching\") {\n    return stringedValue + SPACE$2 + printer2(val.sample, config, indentation, depth, refs);\n  }\n  if (stringedValue === \"StringContaining\" || stringedValue === \"StringNotContaining\") {\n    return stringedValue + SPACE$2 + printer2(val.sample, config, indentation, depth, refs);\n  }\n  if (typeof val.toAsymmetricMatcher !== \"function\") {\n    throw new TypeError(`Asymmetric matcher ${val.constructor.name} does not implement toAsymmetricMatcher()`);\n  }\n  return val.toAsymmetricMatcher();\n}, \"serialize$5\");\nvar test$5 = /* @__PURE__ */ __name((val) => val && val.$$typeof === asymmetricMatcher, \"test$5\");\nvar plugin$5 = {\n  serialize: serialize$5,\n  test: test$5\n};\nvar SPACE$1 = \" \";\nvar OBJECT_NAMES = /* @__PURE__ */ new Set([\"DOMStringMap\", \"NamedNodeMap\"]);\nvar ARRAY_REGEXP = /^(?:HTML\\w*Collection|NodeList)$/;\nfunction testName(name) {\n  return OBJECT_NAMES.has(name) || ARRAY_REGEXP.test(name);\n}\n__name(testName, \"testName\");\nvar test$4 = /* @__PURE__ */ __name((val) => val && val.constructor && !!val.constructor.name && testName(val.constructor.name), \"test$4\");\nfunction isNamedNodeMap(collection) {\n  return collection.constructor.name === \"NamedNodeMap\";\n}\n__name(isNamedNodeMap, \"isNamedNodeMap\");\nvar serialize$4 = /* @__PURE__ */ __name((collection, config, indentation, depth, refs, printer2) => {\n  const name = collection.constructor.name;\n  if (++depth > config.maxDepth) {\n    return `[${name}]`;\n  }\n  return (config.min ? \"\" : name + SPACE$1) + (OBJECT_NAMES.has(name) ? `{${printObjectProperties(isNamedNodeMap(collection) ? [...collection].reduce((props, attribute) => {\n    props[attribute.name] = attribute.value;\n    return props;\n  }, {}) : { ...collection }, config, indentation, depth, refs, printer2)}}` : `[${printListItems([...collection], config, indentation, depth, refs, printer2)}]`);\n}, \"serialize$4\");\nvar plugin$4 = {\n  serialize: serialize$4,\n  test: test$4\n};\nfunction escapeHTML(str) {\n  return str.replaceAll(\"<\", \"&lt;\").replaceAll(\">\", \"&gt;\");\n}\n__name(escapeHTML, \"escapeHTML\");\nfunction printProps(keys, props, config, indentation, depth, refs, printer2) {\n  const indentationNext = indentation + config.indent;\n  const colors = config.colors;\n  return keys.map((key) => {\n    const value = props[key];\n    let printed = printer2(value, config, indentationNext, depth, refs);\n    if (typeof value !== \"string\") {\n      if (printed.includes(\"\\n\")) {\n        printed = config.spacingOuter + indentationNext + printed + config.spacingOuter + indentation;\n      }\n      printed = `{${printed}}`;\n    }\n    return `${config.spacingInner + indentation + colors.prop.open + key + colors.prop.close}=${colors.value.open}${printed}${colors.value.close}`;\n  }).join(\"\");\n}\n__name(printProps, \"printProps\");\nfunction printChildren(children, config, indentation, depth, refs, printer2) {\n  return children.map((child) => config.spacingOuter + indentation + (typeof child === \"string\" ? printText(child, config) : printer2(child, config, indentation, depth, refs))).join(\"\");\n}\n__name(printChildren, \"printChildren\");\nfunction printText(text, config) {\n  const contentColor = config.colors.content;\n  return contentColor.open + escapeHTML(text) + contentColor.close;\n}\n__name(printText, \"printText\");\nfunction printComment(comment, config) {\n  const commentColor = config.colors.comment;\n  return `${commentColor.open}<!--${escapeHTML(comment)}-->${commentColor.close}`;\n}\n__name(printComment, \"printComment\");\nfunction printElement(type, printedProps, printedChildren, config, indentation) {\n  const tagColor = config.colors.tag;\n  return `${tagColor.open}<${type}${printedProps && tagColor.close + printedProps + config.spacingOuter + indentation + tagColor.open}${printedChildren ? `>${tagColor.close}${printedChildren}${config.spacingOuter}${indentation}${tagColor.open}</${type}` : `${printedProps && !config.min ? \"\" : \" \"}/`}>${tagColor.close}`;\n}\n__name(printElement, \"printElement\");\nfunction printElementAsLeaf(type, config) {\n  const tagColor = config.colors.tag;\n  return `${tagColor.open}<${type}${tagColor.close} \\u2026${tagColor.open} />${tagColor.close}`;\n}\n__name(printElementAsLeaf, \"printElementAsLeaf\");\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\nvar FRAGMENT_NODE = 11;\nvar ELEMENT_REGEXP = /^(?:(?:HTML|SVG)\\w*)?Element$/;\nfunction testHasAttribute(val) {\n  try {\n    return typeof val.hasAttribute === \"function\" && val.hasAttribute(\"is\");\n  } catch {\n    return false;\n  }\n}\n__name(testHasAttribute, \"testHasAttribute\");\nfunction testNode(val) {\n  const constructorName = val.constructor.name;\n  const { nodeType, tagName } = val;\n  const isCustomElement = typeof tagName === \"string\" && tagName.includes(\"-\") || testHasAttribute(val);\n  return nodeType === ELEMENT_NODE && (ELEMENT_REGEXP.test(constructorName) || isCustomElement) || nodeType === TEXT_NODE && constructorName === \"Text\" || nodeType === COMMENT_NODE && constructorName === \"Comment\" || nodeType === FRAGMENT_NODE && constructorName === \"DocumentFragment\";\n}\n__name(testNode, \"testNode\");\nvar test$3 = /* @__PURE__ */ __name((val) => {\n  var _val$constructor;\n  return (val === null || val === void 0 || (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) && testNode(val);\n}, \"test$3\");\nfunction nodeIsText(node) {\n  return node.nodeType === TEXT_NODE;\n}\n__name(nodeIsText, \"nodeIsText\");\nfunction nodeIsComment(node) {\n  return node.nodeType === COMMENT_NODE;\n}\n__name(nodeIsComment, \"nodeIsComment\");\nfunction nodeIsFragment(node) {\n  return node.nodeType === FRAGMENT_NODE;\n}\n__name(nodeIsFragment, \"nodeIsFragment\");\nvar serialize$3 = /* @__PURE__ */ __name((node, config, indentation, depth, refs, printer2) => {\n  if (nodeIsText(node)) {\n    return printText(node.data, config);\n  }\n  if (nodeIsComment(node)) {\n    return printComment(node.data, config);\n  }\n  const type = nodeIsFragment(node) ? \"DocumentFragment\" : node.tagName.toLowerCase();\n  if (++depth > config.maxDepth) {\n    return printElementAsLeaf(type, config);\n  }\n  return printElement(type, printProps(nodeIsFragment(node) ? [] : Array.from(node.attributes, (attr) => attr.name).sort(), nodeIsFragment(node) ? {} : [...node.attributes].reduce((props, attribute) => {\n    props[attribute.name] = attribute.value;\n    return props;\n  }, {}), config, indentation + config.indent, depth, refs, printer2), printChildren(Array.prototype.slice.call(node.childNodes || node.children), config, indentation + config.indent, depth, refs, printer2), config, indentation);\n}, \"serialize$3\");\nvar plugin$3 = {\n  serialize: serialize$3,\n  test: test$3\n};\nvar IS_ITERABLE_SENTINEL = \"@@__IMMUTABLE_ITERABLE__@@\";\nvar IS_LIST_SENTINEL = \"@@__IMMUTABLE_LIST__@@\";\nvar IS_KEYED_SENTINEL = \"@@__IMMUTABLE_KEYED__@@\";\nvar IS_MAP_SENTINEL = \"@@__IMMUTABLE_MAP__@@\";\nvar IS_ORDERED_SENTINEL = \"@@__IMMUTABLE_ORDERED__@@\";\nvar IS_RECORD_SENTINEL = \"@@__IMMUTABLE_RECORD__@@\";\nvar IS_SEQ_SENTINEL = \"@@__IMMUTABLE_SEQ__@@\";\nvar IS_SET_SENTINEL = \"@@__IMMUTABLE_SET__@@\";\nvar IS_STACK_SENTINEL = \"@@__IMMUTABLE_STACK__@@\";\nvar getImmutableName = /* @__PURE__ */ __name((name) => `Immutable.${name}`, \"getImmutableName\");\nvar printAsLeaf = /* @__PURE__ */ __name((name) => `[${name}]`, \"printAsLeaf\");\nvar SPACE = \" \";\nvar LAZY = \"\\u2026\";\nfunction printImmutableEntries(val, config, indentation, depth, refs, printer2, type) {\n  return ++depth > config.maxDepth ? printAsLeaf(getImmutableName(type)) : `${getImmutableName(type) + SPACE}{${printIteratorEntries(val.entries(), config, indentation, depth, refs, printer2)}}`;\n}\n__name(printImmutableEntries, \"printImmutableEntries\");\nfunction getRecordEntries(val) {\n  let i = 0;\n  return { next() {\n    if (i < val._keys.length) {\n      const key = val._keys[i++];\n      return {\n        done: false,\n        value: [key, val.get(key)]\n      };\n    }\n    return {\n      done: true,\n      value: void 0\n    };\n  } };\n}\n__name(getRecordEntries, \"getRecordEntries\");\nfunction printImmutableRecord(val, config, indentation, depth, refs, printer2) {\n  const name = getImmutableName(val._name || \"Record\");\n  return ++depth > config.maxDepth ? printAsLeaf(name) : `${name + SPACE}{${printIteratorEntries(getRecordEntries(val), config, indentation, depth, refs, printer2)}}`;\n}\n__name(printImmutableRecord, \"printImmutableRecord\");\nfunction printImmutableSeq(val, config, indentation, depth, refs, printer2) {\n  const name = getImmutableName(\"Seq\");\n  if (++depth > config.maxDepth) {\n    return printAsLeaf(name);\n  }\n  if (val[IS_KEYED_SENTINEL]) {\n    return `${name + SPACE}{${val._iter || val._object ? printIteratorEntries(val.entries(), config, indentation, depth, refs, printer2) : LAZY}}`;\n  }\n  return `${name + SPACE}[${val._iter || val._array || val._collection || val._iterable ? printIteratorValues(val.values(), config, indentation, depth, refs, printer2) : LAZY}]`;\n}\n__name(printImmutableSeq, \"printImmutableSeq\");\nfunction printImmutableValues(val, config, indentation, depth, refs, printer2, type) {\n  return ++depth > config.maxDepth ? printAsLeaf(getImmutableName(type)) : `${getImmutableName(type) + SPACE}[${printIteratorValues(val.values(), config, indentation, depth, refs, printer2)}]`;\n}\n__name(printImmutableValues, \"printImmutableValues\");\nvar serialize$2 = /* @__PURE__ */ __name((val, config, indentation, depth, refs, printer2) => {\n  if (val[IS_MAP_SENTINEL]) {\n    return printImmutableEntries(val, config, indentation, depth, refs, printer2, val[IS_ORDERED_SENTINEL] ? \"OrderedMap\" : \"Map\");\n  }\n  if (val[IS_LIST_SENTINEL]) {\n    return printImmutableValues(val, config, indentation, depth, refs, printer2, \"List\");\n  }\n  if (val[IS_SET_SENTINEL]) {\n    return printImmutableValues(val, config, indentation, depth, refs, printer2, val[IS_ORDERED_SENTINEL] ? \"OrderedSet\" : \"Set\");\n  }\n  if (val[IS_STACK_SENTINEL]) {\n    return printImmutableValues(val, config, indentation, depth, refs, printer2, \"Stack\");\n  }\n  if (val[IS_SEQ_SENTINEL]) {\n    return printImmutableSeq(val, config, indentation, depth, refs, printer2);\n  }\n  return printImmutableRecord(val, config, indentation, depth, refs, printer2);\n}, \"serialize$2\");\nvar test$2 = /* @__PURE__ */ __name((val) => val && (val[IS_ITERABLE_SENTINEL] === true || val[IS_RECORD_SENTINEL] === true), \"test$2\");\nvar plugin$2 = {\n  serialize: serialize$2,\n  test: test$2\n};\nfunction getDefaultExportFromCjs(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\n__name(getDefaultExportFromCjs, \"getDefaultExportFromCjs\");\nvar reactIs$1 = { exports: {} };\nvar reactIs_production = {};\nvar hasRequiredReactIs_production;\nfunction requireReactIs_production() {\n  if (hasRequiredReactIs_production) return reactIs_production;\n  hasRequiredReactIs_production = 1;\n  var REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"), REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"), REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"), REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"), REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n  var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"), REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"), REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"), REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"), REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"), REACT_MEMO_TYPE = Symbol.for(\"react.memo\"), REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"), REACT_VIEW_TRANSITION_TYPE = Symbol.for(\"react.view_transition\"), REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n  function typeOf(object) {\n    if (\"object\" === typeof object && null !== object) {\n      var $$typeof = object.$$typeof;\n      switch ($$typeof) {\n        case REACT_ELEMENT_TYPE:\n          switch (object = object.type, object) {\n            case REACT_FRAGMENT_TYPE:\n            case REACT_PROFILER_TYPE:\n            case REACT_STRICT_MODE_TYPE:\n            case REACT_SUSPENSE_TYPE:\n            case REACT_SUSPENSE_LIST_TYPE:\n            case REACT_VIEW_TRANSITION_TYPE:\n              return object;\n            default:\n              switch (object = object && object.$$typeof, object) {\n                case REACT_CONTEXT_TYPE:\n                case REACT_FORWARD_REF_TYPE:\n                case REACT_LAZY_TYPE:\n                case REACT_MEMO_TYPE:\n                  return object;\n                case REACT_CONSUMER_TYPE:\n                  return object;\n                default:\n                  return $$typeof;\n              }\n          }\n        case REACT_PORTAL_TYPE:\n          return $$typeof;\n      }\n    }\n  }\n  __name(typeOf, \"typeOf\");\n  reactIs_production.ContextConsumer = REACT_CONSUMER_TYPE;\n  reactIs_production.ContextProvider = REACT_CONTEXT_TYPE;\n  reactIs_production.Element = REACT_ELEMENT_TYPE;\n  reactIs_production.ForwardRef = REACT_FORWARD_REF_TYPE;\n  reactIs_production.Fragment = REACT_FRAGMENT_TYPE;\n  reactIs_production.Lazy = REACT_LAZY_TYPE;\n  reactIs_production.Memo = REACT_MEMO_TYPE;\n  reactIs_production.Portal = REACT_PORTAL_TYPE;\n  reactIs_production.Profiler = REACT_PROFILER_TYPE;\n  reactIs_production.StrictMode = REACT_STRICT_MODE_TYPE;\n  reactIs_production.Suspense = REACT_SUSPENSE_TYPE;\n  reactIs_production.SuspenseList = REACT_SUSPENSE_LIST_TYPE;\n  reactIs_production.isContextConsumer = function(object) {\n    return typeOf(object) === REACT_CONSUMER_TYPE;\n  };\n  reactIs_production.isContextProvider = function(object) {\n    return typeOf(object) === REACT_CONTEXT_TYPE;\n  };\n  reactIs_production.isElement = function(object) {\n    return \"object\" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;\n  };\n  reactIs_production.isForwardRef = function(object) {\n    return typeOf(object) === REACT_FORWARD_REF_TYPE;\n  };\n  reactIs_production.isFragment = function(object) {\n    return typeOf(object) === REACT_FRAGMENT_TYPE;\n  };\n  reactIs_production.isLazy = function(object) {\n    return typeOf(object) === REACT_LAZY_TYPE;\n  };\n  reactIs_production.isMemo = function(object) {\n    return typeOf(object) === REACT_MEMO_TYPE;\n  };\n  reactIs_production.isPortal = function(object) {\n    return typeOf(object) === REACT_PORTAL_TYPE;\n  };\n  reactIs_production.isProfiler = function(object) {\n    return typeOf(object) === REACT_PROFILER_TYPE;\n  };\n  reactIs_production.isStrictMode = function(object) {\n    return typeOf(object) === REACT_STRICT_MODE_TYPE;\n  };\n  reactIs_production.isSuspense = function(object) {\n    return typeOf(object) === REACT_SUSPENSE_TYPE;\n  };\n  reactIs_production.isSuspenseList = function(object) {\n    return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;\n  };\n  reactIs_production.isValidElementType = function(type) {\n    return \"string\" === typeof type || \"function\" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || \"object\" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? true : false;\n  };\n  reactIs_production.typeOf = typeOf;\n  return reactIs_production;\n}\n__name(requireReactIs_production, \"requireReactIs_production\");\nvar reactIs_development$1 = {};\nvar hasRequiredReactIs_development$1;\nfunction requireReactIs_development$1() {\n  if (hasRequiredReactIs_development$1) return reactIs_development$1;\n  hasRequiredReactIs_development$1 = 1;\n  \"production\" !== process.env.NODE_ENV && function() {\n    function typeOf(object) {\n      if (\"object\" === typeof object && null !== object) {\n        var $$typeof = object.$$typeof;\n        switch ($$typeof) {\n          case REACT_ELEMENT_TYPE:\n            switch (object = object.type, object) {\n              case REACT_FRAGMENT_TYPE:\n              case REACT_PROFILER_TYPE:\n              case REACT_STRICT_MODE_TYPE:\n              case REACT_SUSPENSE_TYPE:\n              case REACT_SUSPENSE_LIST_TYPE:\n              case REACT_VIEW_TRANSITION_TYPE:\n                return object;\n              default:\n                switch (object = object && object.$$typeof, object) {\n                  case REACT_CONTEXT_TYPE:\n                  case REACT_FORWARD_REF_TYPE:\n                  case REACT_LAZY_TYPE:\n                  case REACT_MEMO_TYPE:\n                    return object;\n                  case REACT_CONSUMER_TYPE:\n                    return object;\n                  default:\n                    return $$typeof;\n                }\n            }\n          case REACT_PORTAL_TYPE:\n            return $$typeof;\n        }\n      }\n    }\n    __name(typeOf, \"typeOf\");\n    var REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"), REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"), REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"), REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"), REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"), REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"), REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"), REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"), REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"), REACT_MEMO_TYPE = Symbol.for(\"react.memo\"), REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"), REACT_VIEW_TRANSITION_TYPE = Symbol.for(\"react.view_transition\"), REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n    reactIs_development$1.ContextConsumer = REACT_CONSUMER_TYPE;\n    reactIs_development$1.ContextProvider = REACT_CONTEXT_TYPE;\n    reactIs_development$1.Element = REACT_ELEMENT_TYPE;\n    reactIs_development$1.ForwardRef = REACT_FORWARD_REF_TYPE;\n    reactIs_development$1.Fragment = REACT_FRAGMENT_TYPE;\n    reactIs_development$1.Lazy = REACT_LAZY_TYPE;\n    reactIs_development$1.Memo = REACT_MEMO_TYPE;\n    reactIs_development$1.Portal = REACT_PORTAL_TYPE;\n    reactIs_development$1.Profiler = REACT_PROFILER_TYPE;\n    reactIs_development$1.StrictMode = REACT_STRICT_MODE_TYPE;\n    reactIs_development$1.Suspense = REACT_SUSPENSE_TYPE;\n    reactIs_development$1.SuspenseList = REACT_SUSPENSE_LIST_TYPE;\n    reactIs_development$1.isContextConsumer = function(object) {\n      return typeOf(object) === REACT_CONSUMER_TYPE;\n    };\n    reactIs_development$1.isContextProvider = function(object) {\n      return typeOf(object) === REACT_CONTEXT_TYPE;\n    };\n    reactIs_development$1.isElement = function(object) {\n      return \"object\" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;\n    };\n    reactIs_development$1.isForwardRef = function(object) {\n      return typeOf(object) === REACT_FORWARD_REF_TYPE;\n    };\n    reactIs_development$1.isFragment = function(object) {\n      return typeOf(object) === REACT_FRAGMENT_TYPE;\n    };\n    reactIs_development$1.isLazy = function(object) {\n      return typeOf(object) === REACT_LAZY_TYPE;\n    };\n    reactIs_development$1.isMemo = function(object) {\n      return typeOf(object) === REACT_MEMO_TYPE;\n    };\n    reactIs_development$1.isPortal = function(object) {\n      return typeOf(object) === REACT_PORTAL_TYPE;\n    };\n    reactIs_development$1.isProfiler = function(object) {\n      return typeOf(object) === REACT_PROFILER_TYPE;\n    };\n    reactIs_development$1.isStrictMode = function(object) {\n      return typeOf(object) === REACT_STRICT_MODE_TYPE;\n    };\n    reactIs_development$1.isSuspense = function(object) {\n      return typeOf(object) === REACT_SUSPENSE_TYPE;\n    };\n    reactIs_development$1.isSuspenseList = function(object) {\n      return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;\n    };\n    reactIs_development$1.isValidElementType = function(type) {\n      return \"string\" === typeof type || \"function\" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || \"object\" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? true : false;\n    };\n    reactIs_development$1.typeOf = typeOf;\n  }();\n  return reactIs_development$1;\n}\n__name(requireReactIs_development$1, \"requireReactIs_development$1\");\nvar hasRequiredReactIs$1;\nfunction requireReactIs$1() {\n  if (hasRequiredReactIs$1) return reactIs$1.exports;\n  hasRequiredReactIs$1 = 1;\n  if (process.env.NODE_ENV === \"production\") {\n    reactIs$1.exports = requireReactIs_production();\n  } else {\n    reactIs$1.exports = requireReactIs_development$1();\n  }\n  return reactIs$1.exports;\n}\n__name(requireReactIs$1, \"requireReactIs$1\");\nvar reactIsExports$1 = requireReactIs$1();\nvar index$1 = getDefaultExportFromCjs(reactIsExports$1);\nvar ReactIs19 = _mergeNamespaces({\n  __proto__: null,\n  default: index$1\n}, [reactIsExports$1]);\nvar reactIs = { exports: {} };\nvar reactIs_production_min = {};\nvar hasRequiredReactIs_production_min;\nfunction requireReactIs_production_min() {\n  if (hasRequiredReactIs_production_min) return reactIs_production_min;\n  hasRequiredReactIs_production_min = 1;\n  var b = Symbol.for(\"react.element\"), c = Symbol.for(\"react.portal\"), d = Symbol.for(\"react.fragment\"), e = Symbol.for(\"react.strict_mode\"), f2 = Symbol.for(\"react.profiler\"), g = Symbol.for(\"react.provider\"), h2 = Symbol.for(\"react.context\"), k = Symbol.for(\"react.server_context\"), l = Symbol.for(\"react.forward_ref\"), m2 = Symbol.for(\"react.suspense\"), n = Symbol.for(\"react.suspense_list\"), p2 = Symbol.for(\"react.memo\"), q = Symbol.for(\"react.lazy\"), t = Symbol.for(\"react.offscreen\"), u;\n  u = Symbol.for(\"react.module.reference\");\n  function v(a2) {\n    if (\"object\" === typeof a2 && null !== a2) {\n      var r = a2.$$typeof;\n      switch (r) {\n        case b:\n          switch (a2 = a2.type, a2) {\n            case d:\n            case f2:\n            case e:\n            case m2:\n            case n:\n              return a2;\n            default:\n              switch (a2 = a2 && a2.$$typeof, a2) {\n                case k:\n                case h2:\n                case l:\n                case q:\n                case p2:\n                case g:\n                  return a2;\n                default:\n                  return r;\n              }\n          }\n        case c:\n          return r;\n      }\n    }\n  }\n  __name(v, \"v\");\n  reactIs_production_min.ContextConsumer = h2;\n  reactIs_production_min.ContextProvider = g;\n  reactIs_production_min.Element = b;\n  reactIs_production_min.ForwardRef = l;\n  reactIs_production_min.Fragment = d;\n  reactIs_production_min.Lazy = q;\n  reactIs_production_min.Memo = p2;\n  reactIs_production_min.Portal = c;\n  reactIs_production_min.Profiler = f2;\n  reactIs_production_min.StrictMode = e;\n  reactIs_production_min.Suspense = m2;\n  reactIs_production_min.SuspenseList = n;\n  reactIs_production_min.isAsyncMode = function() {\n    return false;\n  };\n  reactIs_production_min.isConcurrentMode = function() {\n    return false;\n  };\n  reactIs_production_min.isContextConsumer = function(a2) {\n    return v(a2) === h2;\n  };\n  reactIs_production_min.isContextProvider = function(a2) {\n    return v(a2) === g;\n  };\n  reactIs_production_min.isElement = function(a2) {\n    return \"object\" === typeof a2 && null !== a2 && a2.$$typeof === b;\n  };\n  reactIs_production_min.isForwardRef = function(a2) {\n    return v(a2) === l;\n  };\n  reactIs_production_min.isFragment = function(a2) {\n    return v(a2) === d;\n  };\n  reactIs_production_min.isLazy = function(a2) {\n    return v(a2) === q;\n  };\n  reactIs_production_min.isMemo = function(a2) {\n    return v(a2) === p2;\n  };\n  reactIs_production_min.isPortal = function(a2) {\n    return v(a2) === c;\n  };\n  reactIs_production_min.isProfiler = function(a2) {\n    return v(a2) === f2;\n  };\n  reactIs_production_min.isStrictMode = function(a2) {\n    return v(a2) === e;\n  };\n  reactIs_production_min.isSuspense = function(a2) {\n    return v(a2) === m2;\n  };\n  reactIs_production_min.isSuspenseList = function(a2) {\n    return v(a2) === n;\n  };\n  reactIs_production_min.isValidElementType = function(a2) {\n    return \"string\" === typeof a2 || \"function\" === typeof a2 || a2 === d || a2 === f2 || a2 === e || a2 === m2 || a2 === n || a2 === t || \"object\" === typeof a2 && null !== a2 && (a2.$$typeof === q || a2.$$typeof === p2 || a2.$$typeof === g || a2.$$typeof === h2 || a2.$$typeof === l || a2.$$typeof === u || void 0 !== a2.getModuleId) ? true : false;\n  };\n  reactIs_production_min.typeOf = v;\n  return reactIs_production_min;\n}\n__name(requireReactIs_production_min, \"requireReactIs_production_min\");\nvar reactIs_development = {};\nvar hasRequiredReactIs_development;\nfunction requireReactIs_development() {\n  if (hasRequiredReactIs_development) return reactIs_development;\n  hasRequiredReactIs_development = 1;\n  if (process.env.NODE_ENV !== \"production\") {\n    (function() {\n      var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n      var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n      var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n      var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n      var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n      var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n      var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n      var REACT_SERVER_CONTEXT_TYPE = Symbol.for(\"react.server_context\");\n      var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n      var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n      var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n      var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n      var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n      var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n      var enableScopeAPI = false;\n      var enableCacheElement = false;\n      var enableTransitionTracing = false;\n      var enableLegacyHidden = false;\n      var enableDebugTracing = false;\n      var REACT_MODULE_REFERENCE;\n      {\n        REACT_MODULE_REFERENCE = Symbol.for(\"react.module.reference\");\n      }\n      function isValidElementType(type) {\n        if (typeof type === \"string\" || typeof type === \"function\") {\n          return true;\n        }\n        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n          return true;\n        }\n        if (typeof type === \"object\" && type !== null) {\n          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n          // types supported by any Flight configuration anywhere since\n          // we don't know which Flight build this will end up being used\n          // with.\n          type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {\n            return true;\n          }\n        }\n        return false;\n      }\n      __name(isValidElementType, \"isValidElementType\");\n      function typeOf(object) {\n        if (typeof object === \"object\" && object !== null) {\n          var $$typeof = object.$$typeof;\n          switch ($$typeof) {\n            case REACT_ELEMENT_TYPE:\n              var type = object.type;\n              switch (type) {\n                case REACT_FRAGMENT_TYPE:\n                case REACT_PROFILER_TYPE:\n                case REACT_STRICT_MODE_TYPE:\n                case REACT_SUSPENSE_TYPE:\n                case REACT_SUSPENSE_LIST_TYPE:\n                  return type;\n                default:\n                  var $$typeofType = type && type.$$typeof;\n                  switch ($$typeofType) {\n                    case REACT_SERVER_CONTEXT_TYPE:\n                    case REACT_CONTEXT_TYPE:\n                    case REACT_FORWARD_REF_TYPE:\n                    case REACT_LAZY_TYPE:\n                    case REACT_MEMO_TYPE:\n                    case REACT_PROVIDER_TYPE:\n                      return $$typeofType;\n                    default:\n                      return $$typeof;\n                  }\n              }\n            case REACT_PORTAL_TYPE:\n              return $$typeof;\n          }\n        }\n        return void 0;\n      }\n      __name(typeOf, \"typeOf\");\n      var ContextConsumer = REACT_CONTEXT_TYPE;\n      var ContextProvider = REACT_PROVIDER_TYPE;\n      var Element2 = REACT_ELEMENT_TYPE;\n      var ForwardRef = REACT_FORWARD_REF_TYPE;\n      var Fragment = REACT_FRAGMENT_TYPE;\n      var Lazy = REACT_LAZY_TYPE;\n      var Memo = REACT_MEMO_TYPE;\n      var Portal = REACT_PORTAL_TYPE;\n      var Profiler = REACT_PROFILER_TYPE;\n      var StrictMode = REACT_STRICT_MODE_TYPE;\n      var Suspense = REACT_SUSPENSE_TYPE;\n      var SuspenseList = REACT_SUSPENSE_LIST_TYPE;\n      var hasWarnedAboutDeprecatedIsAsyncMode = false;\n      var hasWarnedAboutDeprecatedIsConcurrentMode = false;\n      function isAsyncMode(object) {\n        {\n          if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n            hasWarnedAboutDeprecatedIsAsyncMode = true;\n            console[\"warn\"](\"The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.\");\n          }\n        }\n        return false;\n      }\n      __name(isAsyncMode, \"isAsyncMode\");\n      function isConcurrentMode(object) {\n        {\n          if (!hasWarnedAboutDeprecatedIsConcurrentMode) {\n            hasWarnedAboutDeprecatedIsConcurrentMode = true;\n            console[\"warn\"](\"The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.\");\n          }\n        }\n        return false;\n      }\n      __name(isConcurrentMode, \"isConcurrentMode\");\n      function isContextConsumer(object) {\n        return typeOf(object) === REACT_CONTEXT_TYPE;\n      }\n      __name(isContextConsumer, \"isContextConsumer\");\n      function isContextProvider(object) {\n        return typeOf(object) === REACT_PROVIDER_TYPE;\n      }\n      __name(isContextProvider, \"isContextProvider\");\n      function isElement(object) {\n        return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n      }\n      __name(isElement, \"isElement\");\n      function isForwardRef(object) {\n        return typeOf(object) === REACT_FORWARD_REF_TYPE;\n      }\n      __name(isForwardRef, \"isForwardRef\");\n      function isFragment(object) {\n        return typeOf(object) === REACT_FRAGMENT_TYPE;\n      }\n      __name(isFragment, \"isFragment\");\n      function isLazy(object) {\n        return typeOf(object) === REACT_LAZY_TYPE;\n      }\n      __name(isLazy, \"isLazy\");\n      function isMemo(object) {\n        return typeOf(object) === REACT_MEMO_TYPE;\n      }\n      __name(isMemo, \"isMemo\");\n      function isPortal(object) {\n        return typeOf(object) === REACT_PORTAL_TYPE;\n      }\n      __name(isPortal, \"isPortal\");\n      function isProfiler(object) {\n        return typeOf(object) === REACT_PROFILER_TYPE;\n      }\n      __name(isProfiler, \"isProfiler\");\n      function isStrictMode(object) {\n        return typeOf(object) === REACT_STRICT_MODE_TYPE;\n      }\n      __name(isStrictMode, \"isStrictMode\");\n      function isSuspense(object) {\n        return typeOf(object) === REACT_SUSPENSE_TYPE;\n      }\n      __name(isSuspense, \"isSuspense\");\n      function isSuspenseList(object) {\n        return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;\n      }\n      __name(isSuspenseList, \"isSuspenseList\");\n      reactIs_development.ContextConsumer = ContextConsumer;\n      reactIs_development.ContextProvider = ContextProvider;\n      reactIs_development.Element = Element2;\n      reactIs_development.ForwardRef = ForwardRef;\n      reactIs_development.Fragment = Fragment;\n      reactIs_development.Lazy = Lazy;\n      reactIs_development.Memo = Memo;\n      reactIs_development.Portal = Portal;\n      reactIs_development.Profiler = Profiler;\n      reactIs_development.StrictMode = StrictMode;\n      reactIs_development.Suspense = Suspense;\n      reactIs_development.SuspenseList = SuspenseList;\n      reactIs_development.isAsyncMode = isAsyncMode;\n      reactIs_development.isConcurrentMode = isConcurrentMode;\n      reactIs_development.isContextConsumer = isContextConsumer;\n      reactIs_development.isContextProvider = isContextProvider;\n      reactIs_development.isElement = isElement;\n      reactIs_development.isForwardRef = isForwardRef;\n      reactIs_development.isFragment = isFragment;\n      reactIs_development.isLazy = isLazy;\n      reactIs_development.isMemo = isMemo;\n      reactIs_development.isPortal = isPortal;\n      reactIs_development.isProfiler = isProfiler;\n      reactIs_development.isStrictMode = isStrictMode;\n      reactIs_development.isSuspense = isSuspense;\n      reactIs_development.isSuspenseList = isSuspenseList;\n      reactIs_development.isValidElementType = isValidElementType;\n      reactIs_development.typeOf = typeOf;\n    })();\n  }\n  return reactIs_development;\n}\n__name(requireReactIs_development, \"requireReactIs_development\");\nvar hasRequiredReactIs;\nfunction requireReactIs() {\n  if (hasRequiredReactIs) return reactIs.exports;\n  hasRequiredReactIs = 1;\n  if (process.env.NODE_ENV === \"production\") {\n    reactIs.exports = requireReactIs_production_min();\n  } else {\n    reactIs.exports = requireReactIs_development();\n  }\n  return reactIs.exports;\n}\n__name(requireReactIs, \"requireReactIs\");\nvar reactIsExports = requireReactIs();\nvar index = getDefaultExportFromCjs(reactIsExports);\nvar ReactIs18 = _mergeNamespaces({\n  __proto__: null,\n  default: index\n}, [reactIsExports]);\nvar reactIsMethods = [\n  \"isAsyncMode\",\n  \"isConcurrentMode\",\n  \"isContextConsumer\",\n  \"isContextProvider\",\n  \"isElement\",\n  \"isForwardRef\",\n  \"isFragment\",\n  \"isLazy\",\n  \"isMemo\",\n  \"isPortal\",\n  \"isProfiler\",\n  \"isStrictMode\",\n  \"isSuspense\",\n  \"isSuspenseList\",\n  \"isValidElementType\"\n];\nvar ReactIs = Object.fromEntries(reactIsMethods.map((m2) => [m2, (v) => ReactIs18[m2](v) || ReactIs19[m2](v)]));\nfunction getChildren(arg, children = []) {\n  if (Array.isArray(arg)) {\n    for (const item of arg) {\n      getChildren(item, children);\n    }\n  } else if (arg != null && arg !== false && arg !== \"\") {\n    children.push(arg);\n  }\n  return children;\n}\n__name(getChildren, \"getChildren\");\nfunction getType(element) {\n  const type = element.type;\n  if (typeof type === \"string\") {\n    return type;\n  }\n  if (typeof type === \"function\") {\n    return type.displayName || type.name || \"Unknown\";\n  }\n  if (ReactIs.isFragment(element)) {\n    return \"React.Fragment\";\n  }\n  if (ReactIs.isSuspense(element)) {\n    return \"React.Suspense\";\n  }\n  if (typeof type === \"object\" && type !== null) {\n    if (ReactIs.isContextProvider(element)) {\n      return \"Context.Provider\";\n    }\n    if (ReactIs.isContextConsumer(element)) {\n      return \"Context.Consumer\";\n    }\n    if (ReactIs.isForwardRef(element)) {\n      if (type.displayName) {\n        return type.displayName;\n      }\n      const functionName = type.render.displayName || type.render.name || \"\";\n      return functionName === \"\" ? \"ForwardRef\" : `ForwardRef(${functionName})`;\n    }\n    if (ReactIs.isMemo(element)) {\n      const functionName = type.displayName || type.type.displayName || type.type.name || \"\";\n      return functionName === \"\" ? \"Memo\" : `Memo(${functionName})`;\n    }\n  }\n  return \"UNDEFINED\";\n}\n__name(getType, \"getType\");\nfunction getPropKeys$1(element) {\n  const { props } = element;\n  return Object.keys(props).filter((key) => key !== \"children\" && props[key] !== void 0).sort();\n}\n__name(getPropKeys$1, \"getPropKeys$1\");\nvar serialize$1 = /* @__PURE__ */ __name((element, config, indentation, depth, refs, printer2) => ++depth > config.maxDepth ? printElementAsLeaf(getType(element), config) : printElement(getType(element), printProps(getPropKeys$1(element), element.props, config, indentation + config.indent, depth, refs, printer2), printChildren(getChildren(element.props.children), config, indentation + config.indent, depth, refs, printer2), config, indentation), \"serialize$1\");\nvar test$1 = /* @__PURE__ */ __name((val) => val != null && ReactIs.isElement(val), \"test$1\");\nvar plugin$1 = {\n  serialize: serialize$1,\n  test: test$1\n};\nvar testSymbol = typeof Symbol === \"function\" && Symbol.for ? Symbol.for(\"react.test.json\") : 245830487;\nfunction getPropKeys(object) {\n  const { props } = object;\n  return props ? Object.keys(props).filter((key) => props[key] !== void 0).sort() : [];\n}\n__name(getPropKeys, \"getPropKeys\");\nvar serialize = /* @__PURE__ */ __name((object, config, indentation, depth, refs, printer2) => ++depth > config.maxDepth ? printElementAsLeaf(object.type, config) : printElement(object.type, object.props ? printProps(getPropKeys(object), object.props, config, indentation + config.indent, depth, refs, printer2) : \"\", object.children ? printChildren(object.children, config, indentation + config.indent, depth, refs, printer2) : \"\", config, indentation), \"serialize\");\nvar test = /* @__PURE__ */ __name((val) => val && val.$$typeof === testSymbol, \"test\");\nvar plugin = {\n  serialize,\n  test\n};\nvar toString = Object.prototype.toString;\nvar toISOString = Date.prototype.toISOString;\nvar errorToString = Error.prototype.toString;\nvar regExpToString = RegExp.prototype.toString;\nfunction getConstructorName(val) {\n  return typeof val.constructor === \"function\" && val.constructor.name || \"Object\";\n}\n__name(getConstructorName, \"getConstructorName\");\nfunction isWindow(val) {\n  return typeof window !== \"undefined\" && val === window;\n}\n__name(isWindow, \"isWindow\");\nvar SYMBOL_REGEXP = /^Symbol\\((.*)\\)(.*)$/;\nvar NEWLINE_REGEXP = /\\n/g;\nvar _PrettyFormatPluginError = class _PrettyFormatPluginError extends Error {\n  constructor(message, stack) {\n    super(message);\n    this.stack = stack;\n    this.name = this.constructor.name;\n  }\n};\n__name(_PrettyFormatPluginError, \"PrettyFormatPluginError\");\nvar PrettyFormatPluginError = _PrettyFormatPluginError;\nfunction isToStringedArrayType(toStringed) {\n  return toStringed === \"[object Array]\" || toStringed === \"[object ArrayBuffer]\" || toStringed === \"[object DataView]\" || toStringed === \"[object Float32Array]\" || toStringed === \"[object Float64Array]\" || toStringed === \"[object Int8Array]\" || toStringed === \"[object Int16Array]\" || toStringed === \"[object Int32Array]\" || toStringed === \"[object Uint8Array]\" || toStringed === \"[object Uint8ClampedArray]\" || toStringed === \"[object Uint16Array]\" || toStringed === \"[object Uint32Array]\";\n}\n__name(isToStringedArrayType, \"isToStringedArrayType\");\nfunction printNumber(val) {\n  return Object.is(val, -0) ? \"-0\" : String(val);\n}\n__name(printNumber, \"printNumber\");\nfunction printBigInt(val) {\n  return String(`${val}n`);\n}\n__name(printBigInt, \"printBigInt\");\nfunction printFunction(val, printFunctionName) {\n  if (!printFunctionName) {\n    return \"[Function]\";\n  }\n  return `[Function ${val.name || \"anonymous\"}]`;\n}\n__name(printFunction, \"printFunction\");\nfunction printSymbol(val) {\n  return String(val).replace(SYMBOL_REGEXP, \"Symbol($1)\");\n}\n__name(printSymbol, \"printSymbol\");\nfunction printError(val) {\n  return `[${errorToString.call(val)}]`;\n}\n__name(printError, \"printError\");\nfunction printBasicValue(val, printFunctionName, escapeRegex, escapeString) {\n  if (val === true || val === false) {\n    return `${val}`;\n  }\n  if (val === void 0) {\n    return \"undefined\";\n  }\n  if (val === null) {\n    return \"null\";\n  }\n  const typeOf = typeof val;\n  if (typeOf === \"number\") {\n    return printNumber(val);\n  }\n  if (typeOf === \"bigint\") {\n    return printBigInt(val);\n  }\n  if (typeOf === \"string\") {\n    if (escapeString) {\n      return `\"${val.replaceAll(/\"|\\\\/g, \"\\\\$&\")}\"`;\n    }\n    return `\"${val}\"`;\n  }\n  if (typeOf === \"function\") {\n    return printFunction(val, printFunctionName);\n  }\n  if (typeOf === \"symbol\") {\n    return printSymbol(val);\n  }\n  const toStringed = toString.call(val);\n  if (toStringed === \"[object WeakMap]\") {\n    return \"WeakMap {}\";\n  }\n  if (toStringed === \"[object WeakSet]\") {\n    return \"WeakSet {}\";\n  }\n  if (toStringed === \"[object Function]\" || toStringed === \"[object GeneratorFunction]\") {\n    return printFunction(val, printFunctionName);\n  }\n  if (toStringed === \"[object Symbol]\") {\n    return printSymbol(val);\n  }\n  if (toStringed === \"[object Date]\") {\n    return Number.isNaN(+val) ? \"Date { NaN }\" : toISOString.call(val);\n  }\n  if (toStringed === \"[object Error]\") {\n    return printError(val);\n  }\n  if (toStringed === \"[object RegExp]\") {\n    if (escapeRegex) {\n      return regExpToString.call(val).replaceAll(/[$()*+.?[\\\\\\]^{|}]/g, \"\\\\$&\");\n    }\n    return regExpToString.call(val);\n  }\n  if (val instanceof Error) {\n    return printError(val);\n  }\n  return null;\n}\n__name(printBasicValue, \"printBasicValue\");\nfunction printComplexValue(val, config, indentation, depth, refs, hasCalledToJSON) {\n  if (refs.includes(val)) {\n    return \"[Circular]\";\n  }\n  refs = [...refs];\n  refs.push(val);\n  const hitMaxDepth = ++depth > config.maxDepth;\n  const min = config.min;\n  if (config.callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON === \"function\" && !hasCalledToJSON) {\n    return printer(val.toJSON(), config, indentation, depth, refs, true);\n  }\n  const toStringed = toString.call(val);\n  if (toStringed === \"[object Arguments]\") {\n    return hitMaxDepth ? \"[Arguments]\" : `${min ? \"\" : \"Arguments \"}[${printListItems(val, config, indentation, depth, refs, printer)}]`;\n  }\n  if (isToStringedArrayType(toStringed)) {\n    return hitMaxDepth ? `[${val.constructor.name}]` : `${min ? \"\" : !config.printBasicPrototype && val.constructor.name === \"Array\" ? \"\" : `${val.constructor.name} `}[${printListItems(val, config, indentation, depth, refs, printer)}]`;\n  }\n  if (toStringed === \"[object Map]\") {\n    return hitMaxDepth ? \"[Map]\" : `Map {${printIteratorEntries(val.entries(), config, indentation, depth, refs, printer, \" => \")}}`;\n  }\n  if (toStringed === \"[object Set]\") {\n    return hitMaxDepth ? \"[Set]\" : `Set {${printIteratorValues(val.values(), config, indentation, depth, refs, printer)}}`;\n  }\n  return hitMaxDepth || isWindow(val) ? `[${getConstructorName(val)}]` : `${min ? \"\" : !config.printBasicPrototype && getConstructorName(val) === \"Object\" ? \"\" : `${getConstructorName(val)} `}{${printObjectProperties(val, config, indentation, depth, refs, printer)}}`;\n}\n__name(printComplexValue, \"printComplexValue\");\nvar ErrorPlugin = {\n  test: /* @__PURE__ */ __name((val) => val && val instanceof Error, \"test\"),\n  serialize(val, config, indentation, depth, refs, printer2) {\n    if (refs.includes(val)) {\n      return \"[Circular]\";\n    }\n    refs = [...refs, val];\n    const hitMaxDepth = ++depth > config.maxDepth;\n    const { message, cause, ...rest } = val;\n    const entries = {\n      message,\n      ...typeof cause !== \"undefined\" ? { cause } : {},\n      ...val instanceof AggregateError ? { errors: val.errors } : {},\n      ...rest\n    };\n    const name = val.name !== \"Error\" ? val.name : getConstructorName(val);\n    return hitMaxDepth ? `[${name}]` : `${name} {${printIteratorEntries(Object.entries(entries).values(), config, indentation, depth, refs, printer2)}}`;\n  }\n};\nfunction isNewPlugin(plugin2) {\n  return plugin2.serialize != null;\n}\n__name(isNewPlugin, \"isNewPlugin\");\nfunction printPlugin(plugin2, val, config, indentation, depth, refs) {\n  let printed;\n  try {\n    printed = isNewPlugin(plugin2) ? plugin2.serialize(val, config, indentation, depth, refs, printer) : plugin2.print(val, (valChild) => printer(valChild, config, indentation, depth, refs), (str) => {\n      const indentationNext = indentation + config.indent;\n      return indentationNext + str.replaceAll(NEWLINE_REGEXP, `\n${indentationNext}`);\n    }, {\n      edgeSpacing: config.spacingOuter,\n      min: config.min,\n      spacing: config.spacingInner\n    }, config.colors);\n  } catch (error) {\n    throw new PrettyFormatPluginError(error.message, error.stack);\n  }\n  if (typeof printed !== \"string\") {\n    throw new TypeError(`pretty-format: Plugin must return type \"string\" but instead returned \"${typeof printed}\".`);\n  }\n  return printed;\n}\n__name(printPlugin, \"printPlugin\");\nfunction findPlugin(plugins2, val) {\n  for (const plugin2 of plugins2) {\n    try {\n      if (plugin2.test(val)) {\n        return plugin2;\n      }\n    } catch (error) {\n      throw new PrettyFormatPluginError(error.message, error.stack);\n    }\n  }\n  return null;\n}\n__name(findPlugin, \"findPlugin\");\nfunction printer(val, config, indentation, depth, refs, hasCalledToJSON) {\n  const plugin2 = findPlugin(config.plugins, val);\n  if (plugin2 !== null) {\n    return printPlugin(plugin2, val, config, indentation, depth, refs);\n  }\n  const basicResult = printBasicValue(val, config.printFunctionName, config.escapeRegex, config.escapeString);\n  if (basicResult !== null) {\n    return basicResult;\n  }\n  return printComplexValue(val, config, indentation, depth, refs, hasCalledToJSON);\n}\n__name(printer, \"printer\");\nvar DEFAULT_THEME = {\n  comment: \"gray\",\n  content: \"reset\",\n  prop: \"yellow\",\n  tag: \"cyan\",\n  value: \"green\"\n};\nvar DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME);\nvar DEFAULT_OPTIONS = {\n  callToJSON: true,\n  compareKeys: void 0,\n  escapeRegex: false,\n  escapeString: true,\n  highlight: false,\n  indent: 2,\n  maxDepth: Number.POSITIVE_INFINITY,\n  maxWidth: Number.POSITIVE_INFINITY,\n  min: false,\n  plugins: [],\n  printBasicPrototype: true,\n  printFunctionName: true,\n  theme: DEFAULT_THEME\n};\nfunction validateOptions(options) {\n  for (const key of Object.keys(options)) {\n    if (!Object.prototype.hasOwnProperty.call(DEFAULT_OPTIONS, key)) {\n      throw new Error(`pretty-format: Unknown option \"${key}\".`);\n    }\n  }\n  if (options.min && options.indent !== void 0 && options.indent !== 0) {\n    throw new Error('pretty-format: Options \"min\" and \"indent\" cannot be used together.');\n  }\n}\n__name(validateOptions, \"validateOptions\");\nfunction getColorsHighlight() {\n  return DEFAULT_THEME_KEYS.reduce((colors, key) => {\n    const value = DEFAULT_THEME[key];\n    const color = value && s[value];\n    if (color && typeof color.close === \"string\" && typeof color.open === \"string\") {\n      colors[key] = color;\n    } else {\n      throw new Error(`pretty-format: Option \"theme\" has a key \"${key}\" whose value \"${value}\" is undefined in ansi-styles.`);\n    }\n    return colors;\n  }, /* @__PURE__ */ Object.create(null));\n}\n__name(getColorsHighlight, \"getColorsHighlight\");\nfunction getColorsEmpty() {\n  return DEFAULT_THEME_KEYS.reduce((colors, key) => {\n    colors[key] = {\n      close: \"\",\n      open: \"\"\n    };\n    return colors;\n  }, /* @__PURE__ */ Object.create(null));\n}\n__name(getColorsEmpty, \"getColorsEmpty\");\nfunction getPrintFunctionName(options) {\n  return (options === null || options === void 0 ? void 0 : options.printFunctionName) ?? DEFAULT_OPTIONS.printFunctionName;\n}\n__name(getPrintFunctionName, \"getPrintFunctionName\");\nfunction getEscapeRegex(options) {\n  return (options === null || options === void 0 ? void 0 : options.escapeRegex) ?? DEFAULT_OPTIONS.escapeRegex;\n}\n__name(getEscapeRegex, \"getEscapeRegex\");\nfunction getEscapeString(options) {\n  return (options === null || options === void 0 ? void 0 : options.escapeString) ?? DEFAULT_OPTIONS.escapeString;\n}\n__name(getEscapeString, \"getEscapeString\");\nfunction getConfig(options) {\n  return {\n    callToJSON: (options === null || options === void 0 ? void 0 : options.callToJSON) ?? DEFAULT_OPTIONS.callToJSON,\n    colors: (options === null || options === void 0 ? void 0 : options.highlight) ? getColorsHighlight() : getColorsEmpty(),\n    compareKeys: typeof (options === null || options === void 0 ? void 0 : options.compareKeys) === \"function\" || (options === null || options === void 0 ? void 0 : options.compareKeys) === null ? options.compareKeys : DEFAULT_OPTIONS.compareKeys,\n    escapeRegex: getEscapeRegex(options),\n    escapeString: getEscapeString(options),\n    indent: (options === null || options === void 0 ? void 0 : options.min) ? \"\" : createIndent((options === null || options === void 0 ? void 0 : options.indent) ?? DEFAULT_OPTIONS.indent),\n    maxDepth: (options === null || options === void 0 ? void 0 : options.maxDepth) ?? DEFAULT_OPTIONS.maxDepth,\n    maxWidth: (options === null || options === void 0 ? void 0 : options.maxWidth) ?? DEFAULT_OPTIONS.maxWidth,\n    min: (options === null || options === void 0 ? void 0 : options.min) ?? DEFAULT_OPTIONS.min,\n    plugins: (options === null || options === void 0 ? void 0 : options.plugins) ?? DEFAULT_OPTIONS.plugins,\n    printBasicPrototype: (options === null || options === void 0 ? void 0 : options.printBasicPrototype) ?? true,\n    printFunctionName: getPrintFunctionName(options),\n    spacingInner: (options === null || options === void 0 ? void 0 : options.min) ? \" \" : \"\\n\",\n    spacingOuter: (options === null || options === void 0 ? void 0 : options.min) ? \"\" : \"\\n\"\n  };\n}\n__name(getConfig, \"getConfig\");\nfunction createIndent(indent) {\n  return Array.from({ length: indent + 1 }).join(\" \");\n}\n__name(createIndent, \"createIndent\");\nfunction format(val, options) {\n  if (options) {\n    validateOptions(options);\n    if (options.plugins) {\n      const plugin2 = findPlugin(options.plugins, val);\n      if (plugin2 !== null) {\n        return printPlugin(plugin2, val, getConfig(options), \"\", 0, []);\n      }\n    }\n  }\n  const basicResult = printBasicValue(val, getPrintFunctionName(options), getEscapeRegex(options), getEscapeString(options));\n  if (basicResult !== null) {\n    return basicResult;\n  }\n  return printComplexValue(val, getConfig(options), \"\", 0, []);\n}\n__name(format, \"format\");\nvar plugins = {\n  AsymmetricMatcher: plugin$5,\n  DOMCollection: plugin$4,\n  DOMElement: plugin$3,\n  Immutable: plugin$2,\n  ReactElement: plugin$1,\n  ReactTestComponent: plugin,\n  Error: ErrorPlugin\n};\n\n// ../node_modules/loupe/lib/helpers.js\nvar ansiColors = {\n  bold: [\"1\", \"22\"],\n  dim: [\"2\", \"22\"],\n  italic: [\"3\", \"23\"],\n  underline: [\"4\", \"24\"],\n  // 5 & 6 are blinking\n  inverse: [\"7\", \"27\"],\n  hidden: [\"8\", \"28\"],\n  strike: [\"9\", \"29\"],\n  // 10-20 are fonts\n  // 21-29 are resets for 1-9\n  black: [\"30\", \"39\"],\n  red: [\"31\", \"39\"],\n  green: [\"32\", \"39\"],\n  yellow: [\"33\", \"39\"],\n  blue: [\"34\", \"39\"],\n  magenta: [\"35\", \"39\"],\n  cyan: [\"36\", \"39\"],\n  white: [\"37\", \"39\"],\n  brightblack: [\"30;1\", \"39\"],\n  brightred: [\"31;1\", \"39\"],\n  brightgreen: [\"32;1\", \"39\"],\n  brightyellow: [\"33;1\", \"39\"],\n  brightblue: [\"34;1\", \"39\"],\n  brightmagenta: [\"35;1\", \"39\"],\n  brightcyan: [\"36;1\", \"39\"],\n  brightwhite: [\"37;1\", \"39\"],\n  grey: [\"90\", \"39\"]\n};\nvar styles = {\n  special: \"cyan\",\n  number: \"yellow\",\n  bigint: \"yellow\",\n  boolean: \"yellow\",\n  undefined: \"grey\",\n  null: \"bold\",\n  string: \"green\",\n  symbol: \"green\",\n  date: \"magenta\",\n  regexp: \"red\"\n};\nvar truncator = \"\\u2026\";\nfunction colorise(value, styleType) {\n  const color = ansiColors[styles[styleType]] || ansiColors[styleType] || \"\";\n  if (!color) {\n    return String(value);\n  }\n  return `\\x1B[${color[0]}m${String(value)}\\x1B[${color[1]}m`;\n}\n__name(colorise, \"colorise\");\nfunction normaliseOptions({\n  showHidden = false,\n  depth = 2,\n  colors = false,\n  customInspect = true,\n  showProxy = false,\n  maxArrayLength = Infinity,\n  breakLength = Infinity,\n  seen = [],\n  // eslint-disable-next-line no-shadow\n  truncate: truncate2 = Infinity,\n  stylize = String\n} = {}, inspect3) {\n  const options = {\n    showHidden: Boolean(showHidden),\n    depth: Number(depth),\n    colors: Boolean(colors),\n    customInspect: Boolean(customInspect),\n    showProxy: Boolean(showProxy),\n    maxArrayLength: Number(maxArrayLength),\n    breakLength: Number(breakLength),\n    truncate: Number(truncate2),\n    seen,\n    inspect: inspect3,\n    stylize\n  };\n  if (options.colors) {\n    options.stylize = colorise;\n  }\n  return options;\n}\n__name(normaliseOptions, \"normaliseOptions\");\nfunction isHighSurrogate(char) {\n  return char >= \"\\uD800\" && char <= \"\\uDBFF\";\n}\n__name(isHighSurrogate, \"isHighSurrogate\");\nfunction truncate(string, length, tail = truncator) {\n  string = String(string);\n  const tailLength = tail.length;\n  const stringLength = string.length;\n  if (tailLength > length && stringLength > tailLength) {\n    return tail;\n  }\n  if (stringLength > length && stringLength > tailLength) {\n    let end = length - tailLength;\n    if (end > 0 && isHighSurrogate(string[end - 1])) {\n      end = end - 1;\n    }\n    return `${string.slice(0, end)}${tail}`;\n  }\n  return string;\n}\n__name(truncate, \"truncate\");\nfunction inspectList(list, options, inspectItem, separator = \", \") {\n  inspectItem = inspectItem || options.inspect;\n  const size = list.length;\n  if (size === 0)\n    return \"\";\n  const originalLength = options.truncate;\n  let output = \"\";\n  let peek = \"\";\n  let truncated = \"\";\n  for (let i = 0; i < size; i += 1) {\n    const last = i + 1 === list.length;\n    const secondToLast = i + 2 === list.length;\n    truncated = `${truncator}(${list.length - i})`;\n    const value = list[i];\n    options.truncate = originalLength - output.length - (last ? 0 : separator.length);\n    const string = peek || inspectItem(value, options) + (last ? \"\" : separator);\n    const nextLength = output.length + string.length;\n    const truncatedLength = nextLength + truncated.length;\n    if (last && nextLength > originalLength && output.length + truncated.length <= originalLength) {\n      break;\n    }\n    if (!last && !secondToLast && truncatedLength > originalLength) {\n      break;\n    }\n    peek = last ? \"\" : inspectItem(list[i + 1], options) + (secondToLast ? \"\" : separator);\n    if (!last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength) {\n      break;\n    }\n    output += string;\n    if (!last && !secondToLast && nextLength + peek.length >= originalLength) {\n      truncated = `${truncator}(${list.length - i - 1})`;\n      break;\n    }\n    truncated = \"\";\n  }\n  return `${output}${truncated}`;\n}\n__name(inspectList, \"inspectList\");\nfunction quoteComplexKey(key) {\n  if (key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)) {\n    return key;\n  }\n  return JSON.stringify(key).replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\");\n}\n__name(quoteComplexKey, \"quoteComplexKey\");\nfunction inspectProperty([key, value], options) {\n  options.truncate -= 2;\n  if (typeof key === \"string\") {\n    key = quoteComplexKey(key);\n  } else if (typeof key !== \"number\") {\n    key = `[${options.inspect(key, options)}]`;\n  }\n  options.truncate -= key.length;\n  value = options.inspect(value, options);\n  return `${key}: ${value}`;\n}\n__name(inspectProperty, \"inspectProperty\");\n\n// ../node_modules/loupe/lib/array.js\nfunction inspectArray(array, options) {\n  const nonIndexProperties = Object.keys(array).slice(array.length);\n  if (!array.length && !nonIndexProperties.length)\n    return \"[]\";\n  options.truncate -= 4;\n  const listContents = inspectList(array, options);\n  options.truncate -= listContents.length;\n  let propertyContents = \"\";\n  if (nonIndexProperties.length) {\n    propertyContents = inspectList(nonIndexProperties.map((key) => [key, array[key]]), options, inspectProperty);\n  }\n  return `[ ${listContents}${propertyContents ? `, ${propertyContents}` : \"\"} ]`;\n}\n__name(inspectArray, \"inspectArray\");\n\n// ../node_modules/loupe/lib/typedarray.js\nvar getArrayName = /* @__PURE__ */ __name((array) => {\n  if (typeof Buffer === \"function\" && array instanceof Buffer) {\n    return \"Buffer\";\n  }\n  if (array[Symbol.toStringTag]) {\n    return array[Symbol.toStringTag];\n  }\n  return array.constructor.name;\n}, \"getArrayName\");\nfunction inspectTypedArray(array, options) {\n  const name = getArrayName(array);\n  options.truncate -= name.length + 4;\n  const nonIndexProperties = Object.keys(array).slice(array.length);\n  if (!array.length && !nonIndexProperties.length)\n    return `${name}[]`;\n  let output = \"\";\n  for (let i = 0; i < array.length; i++) {\n    const string = `${options.stylize(truncate(array[i], options.truncate), \"number\")}${i === array.length - 1 ? \"\" : \", \"}`;\n    options.truncate -= string.length;\n    if (array[i] !== array.length && options.truncate <= 3) {\n      output += `${truncator}(${array.length - array[i] + 1})`;\n      break;\n    }\n    output += string;\n  }\n  let propertyContents = \"\";\n  if (nonIndexProperties.length) {\n    propertyContents = inspectList(nonIndexProperties.map((key) => [key, array[key]]), options, inspectProperty);\n  }\n  return `${name}[ ${output}${propertyContents ? `, ${propertyContents}` : \"\"} ]`;\n}\n__name(inspectTypedArray, \"inspectTypedArray\");\n\n// ../node_modules/loupe/lib/date.js\nfunction inspectDate(dateObject, options) {\n  const stringRepresentation = dateObject.toJSON();\n  if (stringRepresentation === null) {\n    return \"Invalid Date\";\n  }\n  const split = stringRepresentation.split(\"T\");\n  const date = split[0];\n  return options.stylize(`${date}T${truncate(split[1], options.truncate - date.length - 1)}`, \"date\");\n}\n__name(inspectDate, \"inspectDate\");\n\n// ../node_modules/loupe/lib/function.js\nfunction inspectFunction(func, options) {\n  const functionType = func[Symbol.toStringTag] || \"Function\";\n  const name = func.name;\n  if (!name) {\n    return options.stylize(`[${functionType}]`, \"special\");\n  }\n  return options.stylize(`[${functionType} ${truncate(name, options.truncate - 11)}]`, \"special\");\n}\n__name(inspectFunction, \"inspectFunction\");\n\n// ../node_modules/loupe/lib/map.js\nfunction inspectMapEntry([key, value], options) {\n  options.truncate -= 4;\n  key = options.inspect(key, options);\n  options.truncate -= key.length;\n  value = options.inspect(value, options);\n  return `${key} => ${value}`;\n}\n__name(inspectMapEntry, \"inspectMapEntry\");\nfunction mapToEntries(map) {\n  const entries = [];\n  map.forEach((value, key) => {\n    entries.push([key, value]);\n  });\n  return entries;\n}\n__name(mapToEntries, \"mapToEntries\");\nfunction inspectMap(map, options) {\n  if (map.size === 0)\n    return \"Map{}\";\n  options.truncate -= 7;\n  return `Map{ ${inspectList(mapToEntries(map), options, inspectMapEntry)} }`;\n}\n__name(inspectMap, \"inspectMap\");\n\n// ../node_modules/loupe/lib/number.js\nvar isNaN = Number.isNaN || ((i) => i !== i);\nfunction inspectNumber(number, options) {\n  if (isNaN(number)) {\n    return options.stylize(\"NaN\", \"number\");\n  }\n  if (number === Infinity) {\n    return options.stylize(\"Infinity\", \"number\");\n  }\n  if (number === -Infinity) {\n    return options.stylize(\"-Infinity\", \"number\");\n  }\n  if (number === 0) {\n    return options.stylize(1 / number === Infinity ? \"+0\" : \"-0\", \"number\");\n  }\n  return options.stylize(truncate(String(number), options.truncate), \"number\");\n}\n__name(inspectNumber, \"inspectNumber\");\n\n// ../node_modules/loupe/lib/bigint.js\nfunction inspectBigInt(number, options) {\n  let nums = truncate(number.toString(), options.truncate - 1);\n  if (nums !== truncator)\n    nums += \"n\";\n  return options.stylize(nums, \"bigint\");\n}\n__name(inspectBigInt, \"inspectBigInt\");\n\n// ../node_modules/loupe/lib/regexp.js\nfunction inspectRegExp(value, options) {\n  const flags = value.toString().split(\"/\")[2];\n  const sourceLength = options.truncate - (2 + flags.length);\n  const source = value.source;\n  return options.stylize(`/${truncate(source, sourceLength)}/${flags}`, \"regexp\");\n}\n__name(inspectRegExp, \"inspectRegExp\");\n\n// ../node_modules/loupe/lib/set.js\nfunction arrayFromSet(set) {\n  const values = [];\n  set.forEach((value) => {\n    values.push(value);\n  });\n  return values;\n}\n__name(arrayFromSet, \"arrayFromSet\");\nfunction inspectSet(set, options) {\n  if (set.size === 0)\n    return \"Set{}\";\n  options.truncate -= 7;\n  return `Set{ ${inspectList(arrayFromSet(set), options)} }`;\n}\n__name(inspectSet, \"inspectSet\");\n\n// ../node_modules/loupe/lib/string.js\nvar stringEscapeChars = new RegExp(\"['\\\\u0000-\\\\u001f\\\\u007f-\\\\u009f\\\\u00ad\\\\u0600-\\\\u0604\\\\u070f\\\\u17b4\\\\u17b5\\\\u200c-\\\\u200f\\\\u2028-\\\\u202f\\\\u2060-\\\\u206f\\\\ufeff\\\\ufff0-\\\\uffff]\", \"g\");\nvar escapeCharacters = {\n  \"\\b\": \"\\\\b\",\n  \"\t\": \"\\\\t\",\n  \"\\n\": \"\\\\n\",\n  \"\\f\": \"\\\\f\",\n  \"\\r\": \"\\\\r\",\n  \"'\": \"\\\\'\",\n  \"\\\\\": \"\\\\\\\\\"\n};\nvar hex = 16;\nvar unicodeLength = 4;\nfunction escape(char) {\n  return escapeCharacters[char] || `\\\\u${`0000${char.charCodeAt(0).toString(hex)}`.slice(-unicodeLength)}`;\n}\n__name(escape, \"escape\");\nfunction inspectString(string, options) {\n  if (stringEscapeChars.test(string)) {\n    string = string.replace(stringEscapeChars, escape);\n  }\n  return options.stylize(`'${truncate(string, options.truncate - 2)}'`, \"string\");\n}\n__name(inspectString, \"inspectString\");\n\n// ../node_modules/loupe/lib/symbol.js\nfunction inspectSymbol(value) {\n  if (\"description\" in Symbol.prototype) {\n    return value.description ? `Symbol(${value.description})` : \"Symbol()\";\n  }\n  return value.toString();\n}\n__name(inspectSymbol, \"inspectSymbol\");\n\n// ../node_modules/loupe/lib/promise.js\nvar getPromiseValue = /* @__PURE__ */ __name(() => \"Promise{\\u2026}\", \"getPromiseValue\");\nvar promise_default = getPromiseValue;\n\n// ../node_modules/loupe/lib/object.js\nfunction inspectObject(object, options) {\n  const properties = Object.getOwnPropertyNames(object);\n  const symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : [];\n  if (properties.length === 0 && symbols.length === 0) {\n    return \"{}\";\n  }\n  options.truncate -= 4;\n  options.seen = options.seen || [];\n  if (options.seen.includes(object)) {\n    return \"[Circular]\";\n  }\n  options.seen.push(object);\n  const propertyContents = inspectList(properties.map((key) => [key, object[key]]), options, inspectProperty);\n  const symbolContents = inspectList(symbols.map((key) => [key, object[key]]), options, inspectProperty);\n  options.seen.pop();\n  let sep = \"\";\n  if (propertyContents && symbolContents) {\n    sep = \", \";\n  }\n  return `{ ${propertyContents}${sep}${symbolContents} }`;\n}\n__name(inspectObject, \"inspectObject\");\n\n// ../node_modules/loupe/lib/class.js\nvar toStringTag = typeof Symbol !== \"undefined\" && Symbol.toStringTag ? Symbol.toStringTag : false;\nfunction inspectClass(value, options) {\n  let name = \"\";\n  if (toStringTag && toStringTag in value) {\n    name = value[toStringTag];\n  }\n  name = name || value.constructor.name;\n  if (!name || name === \"_class\") {\n    name = \"<Anonymous Class>\";\n  }\n  options.truncate -= name.length;\n  return `${name}${inspectObject(value, options)}`;\n}\n__name(inspectClass, \"inspectClass\");\n\n// ../node_modules/loupe/lib/arguments.js\nfunction inspectArguments(args, options) {\n  if (args.length === 0)\n    return \"Arguments[]\";\n  options.truncate -= 13;\n  return `Arguments[ ${inspectList(args, options)} ]`;\n}\n__name(inspectArguments, \"inspectArguments\");\n\n// ../node_modules/loupe/lib/error.js\nvar errorKeys = [\n  \"stack\",\n  \"line\",\n  \"column\",\n  \"name\",\n  \"message\",\n  \"fileName\",\n  \"lineNumber\",\n  \"columnNumber\",\n  \"number\",\n  \"description\",\n  \"cause\"\n];\nfunction inspectObject2(error, options) {\n  const properties = Object.getOwnPropertyNames(error).filter((key) => errorKeys.indexOf(key) === -1);\n  const name = error.name;\n  options.truncate -= name.length;\n  let message = \"\";\n  if (typeof error.message === \"string\") {\n    message = truncate(error.message, options.truncate);\n  } else {\n    properties.unshift(\"message\");\n  }\n  message = message ? `: ${message}` : \"\";\n  options.truncate -= message.length + 5;\n  options.seen = options.seen || [];\n  if (options.seen.includes(error)) {\n    return \"[Circular]\";\n  }\n  options.seen.push(error);\n  const propertyContents = inspectList(properties.map((key) => [key, error[key]]), options, inspectProperty);\n  return `${name}${message}${propertyContents ? ` { ${propertyContents} }` : \"\"}`;\n}\n__name(inspectObject2, \"inspectObject\");\n\n// ../node_modules/loupe/lib/html.js\nfunction inspectAttribute([key, value], options) {\n  options.truncate -= 3;\n  if (!value) {\n    return `${options.stylize(String(key), \"yellow\")}`;\n  }\n  return `${options.stylize(String(key), \"yellow\")}=${options.stylize(`\"${value}\"`, \"string\")}`;\n}\n__name(inspectAttribute, \"inspectAttribute\");\nfunction inspectNodeCollection(collection, options) {\n  return inspectList(collection, options, inspectNode, \"\\n\");\n}\n__name(inspectNodeCollection, \"inspectNodeCollection\");\nfunction inspectNode(node, options) {\n  switch (node.nodeType) {\n    case 1:\n      return inspectHTML(node, options);\n    case 3:\n      return options.inspect(node.data, options);\n    default:\n      return options.inspect(node, options);\n  }\n}\n__name(inspectNode, \"inspectNode\");\nfunction inspectHTML(element, options) {\n  const properties = element.getAttributeNames();\n  const name = element.tagName.toLowerCase();\n  const head = options.stylize(`<${name}`, \"special\");\n  const headClose = options.stylize(`>`, \"special\");\n  const tail = options.stylize(`</${name}>`, \"special\");\n  options.truncate -= name.length * 2 + 5;\n  let propertyContents = \"\";\n  if (properties.length > 0) {\n    propertyContents += \" \";\n    propertyContents += inspectList(properties.map((key) => [key, element.getAttribute(key)]), options, inspectAttribute, \" \");\n  }\n  options.truncate -= propertyContents.length;\n  const truncate2 = options.truncate;\n  let children = inspectNodeCollection(element.children, options);\n  if (children && children.length > truncate2) {\n    children = `${truncator}(${element.children.length})`;\n  }\n  return `${head}${propertyContents}${headClose}${children}${tail}`;\n}\n__name(inspectHTML, \"inspectHTML\");\n\n// ../node_modules/loupe/lib/index.js\nvar symbolsSupported = typeof Symbol === \"function\" && typeof Symbol.for === \"function\";\nvar chaiInspect = symbolsSupported ? Symbol.for(\"chai/inspect\") : \"@@chai/inspect\";\nvar nodeInspect = Symbol.for(\"nodejs.util.inspect.custom\");\nvar constructorMap = /* @__PURE__ */ new WeakMap();\nvar stringTagMap = {};\nvar baseTypesMap = {\n  undefined: /* @__PURE__ */ __name((value, options) => options.stylize(\"undefined\", \"undefined\"), \"undefined\"),\n  null: /* @__PURE__ */ __name((value, options) => options.stylize(\"null\", \"null\"), \"null\"),\n  boolean: /* @__PURE__ */ __name((value, options) => options.stylize(String(value), \"boolean\"), \"boolean\"),\n  Boolean: /* @__PURE__ */ __name((value, options) => options.stylize(String(value), \"boolean\"), \"Boolean\"),\n  number: inspectNumber,\n  Number: inspectNumber,\n  bigint: inspectBigInt,\n  BigInt: inspectBigInt,\n  string: inspectString,\n  String: inspectString,\n  function: inspectFunction,\n  Function: inspectFunction,\n  symbol: inspectSymbol,\n  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect\n  Symbol: inspectSymbol,\n  Array: inspectArray,\n  Date: inspectDate,\n  Map: inspectMap,\n  Set: inspectSet,\n  RegExp: inspectRegExp,\n  Promise: promise_default,\n  // WeakSet, WeakMap are totally opaque to us\n  WeakSet: /* @__PURE__ */ __name((value, options) => options.stylize(\"WeakSet{\\u2026}\", \"special\"), \"WeakSet\"),\n  WeakMap: /* @__PURE__ */ __name((value, options) => options.stylize(\"WeakMap{\\u2026}\", \"special\"), \"WeakMap\"),\n  Arguments: inspectArguments,\n  Int8Array: inspectTypedArray,\n  Uint8Array: inspectTypedArray,\n  Uint8ClampedArray: inspectTypedArray,\n  Int16Array: inspectTypedArray,\n  Uint16Array: inspectTypedArray,\n  Int32Array: inspectTypedArray,\n  Uint32Array: inspectTypedArray,\n  Float32Array: inspectTypedArray,\n  Float64Array: inspectTypedArray,\n  Generator: /* @__PURE__ */ __name(() => \"\", \"Generator\"),\n  DataView: /* @__PURE__ */ __name(() => \"\", \"DataView\"),\n  ArrayBuffer: /* @__PURE__ */ __name(() => \"\", \"ArrayBuffer\"),\n  Error: inspectObject2,\n  HTMLCollection: inspectNodeCollection,\n  NodeList: inspectNodeCollection\n};\nvar inspectCustom = /* @__PURE__ */ __name((value, options, type, inspectFn) => {\n  if (chaiInspect in value && typeof value[chaiInspect] === \"function\") {\n    return value[chaiInspect](options);\n  }\n  if (nodeInspect in value && typeof value[nodeInspect] === \"function\") {\n    return value[nodeInspect](options.depth, options, inspectFn);\n  }\n  if (\"inspect\" in value && typeof value.inspect === \"function\") {\n    return value.inspect(options.depth, options);\n  }\n  if (\"constructor\" in value && constructorMap.has(value.constructor)) {\n    return constructorMap.get(value.constructor)(value, options);\n  }\n  if (stringTagMap[type]) {\n    return stringTagMap[type](value, options);\n  }\n  return \"\";\n}, \"inspectCustom\");\nvar toString2 = Object.prototype.toString;\nfunction inspect(value, opts = {}) {\n  const options = normaliseOptions(opts, inspect);\n  const { customInspect } = options;\n  let type = value === null ? \"null\" : typeof value;\n  if (type === \"object\") {\n    type = toString2.call(value).slice(8, -1);\n  }\n  if (type in baseTypesMap) {\n    return baseTypesMap[type](value, options);\n  }\n  if (customInspect && value) {\n    const output = inspectCustom(value, options, type, inspect);\n    if (output) {\n      if (typeof output === \"string\")\n        return output;\n      return inspect(output, options);\n    }\n  }\n  const proto = value ? Object.getPrototypeOf(value) : false;\n  if (proto === Object.prototype || proto === null) {\n    return inspectObject(value, options);\n  }\n  if (value && typeof HTMLElement === \"function\" && value instanceof HTMLElement) {\n    return inspectHTML(value, options);\n  }\n  if (\"constructor\" in value) {\n    if (value.constructor !== Object) {\n      return inspectClass(value, options);\n    }\n    return inspectObject(value, options);\n  }\n  if (value === Object(value)) {\n    return inspectObject(value, options);\n  }\n  return options.stylize(String(value), type);\n}\n__name(inspect, \"inspect\");\n\n// ../node_modules/@vitest/utils/dist/chunk-_commonjsHelpers.js\nvar { AsymmetricMatcher, DOMCollection, DOMElement, Immutable, ReactElement, ReactTestComponent } = plugins;\nvar PLUGINS = [\n  ReactTestComponent,\n  ReactElement,\n  DOMElement,\n  DOMCollection,\n  Immutable,\n  AsymmetricMatcher\n];\nfunction stringify(object, maxDepth = 10, { maxLength, ...options } = {}) {\n  const MAX_LENGTH = maxLength ?? 1e4;\n  let result;\n  try {\n    result = format(object, {\n      maxDepth,\n      escapeString: false,\n      plugins: PLUGINS,\n      ...options\n    });\n  } catch {\n    result = format(object, {\n      callToJSON: false,\n      maxDepth,\n      escapeString: false,\n      plugins: PLUGINS,\n      ...options\n    });\n  }\n  return result.length >= MAX_LENGTH && maxDepth > 1 ? stringify(object, Math.floor(Math.min(maxDepth, Number.MAX_SAFE_INTEGER) / 2), {\n    maxLength,\n    ...options\n  }) : result;\n}\n__name(stringify, \"stringify\");\nvar formatRegExp = /%[sdjifoOc%]/g;\nfunction format2(...args) {\n  if (typeof args[0] !== \"string\") {\n    const objects = [];\n    for (let i2 = 0; i2 < args.length; i2++) {\n      objects.push(inspect2(args[i2], {\n        depth: 0,\n        colors: false\n      }));\n    }\n    return objects.join(\" \");\n  }\n  const len = args.length;\n  let i = 1;\n  const template = args[0];\n  let str = String(template).replace(formatRegExp, (x) => {\n    if (x === \"%%\") {\n      return \"%\";\n    }\n    if (i >= len) {\n      return x;\n    }\n    switch (x) {\n      case \"%s\": {\n        const value = args[i++];\n        if (typeof value === \"bigint\") {\n          return `${value.toString()}n`;\n        }\n        if (typeof value === \"number\" && value === 0 && 1 / value < 0) {\n          return \"-0\";\n        }\n        if (typeof value === \"object\" && value !== null) {\n          if (typeof value.toString === \"function\" && value.toString !== Object.prototype.toString) {\n            return value.toString();\n          }\n          return inspect2(value, {\n            depth: 0,\n            colors: false\n          });\n        }\n        return String(value);\n      }\n      case \"%d\": {\n        const value = args[i++];\n        if (typeof value === \"bigint\") {\n          return `${value.toString()}n`;\n        }\n        return Number(value).toString();\n      }\n      case \"%i\": {\n        const value = args[i++];\n        if (typeof value === \"bigint\") {\n          return `${value.toString()}n`;\n        }\n        return Number.parseInt(String(value)).toString();\n      }\n      case \"%f\":\n        return Number.parseFloat(String(args[i++])).toString();\n      case \"%o\":\n        return inspect2(args[i++], {\n          showHidden: true,\n          showProxy: true\n        });\n      case \"%O\":\n        return inspect2(args[i++]);\n      case \"%c\": {\n        i++;\n        return \"\";\n      }\n      case \"%j\":\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (err) {\n          const m2 = err.message;\n          if (m2.includes(\"circular structure\") || m2.includes(\"cyclic structures\") || m2.includes(\"cyclic object\")) {\n            return \"[Circular]\";\n          }\n          throw err;\n        }\n      default:\n        return x;\n    }\n  });\n  for (let x = args[i]; i < len; x = args[++i]) {\n    if (x === null || typeof x !== \"object\") {\n      str += ` ${x}`;\n    } else {\n      str += ` ${inspect2(x)}`;\n    }\n  }\n  return str;\n}\n__name(format2, \"format\");\nfunction inspect2(obj, options = {}) {\n  if (options.truncate === 0) {\n    options.truncate = Number.POSITIVE_INFINITY;\n  }\n  return inspect(obj, options);\n}\n__name(inspect2, \"inspect\");\nfunction getDefaultExportFromCjs2(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\n__name(getDefaultExportFromCjs2, \"getDefaultExportFromCjs\");\n\n// ../node_modules/@vitest/utils/dist/helpers.js\nfunction assertTypes(value, name, types) {\n  const receivedType = typeof value;\n  const pass = types.includes(receivedType);\n  if (!pass) {\n    throw new TypeError(`${name} value must be ${types.join(\" or \")}, received \"${receivedType}\"`);\n  }\n}\n__name(assertTypes, \"assertTypes\");\nfunction isObject(item) {\n  return item != null && typeof item === \"object\" && !Array.isArray(item);\n}\n__name(isObject, \"isObject\");\nfunction isFinalObj(obj) {\n  return obj === Object.prototype || obj === Function.prototype || obj === RegExp.prototype;\n}\n__name(isFinalObj, \"isFinalObj\");\nfunction getType2(value) {\n  return Object.prototype.toString.apply(value).slice(8, -1);\n}\n__name(getType2, \"getType\");\nfunction collectOwnProperties(obj, collector) {\n  const collect = typeof collector === \"function\" ? collector : (key) => collector.add(key);\n  Object.getOwnPropertyNames(obj).forEach(collect);\n  Object.getOwnPropertySymbols(obj).forEach(collect);\n}\n__name(collectOwnProperties, \"collectOwnProperties\");\nfunction getOwnProperties(obj) {\n  const ownProps = /* @__PURE__ */ new Set();\n  if (isFinalObj(obj)) {\n    return [];\n  }\n  collectOwnProperties(obj, ownProps);\n  return Array.from(ownProps);\n}\n__name(getOwnProperties, \"getOwnProperties\");\nvar defaultCloneOptions = { forceWritable: false };\nfunction deepClone(val, options = defaultCloneOptions) {\n  const seen = /* @__PURE__ */ new WeakMap();\n  return clone(val, seen, options);\n}\n__name(deepClone, \"deepClone\");\nfunction clone(val, seen, options = defaultCloneOptions) {\n  let k, out;\n  if (seen.has(val)) {\n    return seen.get(val);\n  }\n  if (Array.isArray(val)) {\n    out = Array.from({ length: k = val.length });\n    seen.set(val, out);\n    while (k--) {\n      out[k] = clone(val[k], seen, options);\n    }\n    return out;\n  }\n  if (Object.prototype.toString.call(val) === \"[object Object]\") {\n    out = Object.create(Object.getPrototypeOf(val));\n    seen.set(val, out);\n    const props = getOwnProperties(val);\n    for (const k2 of props) {\n      const descriptor = Object.getOwnPropertyDescriptor(val, k2);\n      if (!descriptor) {\n        continue;\n      }\n      const cloned = clone(val[k2], seen, options);\n      if (options.forceWritable) {\n        Object.defineProperty(out, k2, {\n          enumerable: descriptor.enumerable,\n          configurable: true,\n          writable: true,\n          value: cloned\n        });\n      } else if (\"get\" in descriptor) {\n        Object.defineProperty(out, k2, {\n          ...descriptor,\n          get() {\n            return cloned;\n          }\n        });\n      } else {\n        Object.defineProperty(out, k2, {\n          ...descriptor,\n          value: cloned\n        });\n      }\n    }\n    return out;\n  }\n  return val;\n}\n__name(clone, \"clone\");\nfunction noop() {\n}\n__name(noop, \"noop\");\n\n// ../node_modules/@vitest/utils/dist/diff.js\nvar DIFF_DELETE = -1;\nvar DIFF_INSERT = 1;\nvar DIFF_EQUAL = 0;\nvar _Diff = class _Diff {\n  0;\n  1;\n  constructor(op, text) {\n    this[0] = op;\n    this[1] = text;\n  }\n};\n__name(_Diff, \"Diff\");\nvar Diff = _Diff;\nfunction diff_commonPrefix(text1, text2) {\n  if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {\n    return 0;\n  }\n  let pointermin = 0;\n  let pointermax = Math.min(text1.length, text2.length);\n  let pointermid = pointermax;\n  let pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid)) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n}\n__name(diff_commonPrefix, \"diff_commonPrefix\");\nfunction diff_commonSuffix(text1, text2) {\n  if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1)) {\n    return 0;\n  }\n  let pointermin = 0;\n  let pointermax = Math.min(text1.length, text2.length);\n  let pointermid = pointermax;\n  let pointerend = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n}\n__name(diff_commonSuffix, \"diff_commonSuffix\");\nfunction diff_commonOverlap_(text1, text2) {\n  const text1_length = text1.length;\n  const text2_length = text2.length;\n  if (text1_length === 0 || text2_length === 0) {\n    return 0;\n  }\n  if (text1_length > text2_length) {\n    text1 = text1.substring(text1_length - text2_length);\n  } else if (text1_length < text2_length) {\n    text2 = text2.substring(0, text1_length);\n  }\n  const text_length = Math.min(text1_length, text2_length);\n  if (text1 === text2) {\n    return text_length;\n  }\n  let best = 0;\n  let length = 1;\n  while (true) {\n    const pattern = text1.substring(text_length - length);\n    const found = text2.indexOf(pattern);\n    if (found === -1) {\n      return best;\n    }\n    length += found;\n    if (found === 0 || text1.substring(text_length - length) === text2.substring(0, length)) {\n      best = length;\n      length++;\n    }\n  }\n}\n__name(diff_commonOverlap_, \"diff_commonOverlap_\");\nfunction diff_cleanupSemantic(diffs) {\n  let changes = false;\n  const equalities = [];\n  let equalitiesLength = 0;\n  let lastEquality = null;\n  let pointer = 0;\n  let length_insertions1 = 0;\n  let length_deletions1 = 0;\n  let length_insertions2 = 0;\n  let length_deletions2 = 0;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] === DIFF_EQUAL) {\n      equalities[equalitiesLength++] = pointer;\n      length_insertions1 = length_insertions2;\n      length_deletions1 = length_deletions2;\n      length_insertions2 = 0;\n      length_deletions2 = 0;\n      lastEquality = diffs[pointer][1];\n    } else {\n      if (diffs[pointer][0] === DIFF_INSERT) {\n        length_insertions2 += diffs[pointer][1].length;\n      } else {\n        length_deletions2 += diffs[pointer][1].length;\n      }\n      if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2)) {\n        diffs.splice(equalities[equalitiesLength - 1], 0, new Diff(DIFF_DELETE, lastEquality));\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        equalitiesLength--;\n        equalitiesLength--;\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n        length_insertions1 = 0;\n        length_deletions1 = 0;\n        length_insertions2 = 0;\n        length_deletions2 = 0;\n        lastEquality = null;\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  if (changes) {\n    diff_cleanupMerge(diffs);\n  }\n  diff_cleanupSemanticLossless(diffs);\n  pointer = 1;\n  while (pointer < diffs.length) {\n    if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {\n      const deletion = diffs[pointer - 1][1];\n      const insertion = diffs[pointer][1];\n      const overlap_length1 = diff_commonOverlap_(deletion, insertion);\n      const overlap_length2 = diff_commonOverlap_(insertion, deletion);\n      if (overlap_length1 >= overlap_length2) {\n        if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {\n          diffs.splice(pointer, 0, new Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1)));\n          diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\n          pointer++;\n        }\n      } else {\n        if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {\n          diffs.splice(pointer, 0, new Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2)));\n          diffs[pointer - 1][0] = DIFF_INSERT;\n          diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);\n          diffs[pointer + 1][0] = DIFF_DELETE;\n          diffs[pointer + 1][1] = deletion.substring(overlap_length2);\n          pointer++;\n        }\n      }\n      pointer++;\n    }\n    pointer++;\n  }\n}\n__name(diff_cleanupSemantic, \"diff_cleanupSemantic\");\nvar nonAlphaNumericRegex_ = /[^a-z0-9]/i;\nvar whitespaceRegex_ = /\\s/;\nvar linebreakRegex_ = /[\\r\\n]/;\nvar blanklineEndRegex_ = /\\n\\r?\\n$/;\nvar blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\nfunction diff_cleanupSemanticLossless(diffs) {\n  let pointer = 1;\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n      let equality1 = diffs[pointer - 1][1];\n      let edit = diffs[pointer][1];\n      let equality2 = diffs[pointer + 1][1];\n      const commonOffset = diff_commonSuffix(equality1, edit);\n      if (commonOffset) {\n        const commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\n        equality2 = commonString + equality2;\n      }\n      let bestEquality1 = equality1;\n      let bestEdit = edit;\n      let bestEquality2 = equality2;\n      let bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);\n      while (edit.charAt(0) === equality2.charAt(0)) {\n        equality1 += edit.charAt(0);\n        edit = edit.substring(1) + equality2.charAt(0);\n        equality2 = equality2.substring(1);\n        const score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);\n        if (score >= bestScore) {\n          bestScore = score;\n          bestEquality1 = equality1;\n          bestEdit = edit;\n          bestEquality2 = equality2;\n        }\n      }\n      if (diffs[pointer - 1][1] !== bestEquality1) {\n        if (bestEquality1) {\n          diffs[pointer - 1][1] = bestEquality1;\n        } else {\n          diffs.splice(pointer - 1, 1);\n          pointer--;\n        }\n        diffs[pointer][1] = bestEdit;\n        if (bestEquality2) {\n          diffs[pointer + 1][1] = bestEquality2;\n        } else {\n          diffs.splice(pointer + 1, 1);\n          pointer--;\n        }\n      }\n    }\n    pointer++;\n  }\n}\n__name(diff_cleanupSemanticLossless, \"diff_cleanupSemanticLossless\");\nfunction diff_cleanupMerge(diffs) {\n  diffs.push(new Diff(DIFF_EQUAL, \"\"));\n  let pointer = 0;\n  let count_delete = 0;\n  let count_insert = 0;\n  let text_delete = \"\";\n  let text_insert = \"\";\n  let commonlength;\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        if (count_delete + count_insert > 1) {\n          if (count_delete !== 0 && count_insert !== 0) {\n            commonlength = diff_commonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] === DIFF_EQUAL) {\n                diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(0, 0, new Diff(DIFF_EQUAL, text_insert.substring(0, commonlength)));\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            }\n            commonlength = diff_commonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];\n              text_insert = text_insert.substring(0, text_insert.length - commonlength);\n              text_delete = text_delete.substring(0, text_delete.length - commonlength);\n            }\n          }\n          pointer -= count_delete + count_insert;\n          diffs.splice(pointer, count_delete + count_insert);\n          if (text_delete.length) {\n            diffs.splice(pointer, 0, new Diff(DIFF_DELETE, text_delete));\n            pointer++;\n          }\n          if (text_insert.length) {\n            diffs.splice(pointer, 0, new Diff(DIFF_INSERT, text_insert));\n            pointer++;\n          }\n          pointer++;\n        } else if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = \"\";\n        text_insert = \"\";\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === \"\") {\n    diffs.pop();\n  }\n  let changes = false;\n  pointer = 1;\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n      if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {\n        diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1]) {\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  if (changes) {\n    diff_cleanupMerge(diffs);\n  }\n}\n__name(diff_cleanupMerge, \"diff_cleanupMerge\");\nfunction diff_cleanupSemanticScore_(one, two) {\n  if (!one || !two) {\n    return 6;\n  }\n  const char1 = one.charAt(one.length - 1);\n  const char2 = two.charAt(0);\n  const nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);\n  const nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);\n  const whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);\n  const whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);\n  const lineBreak1 = whitespace1 && char1.match(linebreakRegex_);\n  const lineBreak2 = whitespace2 && char2.match(linebreakRegex_);\n  const blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);\n  const blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);\n  if (blankLine1 || blankLine2) {\n    return 5;\n  } else if (lineBreak1 || lineBreak2) {\n    return 4;\n  } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n    return 3;\n  } else if (whitespace1 || whitespace2) {\n    return 2;\n  } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n    return 1;\n  }\n  return 0;\n}\n__name(diff_cleanupSemanticScore_, \"diff_cleanupSemanticScore_\");\nvar NO_DIFF_MESSAGE = \"Compared values have no visual difference.\";\nvar SIMILAR_MESSAGE = \"Compared values serialize to the same structure.\\nPrinting internal object structure without calling `toJSON` instead.\";\nvar build = {};\nvar hasRequiredBuild;\nfunction requireBuild() {\n  if (hasRequiredBuild) return build;\n  hasRequiredBuild = 1;\n  Object.defineProperty(build, \"__esModule\", {\n    value: true\n  });\n  build.default = diffSequence;\n  const pkg = \"diff-sequences\";\n  const NOT_YET_SET = 0;\n  const countCommonItemsF = /* @__PURE__ */ __name((aIndex, aEnd, bIndex, bEnd, isCommon) => {\n    let nCommon = 0;\n    while (aIndex < aEnd && bIndex < bEnd && isCommon(aIndex, bIndex)) {\n      aIndex += 1;\n      bIndex += 1;\n      nCommon += 1;\n    }\n    return nCommon;\n  }, \"countCommonItemsF\");\n  const countCommonItemsR = /* @__PURE__ */ __name((aStart, aIndex, bStart, bIndex, isCommon) => {\n    let nCommon = 0;\n    while (aStart <= aIndex && bStart <= bIndex && isCommon(aIndex, bIndex)) {\n      aIndex -= 1;\n      bIndex -= 1;\n      nCommon += 1;\n    }\n    return nCommon;\n  }, \"countCommonItemsR\");\n  const extendPathsF = /* @__PURE__ */ __name((d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF) => {\n    let iF = 0;\n    let kF = -d;\n    let aFirst = aIndexesF[iF];\n    let aIndexPrev1 = aFirst;\n    aIndexesF[iF] += countCommonItemsF(\n      aFirst + 1,\n      aEnd,\n      bF + aFirst - kF + 1,\n      bEnd,\n      isCommon\n    );\n    const nF = d < iMaxF ? d : iMaxF;\n    for (iF += 1, kF += 2; iF <= nF; iF += 1, kF += 2) {\n      if (iF !== d && aIndexPrev1 < aIndexesF[iF]) {\n        aFirst = aIndexesF[iF];\n      } else {\n        aFirst = aIndexPrev1 + 1;\n        if (aEnd <= aFirst) {\n          return iF - 1;\n        }\n      }\n      aIndexPrev1 = aIndexesF[iF];\n      aIndexesF[iF] = aFirst + countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);\n    }\n    return iMaxF;\n  }, \"extendPathsF\");\n  const extendPathsR = /* @__PURE__ */ __name((d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR) => {\n    let iR = 0;\n    let kR = d;\n    let aFirst = aIndexesR[iR];\n    let aIndexPrev1 = aFirst;\n    aIndexesR[iR] -= countCommonItemsR(\n      aStart,\n      aFirst - 1,\n      bStart,\n      bR + aFirst - kR - 1,\n      isCommon\n    );\n    const nR = d < iMaxR ? d : iMaxR;\n    for (iR += 1, kR -= 2; iR <= nR; iR += 1, kR -= 2) {\n      if (iR !== d && aIndexesR[iR] < aIndexPrev1) {\n        aFirst = aIndexesR[iR];\n      } else {\n        aFirst = aIndexPrev1 - 1;\n        if (aFirst < aStart) {\n          return iR - 1;\n        }\n      }\n      aIndexPrev1 = aIndexesR[iR];\n      aIndexesR[iR] = aFirst - countCommonItemsR(\n        aStart,\n        aFirst - 1,\n        bStart,\n        bR + aFirst - kR - 1,\n        isCommon\n      );\n    }\n    return iMaxR;\n  }, \"extendPathsR\");\n  const extendOverlappablePathsF = /* @__PURE__ */ __name((d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {\n    const bF = bStart - aStart;\n    const aLength = aEnd - aStart;\n    const bLength = bEnd - bStart;\n    const baDeltaLength = bLength - aLength;\n    const kMinOverlapF = -baDeltaLength - (d - 1);\n    const kMaxOverlapF = -baDeltaLength + (d - 1);\n    let aIndexPrev1 = NOT_YET_SET;\n    const nF = d < iMaxF ? d : iMaxF;\n    for (let iF = 0, kF = -d; iF <= nF; iF += 1, kF += 2) {\n      const insert = iF === 0 || iF !== d && aIndexPrev1 < aIndexesF[iF];\n      const aLastPrev = insert ? aIndexesF[iF] : aIndexPrev1;\n      const aFirst = insert ? aLastPrev : aLastPrev + 1;\n      const bFirst = bF + aFirst - kF;\n      const nCommonF = countCommonItemsF(\n        aFirst + 1,\n        aEnd,\n        bFirst + 1,\n        bEnd,\n        isCommon\n      );\n      const aLast = aFirst + nCommonF;\n      aIndexPrev1 = aIndexesF[iF];\n      aIndexesF[iF] = aLast;\n      if (kMinOverlapF <= kF && kF <= kMaxOverlapF) {\n        const iR = (d - 1 - (kF + baDeltaLength)) / 2;\n        if (iR <= iMaxR && aIndexesR[iR] - 1 <= aLast) {\n          const bLastPrev = bF + aLastPrev - (insert ? kF + 1 : kF - 1);\n          const nCommonR = countCommonItemsR(\n            aStart,\n            aLastPrev,\n            bStart,\n            bLastPrev,\n            isCommon\n          );\n          const aIndexPrevFirst = aLastPrev - nCommonR;\n          const bIndexPrevFirst = bLastPrev - nCommonR;\n          const aEndPreceding = aIndexPrevFirst + 1;\n          const bEndPreceding = bIndexPrevFirst + 1;\n          division.nChangePreceding = d - 1;\n          if (d - 1 === aEndPreceding + bEndPreceding - aStart - bStart) {\n            division.aEndPreceding = aStart;\n            division.bEndPreceding = bStart;\n          } else {\n            division.aEndPreceding = aEndPreceding;\n            division.bEndPreceding = bEndPreceding;\n          }\n          division.nCommonPreceding = nCommonR;\n          if (nCommonR !== 0) {\n            division.aCommonPreceding = aEndPreceding;\n            division.bCommonPreceding = bEndPreceding;\n          }\n          division.nCommonFollowing = nCommonF;\n          if (nCommonF !== 0) {\n            division.aCommonFollowing = aFirst + 1;\n            division.bCommonFollowing = bFirst + 1;\n          }\n          const aStartFollowing = aLast + 1;\n          const bStartFollowing = bFirst + nCommonF + 1;\n          division.nChangeFollowing = d - 1;\n          if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {\n            division.aStartFollowing = aEnd;\n            division.bStartFollowing = bEnd;\n          } else {\n            division.aStartFollowing = aStartFollowing;\n            division.bStartFollowing = bStartFollowing;\n          }\n          return true;\n        }\n      }\n    }\n    return false;\n  }, \"extendOverlappablePathsF\");\n  const extendOverlappablePathsR = /* @__PURE__ */ __name((d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {\n    const bR = bEnd - aEnd;\n    const aLength = aEnd - aStart;\n    const bLength = bEnd - bStart;\n    const baDeltaLength = bLength - aLength;\n    const kMinOverlapR = baDeltaLength - d;\n    const kMaxOverlapR = baDeltaLength + d;\n    let aIndexPrev1 = NOT_YET_SET;\n    const nR = d < iMaxR ? d : iMaxR;\n    for (let iR = 0, kR = d; iR <= nR; iR += 1, kR -= 2) {\n      const insert = iR === 0 || iR !== d && aIndexesR[iR] < aIndexPrev1;\n      const aLastPrev = insert ? aIndexesR[iR] : aIndexPrev1;\n      const aFirst = insert ? aLastPrev : aLastPrev - 1;\n      const bFirst = bR + aFirst - kR;\n      const nCommonR = countCommonItemsR(\n        aStart,\n        aFirst - 1,\n        bStart,\n        bFirst - 1,\n        isCommon\n      );\n      const aLast = aFirst - nCommonR;\n      aIndexPrev1 = aIndexesR[iR];\n      aIndexesR[iR] = aLast;\n      if (kMinOverlapR <= kR && kR <= kMaxOverlapR) {\n        const iF = (d + (kR - baDeltaLength)) / 2;\n        if (iF <= iMaxF && aLast - 1 <= aIndexesF[iF]) {\n          const bLast = bFirst - nCommonR;\n          division.nChangePreceding = d;\n          if (d === aLast + bLast - aStart - bStart) {\n            division.aEndPreceding = aStart;\n            division.bEndPreceding = bStart;\n          } else {\n            division.aEndPreceding = aLast;\n            division.bEndPreceding = bLast;\n          }\n          division.nCommonPreceding = nCommonR;\n          if (nCommonR !== 0) {\n            division.aCommonPreceding = aLast;\n            division.bCommonPreceding = bLast;\n          }\n          division.nChangeFollowing = d - 1;\n          if (d === 1) {\n            division.nCommonFollowing = 0;\n            division.aStartFollowing = aEnd;\n            division.bStartFollowing = bEnd;\n          } else {\n            const bLastPrev = bR + aLastPrev - (insert ? kR - 1 : kR + 1);\n            const nCommonF = countCommonItemsF(\n              aLastPrev,\n              aEnd,\n              bLastPrev,\n              bEnd,\n              isCommon\n            );\n            division.nCommonFollowing = nCommonF;\n            if (nCommonF !== 0) {\n              division.aCommonFollowing = aLastPrev;\n              division.bCommonFollowing = bLastPrev;\n            }\n            const aStartFollowing = aLastPrev + nCommonF;\n            const bStartFollowing = bLastPrev + nCommonF;\n            if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {\n              division.aStartFollowing = aEnd;\n              division.bStartFollowing = bEnd;\n            } else {\n              division.aStartFollowing = aStartFollowing;\n              division.bStartFollowing = bStartFollowing;\n            }\n          }\n          return true;\n        }\n      }\n    }\n    return false;\n  }, \"extendOverlappablePathsR\");\n  const divide = /* @__PURE__ */ __name((nChange, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, aIndexesR, division) => {\n    const bF = bStart - aStart;\n    const bR = bEnd - aEnd;\n    const aLength = aEnd - aStart;\n    const bLength = bEnd - bStart;\n    const baDeltaLength = bLength - aLength;\n    let iMaxF = aLength;\n    let iMaxR = aLength;\n    aIndexesF[0] = aStart - 1;\n    aIndexesR[0] = aEnd;\n    if (baDeltaLength % 2 === 0) {\n      const dMin = (nChange || baDeltaLength) / 2;\n      const dMax = (aLength + bLength) / 2;\n      for (let d = 1; d <= dMax; d += 1) {\n        iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n        if (d < dMin) {\n          iMaxR = extendPathsR(d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);\n        } else if (\n          // If a reverse path overlaps a forward path in the same diagonal,\n          // return a division of the index intervals at the middle change.\n          extendOverlappablePathsR(\n            d,\n            aStart,\n            aEnd,\n            bStart,\n            bEnd,\n            isCommon,\n            aIndexesF,\n            iMaxF,\n            aIndexesR,\n            iMaxR,\n            division\n          )\n        ) {\n          return;\n        }\n      }\n    } else {\n      const dMin = ((nChange || baDeltaLength) + 1) / 2;\n      const dMax = (aLength + bLength + 1) / 2;\n      let d = 1;\n      iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n      for (d += 1; d <= dMax; d += 1) {\n        iMaxR = extendPathsR(\n          d - 1,\n          aStart,\n          bStart,\n          bR,\n          isCommon,\n          aIndexesR,\n          iMaxR\n        );\n        if (d < dMin) {\n          iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n        } else if (\n          // If a forward path overlaps a reverse path in the same diagonal,\n          // return a division of the index intervals at the middle change.\n          extendOverlappablePathsF(\n            d,\n            aStart,\n            aEnd,\n            bStart,\n            bEnd,\n            isCommon,\n            aIndexesF,\n            iMaxF,\n            aIndexesR,\n            iMaxR,\n            division\n          )\n        ) {\n          return;\n        }\n      }\n    }\n    throw new Error(\n      `${pkg}: no overlap aStart=${aStart} aEnd=${aEnd} bStart=${bStart} bEnd=${bEnd}`\n    );\n  }, \"divide\");\n  const findSubsequences = /* @__PURE__ */ __name((nChange, aStart, aEnd, bStart, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division) => {\n    if (bEnd - bStart < aEnd - aStart) {\n      transposed = !transposed;\n      if (transposed && callbacks.length === 1) {\n        const { foundSubsequence: foundSubsequence2, isCommon: isCommon2 } = callbacks[0];\n        callbacks[1] = {\n          foundSubsequence: /* @__PURE__ */ __name((nCommon, bCommon, aCommon) => {\n            foundSubsequence2(nCommon, aCommon, bCommon);\n          }, \"foundSubsequence\"),\n          isCommon: /* @__PURE__ */ __name((bIndex, aIndex) => isCommon2(aIndex, bIndex), \"isCommon\")\n        };\n      }\n      const tStart = aStart;\n      const tEnd = aEnd;\n      aStart = bStart;\n      aEnd = bEnd;\n      bStart = tStart;\n      bEnd = tEnd;\n    }\n    const { foundSubsequence, isCommon } = callbacks[transposed ? 1 : 0];\n    divide(\n      nChange,\n      aStart,\n      aEnd,\n      bStart,\n      bEnd,\n      isCommon,\n      aIndexesF,\n      aIndexesR,\n      division\n    );\n    const {\n      nChangePreceding,\n      aEndPreceding,\n      bEndPreceding,\n      nCommonPreceding,\n      aCommonPreceding,\n      bCommonPreceding,\n      nCommonFollowing,\n      aCommonFollowing,\n      bCommonFollowing,\n      nChangeFollowing,\n      aStartFollowing,\n      bStartFollowing\n    } = division;\n    if (aStart < aEndPreceding && bStart < bEndPreceding) {\n      findSubsequences(\n        nChangePreceding,\n        aStart,\n        aEndPreceding,\n        bStart,\n        bEndPreceding,\n        transposed,\n        callbacks,\n        aIndexesF,\n        aIndexesR,\n        division\n      );\n    }\n    if (nCommonPreceding !== 0) {\n      foundSubsequence(nCommonPreceding, aCommonPreceding, bCommonPreceding);\n    }\n    if (nCommonFollowing !== 0) {\n      foundSubsequence(nCommonFollowing, aCommonFollowing, bCommonFollowing);\n    }\n    if (aStartFollowing < aEnd && bStartFollowing < bEnd) {\n      findSubsequences(\n        nChangeFollowing,\n        aStartFollowing,\n        aEnd,\n        bStartFollowing,\n        bEnd,\n        transposed,\n        callbacks,\n        aIndexesF,\n        aIndexesR,\n        division\n      );\n    }\n  }, \"findSubsequences\");\n  const validateLength = /* @__PURE__ */ __name((name, arg) => {\n    if (typeof arg !== \"number\") {\n      throw new TypeError(`${pkg}: ${name} typeof ${typeof arg} is not a number`);\n    }\n    if (!Number.isSafeInteger(arg)) {\n      throw new RangeError(`${pkg}: ${name} value ${arg} is not a safe integer`);\n    }\n    if (arg < 0) {\n      throw new RangeError(`${pkg}: ${name} value ${arg} is a negative integer`);\n    }\n  }, \"validateLength\");\n  const validateCallback = /* @__PURE__ */ __name((name, arg) => {\n    const type = typeof arg;\n    if (type !== \"function\") {\n      throw new TypeError(`${pkg}: ${name} typeof ${type} is not a function`);\n    }\n  }, \"validateCallback\");\n  function diffSequence(aLength, bLength, isCommon, foundSubsequence) {\n    validateLength(\"aLength\", aLength);\n    validateLength(\"bLength\", bLength);\n    validateCallback(\"isCommon\", isCommon);\n    validateCallback(\"foundSubsequence\", foundSubsequence);\n    const nCommonF = countCommonItemsF(0, aLength, 0, bLength, isCommon);\n    if (nCommonF !== 0) {\n      foundSubsequence(nCommonF, 0, 0);\n    }\n    if (aLength !== nCommonF || bLength !== nCommonF) {\n      const aStart = nCommonF;\n      const bStart = nCommonF;\n      const nCommonR = countCommonItemsR(\n        aStart,\n        aLength - 1,\n        bStart,\n        bLength - 1,\n        isCommon\n      );\n      const aEnd = aLength - nCommonR;\n      const bEnd = bLength - nCommonR;\n      const nCommonFR = nCommonF + nCommonR;\n      if (aLength !== nCommonFR && bLength !== nCommonFR) {\n        const nChange = 0;\n        const transposed = false;\n        const callbacks = [\n          {\n            foundSubsequence,\n            isCommon\n          }\n        ];\n        const aIndexesF = [NOT_YET_SET];\n        const aIndexesR = [NOT_YET_SET];\n        const division = {\n          aCommonFollowing: NOT_YET_SET,\n          aCommonPreceding: NOT_YET_SET,\n          aEndPreceding: NOT_YET_SET,\n          aStartFollowing: NOT_YET_SET,\n          bCommonFollowing: NOT_YET_SET,\n          bCommonPreceding: NOT_YET_SET,\n          bEndPreceding: NOT_YET_SET,\n          bStartFollowing: NOT_YET_SET,\n          nChangeFollowing: NOT_YET_SET,\n          nChangePreceding: NOT_YET_SET,\n          nCommonFollowing: NOT_YET_SET,\n          nCommonPreceding: NOT_YET_SET\n        };\n        findSubsequences(\n          nChange,\n          aStart,\n          aEnd,\n          bStart,\n          bEnd,\n          transposed,\n          callbacks,\n          aIndexesF,\n          aIndexesR,\n          division\n        );\n      }\n      if (nCommonR !== 0) {\n        foundSubsequence(nCommonR, aEnd, bEnd);\n      }\n    }\n  }\n  __name(diffSequence, \"diffSequence\");\n  return build;\n}\n__name(requireBuild, \"requireBuild\");\nvar buildExports = requireBuild();\nvar diffSequences = getDefaultExportFromCjs2(buildExports);\nfunction formatTrailingSpaces(line, trailingSpaceFormatter) {\n  return line.replace(/\\s+$/, (match) => trailingSpaceFormatter(match));\n}\n__name(formatTrailingSpaces, \"formatTrailingSpaces\");\nfunction printDiffLine(line, isFirstOrLast, color, indicator, trailingSpaceFormatter, emptyFirstOrLastLinePlaceholder) {\n  return line.length !== 0 ? color(`${indicator} ${formatTrailingSpaces(line, trailingSpaceFormatter)}`) : indicator !== \" \" ? color(indicator) : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0 ? color(`${indicator} ${emptyFirstOrLastLinePlaceholder}`) : \"\";\n}\n__name(printDiffLine, \"printDiffLine\");\nfunction printDeleteLine(line, isFirstOrLast, { aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {\n  return printDiffLine(line, isFirstOrLast, aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);\n}\n__name(printDeleteLine, \"printDeleteLine\");\nfunction printInsertLine(line, isFirstOrLast, { bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {\n  return printDiffLine(line, isFirstOrLast, bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);\n}\n__name(printInsertLine, \"printInsertLine\");\nfunction printCommonLine(line, isFirstOrLast, { commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {\n  return printDiffLine(line, isFirstOrLast, commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);\n}\n__name(printCommonLine, \"printCommonLine\");\nfunction createPatchMark(aStart, aEnd, bStart, bEnd, { patchColor }) {\n  return patchColor(`@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`);\n}\n__name(createPatchMark, \"createPatchMark\");\nfunction joinAlignedDiffsNoExpand(diffs, options) {\n  const iLength = diffs.length;\n  const nContextLines = options.contextLines;\n  const nContextLines2 = nContextLines + nContextLines;\n  let jLength = iLength;\n  let hasExcessAtStartOrEnd = false;\n  let nExcessesBetweenChanges = 0;\n  let i = 0;\n  while (i !== iLength) {\n    const iStart = i;\n    while (i !== iLength && diffs[i][0] === DIFF_EQUAL) {\n      i += 1;\n    }\n    if (iStart !== i) {\n      if (iStart === 0) {\n        if (i > nContextLines) {\n          jLength -= i - nContextLines;\n          hasExcessAtStartOrEnd = true;\n        }\n      } else if (i === iLength) {\n        const n = i - iStart;\n        if (n > nContextLines) {\n          jLength -= n - nContextLines;\n          hasExcessAtStartOrEnd = true;\n        }\n      } else {\n        const n = i - iStart;\n        if (n > nContextLines2) {\n          jLength -= n - nContextLines2;\n          nExcessesBetweenChanges += 1;\n        }\n      }\n    }\n    while (i !== iLength && diffs[i][0] !== DIFF_EQUAL) {\n      i += 1;\n    }\n  }\n  const hasPatch = nExcessesBetweenChanges !== 0 || hasExcessAtStartOrEnd;\n  if (nExcessesBetweenChanges !== 0) {\n    jLength += nExcessesBetweenChanges + 1;\n  } else if (hasExcessAtStartOrEnd) {\n    jLength += 1;\n  }\n  const jLast = jLength - 1;\n  const lines = [];\n  let jPatchMark = 0;\n  if (hasPatch) {\n    lines.push(\"\");\n  }\n  let aStart = 0;\n  let bStart = 0;\n  let aEnd = 0;\n  let bEnd = 0;\n  const pushCommonLine = /* @__PURE__ */ __name((line) => {\n    const j = lines.length;\n    lines.push(printCommonLine(line, j === 0 || j === jLast, options));\n    aEnd += 1;\n    bEnd += 1;\n  }, \"pushCommonLine\");\n  const pushDeleteLine = /* @__PURE__ */ __name((line) => {\n    const j = lines.length;\n    lines.push(printDeleteLine(line, j === 0 || j === jLast, options));\n    aEnd += 1;\n  }, \"pushDeleteLine\");\n  const pushInsertLine = /* @__PURE__ */ __name((line) => {\n    const j = lines.length;\n    lines.push(printInsertLine(line, j === 0 || j === jLast, options));\n    bEnd += 1;\n  }, \"pushInsertLine\");\n  i = 0;\n  while (i !== iLength) {\n    let iStart = i;\n    while (i !== iLength && diffs[i][0] === DIFF_EQUAL) {\n      i += 1;\n    }\n    if (iStart !== i) {\n      if (iStart === 0) {\n        if (i > nContextLines) {\n          iStart = i - nContextLines;\n          aStart = iStart;\n          bStart = iStart;\n          aEnd = aStart;\n          bEnd = bStart;\n        }\n        for (let iCommon = iStart; iCommon !== i; iCommon += 1) {\n          pushCommonLine(diffs[iCommon][1]);\n        }\n      } else if (i === iLength) {\n        const iEnd = i - iStart > nContextLines ? iStart + nContextLines : i;\n        for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {\n          pushCommonLine(diffs[iCommon][1]);\n        }\n      } else {\n        const nCommon = i - iStart;\n        if (nCommon > nContextLines2) {\n          const iEnd = iStart + nContextLines;\n          for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {\n            pushCommonLine(diffs[iCommon][1]);\n          }\n          lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);\n          jPatchMark = lines.length;\n          lines.push(\"\");\n          const nOmit = nCommon - nContextLines2;\n          aStart = aEnd + nOmit;\n          bStart = bEnd + nOmit;\n          aEnd = aStart;\n          bEnd = bStart;\n          for (let iCommon = i - nContextLines; iCommon !== i; iCommon += 1) {\n            pushCommonLine(diffs[iCommon][1]);\n          }\n        } else {\n          for (let iCommon = iStart; iCommon !== i; iCommon += 1) {\n            pushCommonLine(diffs[iCommon][1]);\n          }\n        }\n      }\n    }\n    while (i !== iLength && diffs[i][0] === DIFF_DELETE) {\n      pushDeleteLine(diffs[i][1]);\n      i += 1;\n    }\n    while (i !== iLength && diffs[i][0] === DIFF_INSERT) {\n      pushInsertLine(diffs[i][1]);\n      i += 1;\n    }\n  }\n  if (hasPatch) {\n    lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);\n  }\n  return lines.join(\"\\n\");\n}\n__name(joinAlignedDiffsNoExpand, \"joinAlignedDiffsNoExpand\");\nfunction joinAlignedDiffsExpand(diffs, options) {\n  return diffs.map((diff2, i, diffs2) => {\n    const line = diff2[1];\n    const isFirstOrLast = i === 0 || i === diffs2.length - 1;\n    switch (diff2[0]) {\n      case DIFF_DELETE:\n        return printDeleteLine(line, isFirstOrLast, options);\n      case DIFF_INSERT:\n        return printInsertLine(line, isFirstOrLast, options);\n      default:\n        return printCommonLine(line, isFirstOrLast, options);\n    }\n  }).join(\"\\n\");\n}\n__name(joinAlignedDiffsExpand, \"joinAlignedDiffsExpand\");\nvar noColor = /* @__PURE__ */ __name((string) => string, \"noColor\");\nvar DIFF_CONTEXT_DEFAULT = 5;\nvar DIFF_TRUNCATE_THRESHOLD_DEFAULT = 0;\nfunction getDefaultOptions() {\n  return {\n    aAnnotation: \"Expected\",\n    aColor: s.green,\n    aIndicator: \"-\",\n    bAnnotation: \"Received\",\n    bColor: s.red,\n    bIndicator: \"+\",\n    changeColor: s.inverse,\n    changeLineTrailingSpaceColor: noColor,\n    commonColor: s.dim,\n    commonIndicator: \" \",\n    commonLineTrailingSpaceColor: noColor,\n    compareKeys: void 0,\n    contextLines: DIFF_CONTEXT_DEFAULT,\n    emptyFirstOrLastLinePlaceholder: \"\",\n    expand: false,\n    includeChangeCounts: false,\n    omitAnnotationLines: false,\n    patchColor: s.yellow,\n    printBasicPrototype: false,\n    truncateThreshold: DIFF_TRUNCATE_THRESHOLD_DEFAULT,\n    truncateAnnotation: \"... Diff result is truncated\",\n    truncateAnnotationColor: noColor\n  };\n}\n__name(getDefaultOptions, \"getDefaultOptions\");\nfunction getCompareKeys(compareKeys) {\n  return compareKeys && typeof compareKeys === \"function\" ? compareKeys : void 0;\n}\n__name(getCompareKeys, \"getCompareKeys\");\nfunction getContextLines(contextLines) {\n  return typeof contextLines === \"number\" && Number.isSafeInteger(contextLines) && contextLines >= 0 ? contextLines : DIFF_CONTEXT_DEFAULT;\n}\n__name(getContextLines, \"getContextLines\");\nfunction normalizeDiffOptions(options = {}) {\n  return {\n    ...getDefaultOptions(),\n    ...options,\n    compareKeys: getCompareKeys(options.compareKeys),\n    contextLines: getContextLines(options.contextLines)\n  };\n}\n__name(normalizeDiffOptions, \"normalizeDiffOptions\");\nfunction isEmptyString(lines) {\n  return lines.length === 1 && lines[0].length === 0;\n}\n__name(isEmptyString, \"isEmptyString\");\nfunction countChanges(diffs) {\n  let a2 = 0;\n  let b = 0;\n  diffs.forEach((diff2) => {\n    switch (diff2[0]) {\n      case DIFF_DELETE:\n        a2 += 1;\n        break;\n      case DIFF_INSERT:\n        b += 1;\n        break;\n    }\n  });\n  return {\n    a: a2,\n    b\n  };\n}\n__name(countChanges, \"countChanges\");\nfunction printAnnotation({ aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator, includeChangeCounts, omitAnnotationLines }, changeCounts) {\n  if (omitAnnotationLines) {\n    return \"\";\n  }\n  let aRest = \"\";\n  let bRest = \"\";\n  if (includeChangeCounts) {\n    const aCount = String(changeCounts.a);\n    const bCount = String(changeCounts.b);\n    const baAnnotationLengthDiff = bAnnotation.length - aAnnotation.length;\n    const aAnnotationPadding = \" \".repeat(Math.max(0, baAnnotationLengthDiff));\n    const bAnnotationPadding = \" \".repeat(Math.max(0, -baAnnotationLengthDiff));\n    const baCountLengthDiff = bCount.length - aCount.length;\n    const aCountPadding = \" \".repeat(Math.max(0, baCountLengthDiff));\n    const bCountPadding = \" \".repeat(Math.max(0, -baCountLengthDiff));\n    aRest = `${aAnnotationPadding}  ${aIndicator} ${aCountPadding}${aCount}`;\n    bRest = `${bAnnotationPadding}  ${bIndicator} ${bCountPadding}${bCount}`;\n  }\n  const a2 = `${aIndicator} ${aAnnotation}${aRest}`;\n  const b = `${bIndicator} ${bAnnotation}${bRest}`;\n  return `${aColor(a2)}\n${bColor(b)}\n\n`;\n}\n__name(printAnnotation, \"printAnnotation\");\nfunction printDiffLines(diffs, truncated, options) {\n  return printAnnotation(options, countChanges(diffs)) + (options.expand ? joinAlignedDiffsExpand(diffs, options) : joinAlignedDiffsNoExpand(diffs, options)) + (truncated ? options.truncateAnnotationColor(`\n${options.truncateAnnotation}`) : \"\");\n}\n__name(printDiffLines, \"printDiffLines\");\nfunction diffLinesUnified(aLines, bLines, options) {\n  const normalizedOptions = normalizeDiffOptions(options);\n  const [diffs, truncated] = diffLinesRaw(isEmptyString(aLines) ? [] : aLines, isEmptyString(bLines) ? [] : bLines, normalizedOptions);\n  return printDiffLines(diffs, truncated, normalizedOptions);\n}\n__name(diffLinesUnified, \"diffLinesUnified\");\nfunction diffLinesUnified2(aLinesDisplay, bLinesDisplay, aLinesCompare, bLinesCompare, options) {\n  if (isEmptyString(aLinesDisplay) && isEmptyString(aLinesCompare)) {\n    aLinesDisplay = [];\n    aLinesCompare = [];\n  }\n  if (isEmptyString(bLinesDisplay) && isEmptyString(bLinesCompare)) {\n    bLinesDisplay = [];\n    bLinesCompare = [];\n  }\n  if (aLinesDisplay.length !== aLinesCompare.length || bLinesDisplay.length !== bLinesCompare.length) {\n    return diffLinesUnified(aLinesDisplay, bLinesDisplay, options);\n  }\n  const [diffs, truncated] = diffLinesRaw(aLinesCompare, bLinesCompare, options);\n  let aIndex = 0;\n  let bIndex = 0;\n  diffs.forEach((diff2) => {\n    switch (diff2[0]) {\n      case DIFF_DELETE:\n        diff2[1] = aLinesDisplay[aIndex];\n        aIndex += 1;\n        break;\n      case DIFF_INSERT:\n        diff2[1] = bLinesDisplay[bIndex];\n        bIndex += 1;\n        break;\n      default:\n        diff2[1] = bLinesDisplay[bIndex];\n        aIndex += 1;\n        bIndex += 1;\n    }\n  });\n  return printDiffLines(diffs, truncated, normalizeDiffOptions(options));\n}\n__name(diffLinesUnified2, \"diffLinesUnified2\");\nfunction diffLinesRaw(aLines, bLines, options) {\n  const truncate2 = (options === null || options === void 0 ? void 0 : options.truncateThreshold) ?? false;\n  const truncateThreshold = Math.max(Math.floor((options === null || options === void 0 ? void 0 : options.truncateThreshold) ?? 0), 0);\n  const aLength = truncate2 ? Math.min(aLines.length, truncateThreshold) : aLines.length;\n  const bLength = truncate2 ? Math.min(bLines.length, truncateThreshold) : bLines.length;\n  const truncated = aLength !== aLines.length || bLength !== bLines.length;\n  const isCommon = /* @__PURE__ */ __name((aIndex2, bIndex2) => aLines[aIndex2] === bLines[bIndex2], \"isCommon\");\n  const diffs = [];\n  let aIndex = 0;\n  let bIndex = 0;\n  const foundSubsequence = /* @__PURE__ */ __name((nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      diffs.push(new Diff(DIFF_EQUAL, bLines[bIndex]));\n    }\n  }, \"foundSubsequence\");\n  diffSequences(aLength, bLength, isCommon, foundSubsequence);\n  for (; aIndex !== aLength; aIndex += 1) {\n    diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));\n  }\n  return [diffs, truncated];\n}\n__name(diffLinesRaw, \"diffLinesRaw\");\nfunction getType3(value) {\n  if (value === void 0) {\n    return \"undefined\";\n  } else if (value === null) {\n    return \"null\";\n  } else if (Array.isArray(value)) {\n    return \"array\";\n  } else if (typeof value === \"boolean\") {\n    return \"boolean\";\n  } else if (typeof value === \"function\") {\n    return \"function\";\n  } else if (typeof value === \"number\") {\n    return \"number\";\n  } else if (typeof value === \"string\") {\n    return \"string\";\n  } else if (typeof value === \"bigint\") {\n    return \"bigint\";\n  } else if (typeof value === \"object\") {\n    if (value != null) {\n      if (value.constructor === RegExp) {\n        return \"regexp\";\n      } else if (value.constructor === Map) {\n        return \"map\";\n      } else if (value.constructor === Set) {\n        return \"set\";\n      } else if (value.constructor === Date) {\n        return \"date\";\n      }\n    }\n    return \"object\";\n  } else if (typeof value === \"symbol\") {\n    return \"symbol\";\n  }\n  throw new Error(`value of unknown type: ${value}`);\n}\n__name(getType3, \"getType\");\nfunction getNewLineSymbol(string) {\n  return string.includes(\"\\r\\n\") ? \"\\r\\n\" : \"\\n\";\n}\n__name(getNewLineSymbol, \"getNewLineSymbol\");\nfunction diffStrings(a2, b, options) {\n  const truncate2 = (options === null || options === void 0 ? void 0 : options.truncateThreshold) ?? false;\n  const truncateThreshold = Math.max(Math.floor((options === null || options === void 0 ? void 0 : options.truncateThreshold) ?? 0), 0);\n  let aLength = a2.length;\n  let bLength = b.length;\n  if (truncate2) {\n    const aMultipleLines = a2.includes(\"\\n\");\n    const bMultipleLines = b.includes(\"\\n\");\n    const aNewLineSymbol = getNewLineSymbol(a2);\n    const bNewLineSymbol = getNewLineSymbol(b);\n    const _a = aMultipleLines ? `${a2.split(aNewLineSymbol, truncateThreshold).join(aNewLineSymbol)}\n` : a2;\n    const _b = bMultipleLines ? `${b.split(bNewLineSymbol, truncateThreshold).join(bNewLineSymbol)}\n` : b;\n    aLength = _a.length;\n    bLength = _b.length;\n  }\n  const truncated = aLength !== a2.length || bLength !== b.length;\n  const isCommon = /* @__PURE__ */ __name((aIndex2, bIndex2) => a2[aIndex2] === b[bIndex2], \"isCommon\");\n  let aIndex = 0;\n  let bIndex = 0;\n  const diffs = [];\n  const foundSubsequence = /* @__PURE__ */ __name((nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      diffs.push(new Diff(DIFF_DELETE, a2.slice(aIndex, aCommon)));\n    }\n    if (bIndex !== bCommon) {\n      diffs.push(new Diff(DIFF_INSERT, b.slice(bIndex, bCommon)));\n    }\n    aIndex = aCommon + nCommon;\n    bIndex = bCommon + nCommon;\n    diffs.push(new Diff(DIFF_EQUAL, b.slice(bCommon, bIndex)));\n  }, \"foundSubsequence\");\n  diffSequences(aLength, bLength, isCommon, foundSubsequence);\n  if (aIndex !== aLength) {\n    diffs.push(new Diff(DIFF_DELETE, a2.slice(aIndex)));\n  }\n  if (bIndex !== bLength) {\n    diffs.push(new Diff(DIFF_INSERT, b.slice(bIndex)));\n  }\n  return [diffs, truncated];\n}\n__name(diffStrings, \"diffStrings\");\nfunction concatenateRelevantDiffs(op, diffs, changeColor) {\n  return diffs.reduce((reduced, diff2) => reduced + (diff2[0] === DIFF_EQUAL ? diff2[1] : diff2[0] === op && diff2[1].length !== 0 ? changeColor(diff2[1]) : \"\"), \"\");\n}\n__name(concatenateRelevantDiffs, \"concatenateRelevantDiffs\");\nvar _ChangeBuffer = class _ChangeBuffer {\n  op;\n  line;\n  lines;\n  changeColor;\n  constructor(op, changeColor) {\n    this.op = op;\n    this.line = [];\n    this.lines = [];\n    this.changeColor = changeColor;\n  }\n  pushSubstring(substring) {\n    this.pushDiff(new Diff(this.op, substring));\n  }\n  pushLine() {\n    this.lines.push(this.line.length !== 1 ? new Diff(this.op, concatenateRelevantDiffs(this.op, this.line, this.changeColor)) : this.line[0][0] === this.op ? this.line[0] : new Diff(this.op, this.line[0][1]));\n    this.line.length = 0;\n  }\n  isLineEmpty() {\n    return this.line.length === 0;\n  }\n  // Minor input to buffer.\n  pushDiff(diff2) {\n    this.line.push(diff2);\n  }\n  // Main input to buffer.\n  align(diff2) {\n    const string = diff2[1];\n    if (string.includes(\"\\n\")) {\n      const substrings = string.split(\"\\n\");\n      const iLast = substrings.length - 1;\n      substrings.forEach((substring, i) => {\n        if (i < iLast) {\n          this.pushSubstring(substring);\n          this.pushLine();\n        } else if (substring.length !== 0) {\n          this.pushSubstring(substring);\n        }\n      });\n    } else {\n      this.pushDiff(diff2);\n    }\n  }\n  // Output from buffer.\n  moveLinesTo(lines) {\n    if (!this.isLineEmpty()) {\n      this.pushLine();\n    }\n    lines.push(...this.lines);\n    this.lines.length = 0;\n  }\n};\n__name(_ChangeBuffer, \"ChangeBuffer\");\nvar ChangeBuffer = _ChangeBuffer;\nvar _CommonBuffer = class _CommonBuffer {\n  deleteBuffer;\n  insertBuffer;\n  lines;\n  constructor(deleteBuffer, insertBuffer) {\n    this.deleteBuffer = deleteBuffer;\n    this.insertBuffer = insertBuffer;\n    this.lines = [];\n  }\n  pushDiffCommonLine(diff2) {\n    this.lines.push(diff2);\n  }\n  pushDiffChangeLines(diff2) {\n    const isDiffEmpty = diff2[1].length === 0;\n    if (!isDiffEmpty || this.deleteBuffer.isLineEmpty()) {\n      this.deleteBuffer.pushDiff(diff2);\n    }\n    if (!isDiffEmpty || this.insertBuffer.isLineEmpty()) {\n      this.insertBuffer.pushDiff(diff2);\n    }\n  }\n  flushChangeLines() {\n    this.deleteBuffer.moveLinesTo(this.lines);\n    this.insertBuffer.moveLinesTo(this.lines);\n  }\n  // Input to buffer.\n  align(diff2) {\n    const op = diff2[0];\n    const string = diff2[1];\n    if (string.includes(\"\\n\")) {\n      const substrings = string.split(\"\\n\");\n      const iLast = substrings.length - 1;\n      substrings.forEach((substring, i) => {\n        if (i === 0) {\n          const subdiff = new Diff(op, substring);\n          if (this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty()) {\n            this.flushChangeLines();\n            this.pushDiffCommonLine(subdiff);\n          } else {\n            this.pushDiffChangeLines(subdiff);\n            this.flushChangeLines();\n          }\n        } else if (i < iLast) {\n          this.pushDiffCommonLine(new Diff(op, substring));\n        } else if (substring.length !== 0) {\n          this.pushDiffChangeLines(new Diff(op, substring));\n        }\n      });\n    } else {\n      this.pushDiffChangeLines(diff2);\n    }\n  }\n  // Output from buffer.\n  getLines() {\n    this.flushChangeLines();\n    return this.lines;\n  }\n};\n__name(_CommonBuffer, \"CommonBuffer\");\nvar CommonBuffer = _CommonBuffer;\nfunction getAlignedDiffs(diffs, changeColor) {\n  const deleteBuffer = new ChangeBuffer(DIFF_DELETE, changeColor);\n  const insertBuffer = new ChangeBuffer(DIFF_INSERT, changeColor);\n  const commonBuffer = new CommonBuffer(deleteBuffer, insertBuffer);\n  diffs.forEach((diff2) => {\n    switch (diff2[0]) {\n      case DIFF_DELETE:\n        deleteBuffer.align(diff2);\n        break;\n      case DIFF_INSERT:\n        insertBuffer.align(diff2);\n        break;\n      default:\n        commonBuffer.align(diff2);\n    }\n  });\n  return commonBuffer.getLines();\n}\n__name(getAlignedDiffs, \"getAlignedDiffs\");\nfunction hasCommonDiff(diffs, isMultiline) {\n  if (isMultiline) {\n    const iLast = diffs.length - 1;\n    return diffs.some((diff2, i) => diff2[0] === DIFF_EQUAL && (i !== iLast || diff2[1] !== \"\\n\"));\n  }\n  return diffs.some((diff2) => diff2[0] === DIFF_EQUAL);\n}\n__name(hasCommonDiff, \"hasCommonDiff\");\nfunction diffStringsUnified(a2, b, options) {\n  if (a2 !== b && a2.length !== 0 && b.length !== 0) {\n    const isMultiline = a2.includes(\"\\n\") || b.includes(\"\\n\");\n    const [diffs, truncated] = diffStringsRaw(isMultiline ? `${a2}\n` : a2, isMultiline ? `${b}\n` : b, true, options);\n    if (hasCommonDiff(diffs, isMultiline)) {\n      const optionsNormalized = normalizeDiffOptions(options);\n      const lines = getAlignedDiffs(diffs, optionsNormalized.changeColor);\n      return printDiffLines(lines, truncated, optionsNormalized);\n    }\n  }\n  return diffLinesUnified(a2.split(\"\\n\"), b.split(\"\\n\"), options);\n}\n__name(diffStringsUnified, \"diffStringsUnified\");\nfunction diffStringsRaw(a2, b, cleanup, options) {\n  const [diffs, truncated] = diffStrings(a2, b, options);\n  if (cleanup) {\n    diff_cleanupSemantic(diffs);\n  }\n  return [diffs, truncated];\n}\n__name(diffStringsRaw, \"diffStringsRaw\");\nfunction getCommonMessage(message, options) {\n  const { commonColor } = normalizeDiffOptions(options);\n  return commonColor(message);\n}\n__name(getCommonMessage, \"getCommonMessage\");\nvar { AsymmetricMatcher: AsymmetricMatcher2, DOMCollection: DOMCollection2, DOMElement: DOMElement2, Immutable: Immutable2, ReactElement: ReactElement2, ReactTestComponent: ReactTestComponent2 } = plugins;\nvar PLUGINS2 = [\n  ReactTestComponent2,\n  ReactElement2,\n  DOMElement2,\n  DOMCollection2,\n  Immutable2,\n  AsymmetricMatcher2,\n  plugins.Error\n];\nvar FORMAT_OPTIONS = {\n  maxDepth: 20,\n  plugins: PLUGINS2\n};\nvar FALLBACK_FORMAT_OPTIONS = {\n  callToJSON: false,\n  maxDepth: 8,\n  plugins: PLUGINS2\n};\nfunction diff(a2, b, options) {\n  if (Object.is(a2, b)) {\n    return \"\";\n  }\n  const aType = getType3(a2);\n  let expectedType = aType;\n  let omitDifference = false;\n  if (aType === \"object\" && typeof a2.asymmetricMatch === \"function\") {\n    if (a2.$$typeof !== Symbol.for(\"jest.asymmetricMatcher\")) {\n      return void 0;\n    }\n    if (typeof a2.getExpectedType !== \"function\") {\n      return void 0;\n    }\n    expectedType = a2.getExpectedType();\n    omitDifference = expectedType === \"string\";\n  }\n  if (expectedType !== getType3(b)) {\n    let truncate2 = function(s2) {\n      return s2.length <= MAX_LENGTH ? s2 : `${s2.slice(0, MAX_LENGTH)}...`;\n    };\n    __name(truncate2, \"truncate\");\n    const { aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator } = normalizeDiffOptions(options);\n    const formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options);\n    let aDisplay = format(a2, formatOptions);\n    let bDisplay = format(b, formatOptions);\n    const MAX_LENGTH = 1e5;\n    aDisplay = truncate2(aDisplay);\n    bDisplay = truncate2(bDisplay);\n    const aDiff = `${aColor(`${aIndicator} ${aAnnotation}:`)} \n${aDisplay}`;\n    const bDiff = `${bColor(`${bIndicator} ${bAnnotation}:`)} \n${bDisplay}`;\n    return `${aDiff}\n\n${bDiff}`;\n  }\n  if (omitDifference) {\n    return void 0;\n  }\n  switch (aType) {\n    case \"string\":\n      return diffLinesUnified(a2.split(\"\\n\"), b.split(\"\\n\"), options);\n    case \"boolean\":\n    case \"number\":\n      return comparePrimitive(a2, b, options);\n    case \"map\":\n      return compareObjects(sortMap(a2), sortMap(b), options);\n    case \"set\":\n      return compareObjects(sortSet(a2), sortSet(b), options);\n    default:\n      return compareObjects(a2, b, options);\n  }\n}\n__name(diff, \"diff\");\nfunction comparePrimitive(a2, b, options) {\n  const aFormat = format(a2, FORMAT_OPTIONS);\n  const bFormat = format(b, FORMAT_OPTIONS);\n  return aFormat === bFormat ? \"\" : diffLinesUnified(aFormat.split(\"\\n\"), bFormat.split(\"\\n\"), options);\n}\n__name(comparePrimitive, \"comparePrimitive\");\nfunction sortMap(map) {\n  return new Map(Array.from(map.entries()).sort());\n}\n__name(sortMap, \"sortMap\");\nfunction sortSet(set) {\n  return new Set(Array.from(set.values()).sort());\n}\n__name(sortSet, \"sortSet\");\nfunction compareObjects(a2, b, options) {\n  let difference;\n  let hasThrown = false;\n  try {\n    const formatOptions = getFormatOptions(FORMAT_OPTIONS, options);\n    difference = getObjectsDifference(a2, b, formatOptions, options);\n  } catch {\n    hasThrown = true;\n  }\n  const noDiffMessage = getCommonMessage(NO_DIFF_MESSAGE, options);\n  if (difference === void 0 || difference === noDiffMessage) {\n    const formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options);\n    difference = getObjectsDifference(a2, b, formatOptions, options);\n    if (difference !== noDiffMessage && !hasThrown) {\n      difference = `${getCommonMessage(SIMILAR_MESSAGE, options)}\n\n${difference}`;\n    }\n  }\n  return difference;\n}\n__name(compareObjects, \"compareObjects\");\nfunction getFormatOptions(formatOptions, options) {\n  const { compareKeys, printBasicPrototype, maxDepth } = normalizeDiffOptions(options);\n  return {\n    ...formatOptions,\n    compareKeys,\n    printBasicPrototype,\n    maxDepth: maxDepth ?? formatOptions.maxDepth\n  };\n}\n__name(getFormatOptions, \"getFormatOptions\");\nfunction getObjectsDifference(a2, b, formatOptions, options) {\n  const formatOptionsZeroIndent = {\n    ...formatOptions,\n    indent: 0\n  };\n  const aCompare = format(a2, formatOptionsZeroIndent);\n  const bCompare = format(b, formatOptionsZeroIndent);\n  if (aCompare === bCompare) {\n    return getCommonMessage(NO_DIFF_MESSAGE, options);\n  } else {\n    const aDisplay = format(a2, formatOptions);\n    const bDisplay = format(b, formatOptions);\n    return diffLinesUnified2(aDisplay.split(\"\\n\"), bDisplay.split(\"\\n\"), aCompare.split(\"\\n\"), bCompare.split(\"\\n\"), options);\n  }\n}\n__name(getObjectsDifference, \"getObjectsDifference\");\nvar MAX_DIFF_STRING_LENGTH = 2e4;\nfunction isAsymmetricMatcher(data) {\n  const type = getType2(data);\n  return type === \"Object\" && typeof data.asymmetricMatch === \"function\";\n}\n__name(isAsymmetricMatcher, \"isAsymmetricMatcher\");\nfunction isReplaceable(obj1, obj2) {\n  const obj1Type = getType2(obj1);\n  const obj2Type = getType2(obj2);\n  return obj1Type === obj2Type && (obj1Type === \"Object\" || obj1Type === \"Array\");\n}\n__name(isReplaceable, \"isReplaceable\");\nfunction printDiffOrStringify(received, expected, options) {\n  const { aAnnotation, bAnnotation } = normalizeDiffOptions(options);\n  if (typeof expected === \"string\" && typeof received === \"string\" && expected.length > 0 && received.length > 0 && expected.length <= MAX_DIFF_STRING_LENGTH && received.length <= MAX_DIFF_STRING_LENGTH && expected !== received) {\n    if (expected.includes(\"\\n\") || received.includes(\"\\n\")) {\n      return diffStringsUnified(expected, received, options);\n    }\n    const [diffs] = diffStringsRaw(expected, received, true);\n    const hasCommonDiff2 = diffs.some((diff2) => diff2[0] === DIFF_EQUAL);\n    const printLabel = getLabelPrinter(aAnnotation, bAnnotation);\n    const expectedLine = printLabel(aAnnotation) + printExpected(getCommonAndChangedSubstrings(diffs, DIFF_DELETE, hasCommonDiff2));\n    const receivedLine = printLabel(bAnnotation) + printReceived(getCommonAndChangedSubstrings(diffs, DIFF_INSERT, hasCommonDiff2));\n    return `${expectedLine}\n${receivedLine}`;\n  }\n  const clonedExpected = deepClone(expected, { forceWritable: true });\n  const clonedReceived = deepClone(received, { forceWritable: true });\n  const { replacedExpected, replacedActual } = replaceAsymmetricMatcher(clonedReceived, clonedExpected);\n  const difference = diff(replacedExpected, replacedActual, options);\n  return difference;\n}\n__name(printDiffOrStringify, \"printDiffOrStringify\");\nfunction replaceAsymmetricMatcher(actual, expected, actualReplaced = /* @__PURE__ */ new WeakSet(), expectedReplaced = /* @__PURE__ */ new WeakSet()) {\n  if (actual instanceof Error && expected instanceof Error && typeof actual.cause !== \"undefined\" && typeof expected.cause === \"undefined\") {\n    delete actual.cause;\n    return {\n      replacedActual: actual,\n      replacedExpected: expected\n    };\n  }\n  if (!isReplaceable(actual, expected)) {\n    return {\n      replacedActual: actual,\n      replacedExpected: expected\n    };\n  }\n  if (actualReplaced.has(actual) || expectedReplaced.has(expected)) {\n    return {\n      replacedActual: actual,\n      replacedExpected: expected\n    };\n  }\n  actualReplaced.add(actual);\n  expectedReplaced.add(expected);\n  getOwnProperties(expected).forEach((key) => {\n    const expectedValue = expected[key];\n    const actualValue = actual[key];\n    if (isAsymmetricMatcher(expectedValue)) {\n      if (expectedValue.asymmetricMatch(actualValue)) {\n        actual[key] = expectedValue;\n      }\n    } else if (isAsymmetricMatcher(actualValue)) {\n      if (actualValue.asymmetricMatch(expectedValue)) {\n        expected[key] = actualValue;\n      }\n    } else if (isReplaceable(actualValue, expectedValue)) {\n      const replaced = replaceAsymmetricMatcher(actualValue, expectedValue, actualReplaced, expectedReplaced);\n      actual[key] = replaced.replacedActual;\n      expected[key] = replaced.replacedExpected;\n    }\n  });\n  return {\n    replacedActual: actual,\n    replacedExpected: expected\n  };\n}\n__name(replaceAsymmetricMatcher, \"replaceAsymmetricMatcher\");\nfunction getLabelPrinter(...strings) {\n  const maxLength = strings.reduce((max, string) => string.length > max ? string.length : max, 0);\n  return (string) => `${string}: ${\" \".repeat(maxLength - string.length)}`;\n}\n__name(getLabelPrinter, \"getLabelPrinter\");\nvar SPACE_SYMBOL = \"\\xB7\";\nfunction replaceTrailingSpaces(text) {\n  return text.replace(/\\s+$/gm, (spaces) => SPACE_SYMBOL.repeat(spaces.length));\n}\n__name(replaceTrailingSpaces, \"replaceTrailingSpaces\");\nfunction printReceived(object) {\n  return s.red(replaceTrailingSpaces(stringify(object)));\n}\n__name(printReceived, \"printReceived\");\nfunction printExpected(value) {\n  return s.green(replaceTrailingSpaces(stringify(value)));\n}\n__name(printExpected, \"printExpected\");\nfunction getCommonAndChangedSubstrings(diffs, op, hasCommonDiff2) {\n  return diffs.reduce((reduced, diff2) => reduced + (diff2[0] === DIFF_EQUAL ? diff2[1] : diff2[0] === op ? hasCommonDiff2 ? s.inverse(diff2[1]) : diff2[1] : \"\"), \"\");\n}\n__name(getCommonAndChangedSubstrings, \"getCommonAndChangedSubstrings\");\n\n// ../node_modules/@vitest/utils/dist/error.js\nvar IS_RECORD_SYMBOL = \"@@__IMMUTABLE_RECORD__@@\";\nvar IS_COLLECTION_SYMBOL = \"@@__IMMUTABLE_ITERABLE__@@\";\nfunction isImmutable(v) {\n  return v && (v[IS_COLLECTION_SYMBOL] || v[IS_RECORD_SYMBOL]);\n}\n__name(isImmutable, \"isImmutable\");\nvar OBJECT_PROTO = Object.getPrototypeOf({});\nfunction getUnserializableMessage(err) {\n  if (err instanceof Error) {\n    return `<unserializable>: ${err.message}`;\n  }\n  if (typeof err === \"string\") {\n    return `<unserializable>: ${err}`;\n  }\n  return \"<unserializable>\";\n}\n__name(getUnserializableMessage, \"getUnserializableMessage\");\nfunction serializeValue(val, seen = /* @__PURE__ */ new WeakMap()) {\n  if (!val || typeof val === \"string\") {\n    return val;\n  }\n  if (val instanceof Error && \"toJSON\" in val && typeof val.toJSON === \"function\") {\n    const jsonValue = val.toJSON();\n    if (jsonValue && jsonValue !== val && typeof jsonValue === \"object\") {\n      if (typeof val.message === \"string\") {\n        safe(() => jsonValue.message ?? (jsonValue.message = val.message));\n      }\n      if (typeof val.stack === \"string\") {\n        safe(() => jsonValue.stack ?? (jsonValue.stack = val.stack));\n      }\n      if (typeof val.name === \"string\") {\n        safe(() => jsonValue.name ?? (jsonValue.name = val.name));\n      }\n      if (val.cause != null) {\n        safe(() => jsonValue.cause ?? (jsonValue.cause = serializeValue(val.cause, seen)));\n      }\n    }\n    return serializeValue(jsonValue, seen);\n  }\n  if (typeof val === \"function\") {\n    return `Function<${val.name || \"anonymous\"}>`;\n  }\n  if (typeof val === \"symbol\") {\n    return val.toString();\n  }\n  if (typeof val !== \"object\") {\n    return val;\n  }\n  if (typeof Buffer !== \"undefined\" && val instanceof Buffer) {\n    return `<Buffer(${val.length}) ...>`;\n  }\n  if (typeof Uint8Array !== \"undefined\" && val instanceof Uint8Array) {\n    return `<Uint8Array(${val.length}) ...>`;\n  }\n  if (isImmutable(val)) {\n    return serializeValue(val.toJSON(), seen);\n  }\n  if (val instanceof Promise || val.constructor && val.constructor.prototype === \"AsyncFunction\") {\n    return \"Promise\";\n  }\n  if (typeof Element !== \"undefined\" && val instanceof Element) {\n    return val.tagName;\n  }\n  if (typeof val.asymmetricMatch === \"function\") {\n    return `${val.toString()} ${format2(val.sample)}`;\n  }\n  if (typeof val.toJSON === \"function\") {\n    return serializeValue(val.toJSON(), seen);\n  }\n  if (seen.has(val)) {\n    return seen.get(val);\n  }\n  if (Array.isArray(val)) {\n    const clone2 = new Array(val.length);\n    seen.set(val, clone2);\n    val.forEach((e, i) => {\n      try {\n        clone2[i] = serializeValue(e, seen);\n      } catch (err) {\n        clone2[i] = getUnserializableMessage(err);\n      }\n    });\n    return clone2;\n  } else {\n    const clone2 = /* @__PURE__ */ Object.create(null);\n    seen.set(val, clone2);\n    let obj = val;\n    while (obj && obj !== OBJECT_PROTO) {\n      Object.getOwnPropertyNames(obj).forEach((key) => {\n        if (key in clone2) {\n          return;\n        }\n        try {\n          clone2[key] = serializeValue(val[key], seen);\n        } catch (err) {\n          delete clone2[key];\n          clone2[key] = getUnserializableMessage(err);\n        }\n      });\n      obj = Object.getPrototypeOf(obj);\n    }\n    return clone2;\n  }\n}\n__name(serializeValue, \"serializeValue\");\nfunction safe(fn) {\n  try {\n    return fn();\n  } catch {\n  }\n}\n__name(safe, \"safe\");\nfunction normalizeErrorMessage(message) {\n  return message.replace(/__(vite_ssr_import|vi_import)_\\d+__\\./g, \"\");\n}\n__name(normalizeErrorMessage, \"normalizeErrorMessage\");\nfunction processError(_err, diffOptions, seen = /* @__PURE__ */ new WeakSet()) {\n  if (!_err || typeof _err !== \"object\") {\n    return { message: String(_err) };\n  }\n  const err = _err;\n  if (err.showDiff || err.showDiff === void 0 && err.expected !== void 0 && err.actual !== void 0) {\n    err.diff = printDiffOrStringify(err.actual, err.expected, {\n      ...diffOptions,\n      ...err.diffOptions\n    });\n  }\n  if (\"expected\" in err && typeof err.expected !== \"string\") {\n    err.expected = stringify(err.expected, 10);\n  }\n  if (\"actual\" in err && typeof err.actual !== \"string\") {\n    err.actual = stringify(err.actual, 10);\n  }\n  try {\n    if (typeof err.message === \"string\") {\n      err.message = normalizeErrorMessage(err.message);\n    }\n  } catch {\n  }\n  try {\n    if (!seen.has(err) && typeof err.cause === \"object\") {\n      seen.add(err);\n      err.cause = processError(err.cause, diffOptions, seen);\n    }\n  } catch {\n  }\n  try {\n    return serializeValue(err);\n  } catch (e) {\n    return serializeValue(new Error(`Failed to fully serialize error: ${e === null || e === void 0 ? void 0 : e.message}\nInner error message: ${err === null || err === void 0 ? void 0 : err.message}`));\n  }\n}\n__name(processError, \"processError\");\n\nexport {\n  s,\n  stringify,\n  getDefaultExportFromCjs2 as getDefaultExportFromCjs,\n  assertTypes,\n  isObject,\n  getType2 as getType,\n  noop,\n  diff,\n  printDiffOrStringify,\n  processError\n};\n",
      "start": 1762256767688,
      "end": 1762256767707,
      "sourcemaps": null
    },
    {
      "name": "storybook:mock-loader",
      "start": 1762256767707,
      "end": 1762256767707,
      "order": "normal-pre"
    },
    {
      "name": "vite-plugin-svelte",
      "start": 1762256767707,
      "end": 1762256767707,
      "order": "pre"
    },
    {
      "name": "plugin-csf",
      "start": 1762256767707,
      "end": 1762256767707,
      "order": "pre"
    },
    {
      "name": "vite:esbuild",
      "start": 1762256767707,
      "end": 1762256767707,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1762256767707,
      "end": 1762256767707,
      "order": "normal-normal"
    },
    {
      "name": "storybook:mock-loader-preview",
      "start": 1762256767707,
      "end": 1762256767707,
      "order": "normal"
    },
    {
      "name": "storybook:svelte-docgen-plugin",
      "start": 1762256767707,
      "end": 1762256767707,
      "order": "normal"
    },
    {
      "name": "storybook:addon-svelte-csf",
      "start": 1762256767707,
      "end": 1762256767707,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import {\n  __name\n} from \"./chunk-MM7DTO55.js\";\nvar f = {\n  reset: [0, 0],\n  bold: [1, 22, \"\\x1B[22m\\x1B[1m\"],\n  dim: [2, 22, \"\\x1B[22m\\x1B[2m\"],\n  italic: [3, 23],\n  underline: [4, 24],\n  inverse: [7, 27],\n  hidden: [8, 28],\n  strikethrough: [9, 29],\n  black: [30, 39],\n  red: [31, 39],\n  green: [32, 39],\n  yellow: [33, 39],\n  blue: [34, 39],\n  magenta: [35, 39],\n  cyan: [36, 39],\n  white: [37, 39],\n  gray: [90, 39],\n  bgBlack: [40, 49],\n  bgRed: [41, 49],\n  bgGreen: [42, 49],\n  bgYellow: [43, 49],\n  bgBlue: [44, 49],\n  bgMagenta: [45, 49],\n  bgCyan: [46, 49],\n  bgWhite: [47, 49],\n  blackBright: [90, 39],\n  redBright: [91, 39],\n  greenBright: [92, 39],\n  yellowBright: [93, 39],\n  blueBright: [94, 39],\n  magentaBright: [95, 39],\n  cyanBright: [96, 39],\n  whiteBright: [97, 39],\n  bgBlackBright: [100, 49],\n  bgRedBright: [101, 49],\n  bgGreenBright: [102, 49],\n  bgYellowBright: [103, 49],\n  bgBlueBright: [104, 49],\n  bgMagentaBright: [105, 49],\n  bgCyanBright: [106, 49],\n  bgWhiteBright: [107, 49]\n};\nvar h = Object.entries(f);\nfunction a(n) {\n  return String(n);\n}\n__name(a, \"a\");\na.open = \"\";\na.close = \"\";\nvar B = h.reduce(\n  (n, [e]) => (n[e] = a, n),\n  { isColorSupported: false }\n);\nfunction C(n = false) {\n  let e = typeof process != \"undefined\" ? process : void 0, i = (e == null ? void 0 : e.env) || {}, g = (e == null ? void 0 : e.argv) || [];\n  return !(\"NO_COLOR\" in i || g.includes(\"--no-color\")) && (\"FORCE_COLOR\" in i || g.includes(\"--color\") || (e == null ? void 0 : e.platform) === \"win32\" || n && i.TERM !== \"dumb\" || \"CI\" in i) || typeof window != \"undefined\" && !!window.chrome;\n}\n__name(C, \"C\");\nfunction p(n = false) {\n  let e = C(n), i = /* @__PURE__ */ __name((r, t, c, o) => {\n    let l = \"\", s2 = 0;\n    do\n      l += r.substring(s2, o) + c, s2 = o + t.length, o = r.indexOf(t, s2);\n    while (~o);\n    return l + r.substring(s2);\n  }, \"i\"), g = /* @__PURE__ */ __name((r, t, c = r) => {\n    let o = /* @__PURE__ */ __name((l) => {\n      let s2 = String(l), b = s2.indexOf(t, r.length);\n      return ~b ? r + i(s2, t, c, b) + t : r + s2 + t;\n    }, \"o\");\n    return o.open = r, o.close = t, o;\n  }, \"g\"), u = {\n    isColorSupported: e\n  }, d = /* @__PURE__ */ __name((r) => `\\x1B[${r}m`, \"d\");\n  for (let [r, t] of h)\n    u[r] = e ? g(\n      d(t[0]),\n      d(t[1]),\n      t[2]\n    ) : a;\n  return u;\n}\n__name(p, \"p\");\nvar s = p();\nfunction _mergeNamespaces(n, m2) {\n  m2.forEach(function(e) {\n    e && typeof e !== \"string\" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n      if (k !== \"default\" && !(k in n)) {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: /* @__PURE__ */ __name(function() {\n            return e[k];\n          }, \"get\")\n        });\n      }\n    });\n  });\n  return Object.freeze(n);\n}\n__name(_mergeNamespaces, \"_mergeNamespaces\");\nfunction getKeysOfEnumerableProperties(object, compareKeys) {\n  const rawKeys = Object.keys(object);\n  const keys = compareKeys === null ? rawKeys : rawKeys.sort(compareKeys);\n  if (Object.getOwnPropertySymbols) {\n    for (const symbol of Object.getOwnPropertySymbols(object)) {\n      if (Object.getOwnPropertyDescriptor(object, symbol).enumerable) {\n        keys.push(symbol);\n      }\n    }\n  }\n  return keys;\n}\n__name(getKeysOfEnumerableProperties, \"getKeysOfEnumerableProperties\");\nfunction printIteratorEntries(iterator, config, indentation, depth, refs, printer2, separator = \": \") {\n  let result = \"\";\n  let width = 0;\n  let current = iterator.next();\n  if (!current.done) {\n    result += config.spacingOuter;\n    const indentationNext = indentation + config.indent;\n    while (!current.done) {\n      result += indentationNext;\n      if (width++ === config.maxWidth) {\n        result += \"\";\n        break;\n      }\n      const name = printer2(current.value[0], config, indentationNext, depth, refs);\n      const value = printer2(current.value[1], config, indentationNext, depth, refs);\n      result += name + separator + value;\n      current = iterator.next();\n      if (!current.done) {\n        result += `,${config.spacingInner}`;\n      } else if (!config.min) {\n        result += \",\";\n      }\n    }\n    result += config.spacingOuter + indentation;\n  }\n  return result;\n}\n__name(printIteratorEntries, \"printIteratorEntries\");\nfunction printIteratorValues(iterator, config, indentation, depth, refs, printer2) {\n  let result = \"\";\n  let width = 0;\n  let current = iterator.next();\n  if (!current.done) {\n    result += config.spacingOuter;\n    const indentationNext = indentation + config.indent;\n    while (!current.done) {\n      result += indentationNext;\n      if (width++ === config.maxWidth) {\n        result += \"\";\n        break;\n      }\n      result += printer2(current.value, config, indentationNext, depth, refs);\n      current = iterator.next();\n      if (!current.done) {\n        result += `,${config.spacingInner}`;\n      } else if (!config.min) {\n        result += \",\";\n      }\n    }\n    result += config.spacingOuter + indentation;\n  }\n  return result;\n}\n__name(printIteratorValues, \"printIteratorValues\");\nfunction printListItems(list, config, indentation, depth, refs, printer2) {\n  let result = \"\";\n  list = list instanceof ArrayBuffer ? new DataView(list) : list;\n  const isDataView = /* @__PURE__ */ __name((l) => l instanceof DataView, \"isDataView\");\n  const length = isDataView(list) ? list.byteLength : list.length;\n  if (length > 0) {\n    result += config.spacingOuter;\n    const indentationNext = indentation + config.indent;\n    for (let i = 0; i < length; i++) {\n      result += indentationNext;\n      if (i === config.maxWidth) {\n        result += \"\";\n        break;\n      }\n      if (isDataView(list) || i in list) {\n        result += printer2(isDataView(list) ? list.getInt8(i) : list[i], config, indentationNext, depth, refs);\n      }\n      if (i < length - 1) {\n        result += `,${config.spacingInner}`;\n      } else if (!config.min) {\n        result += \",\";\n      }\n    }\n    result += config.spacingOuter + indentation;\n  }\n  return result;\n}\n__name(printListItems, \"printListItems\");\nfunction printObjectProperties(val, config, indentation, depth, refs, printer2) {\n  let result = \"\";\n  const keys = getKeysOfEnumerableProperties(val, config.compareKeys);\n  if (keys.length > 0) {\n    result += config.spacingOuter;\n    const indentationNext = indentation + config.indent;\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const name = printer2(key, config, indentationNext, depth, refs);\n      const value = printer2(val[key], config, indentationNext, depth, refs);\n      result += `${indentationNext + name}: ${value}`;\n      if (i < keys.length - 1) {\n        result += `,${config.spacingInner}`;\n      } else if (!config.min) {\n        result += \",\";\n      }\n    }\n    result += config.spacingOuter + indentation;\n  }\n  return result;\n}\n__name(printObjectProperties, \"printObjectProperties\");\nvar asymmetricMatcher = typeof Symbol === \"function\" && Symbol.for ? Symbol.for(\"jest.asymmetricMatcher\") : 1267621;\nvar SPACE$2 = \" \";\nvar serialize$5 = /* @__PURE__ */ __name((val, config, indentation, depth, refs, printer2) => {\n  const stringedValue = val.toString();\n  if (stringedValue === \"ArrayContaining\" || stringedValue === \"ArrayNotContaining\") {\n    if (++depth > config.maxDepth) {\n      return `[${stringedValue}]`;\n    }\n    return `${stringedValue + SPACE$2}[${printListItems(val.sample, config, indentation, depth, refs, printer2)}]`;\n  }\n  if (stringedValue === \"ObjectContaining\" || stringedValue === \"ObjectNotContaining\") {\n    if (++depth > config.maxDepth) {\n      return `[${stringedValue}]`;\n    }\n    return `${stringedValue + SPACE$2}{${printObjectProperties(val.sample, config, indentation, depth, refs, printer2)}}`;\n  }\n  if (stringedValue === \"StringMatching\" || stringedValue === \"StringNotMatching\") {\n    return stringedValue + SPACE$2 + printer2(val.sample, config, indentation, depth, refs);\n  }\n  if (stringedValue === \"StringContaining\" || stringedValue === \"StringNotContaining\") {\n    return stringedValue + SPACE$2 + printer2(val.sample, config, indentation, depth, refs);\n  }\n  if (typeof val.toAsymmetricMatcher !== \"function\") {\n    throw new TypeError(`Asymmetric matcher ${val.constructor.name} does not implement toAsymmetricMatcher()`);\n  }\n  return val.toAsymmetricMatcher();\n}, \"serialize$5\");\nvar test$5 = /* @__PURE__ */ __name((val) => val && val.$$typeof === asymmetricMatcher, \"test$5\");\nvar plugin$5 = {\n  serialize: serialize$5,\n  test: test$5\n};\nvar SPACE$1 = \" \";\nvar OBJECT_NAMES = /* @__PURE__ */ new Set([\"DOMStringMap\", \"NamedNodeMap\"]);\nvar ARRAY_REGEXP = /^(?:HTML\\w*Collection|NodeList)$/;\nfunction testName(name) {\n  return OBJECT_NAMES.has(name) || ARRAY_REGEXP.test(name);\n}\n__name(testName, \"testName\");\nvar test$4 = /* @__PURE__ */ __name((val) => val && val.constructor && !!val.constructor.name && testName(val.constructor.name), \"test$4\");\nfunction isNamedNodeMap(collection) {\n  return collection.constructor.name === \"NamedNodeMap\";\n}\n__name(isNamedNodeMap, \"isNamedNodeMap\");\nvar serialize$4 = /* @__PURE__ */ __name((collection, config, indentation, depth, refs, printer2) => {\n  const name = collection.constructor.name;\n  if (++depth > config.maxDepth) {\n    return `[${name}]`;\n  }\n  return (config.min ? \"\" : name + SPACE$1) + (OBJECT_NAMES.has(name) ? `{${printObjectProperties(isNamedNodeMap(collection) ? [...collection].reduce((props, attribute) => {\n    props[attribute.name] = attribute.value;\n    return props;\n  }, {}) : { ...collection }, config, indentation, depth, refs, printer2)}}` : `[${printListItems([...collection], config, indentation, depth, refs, printer2)}]`);\n}, \"serialize$4\");\nvar plugin$4 = {\n  serialize: serialize$4,\n  test: test$4\n};\nfunction escapeHTML(str) {\n  return str.replaceAll(\"<\", \"&lt;\").replaceAll(\">\", \"&gt;\");\n}\n__name(escapeHTML, \"escapeHTML\");\nfunction printProps(keys, props, config, indentation, depth, refs, printer2) {\n  const indentationNext = indentation + config.indent;\n  const colors = config.colors;\n  return keys.map((key) => {\n    const value = props[key];\n    let printed = printer2(value, config, indentationNext, depth, refs);\n    if (typeof value !== \"string\") {\n      if (printed.includes(\"\\n\")) {\n        printed = config.spacingOuter + indentationNext + printed + config.spacingOuter + indentation;\n      }\n      printed = `{${printed}}`;\n    }\n    return `${config.spacingInner + indentation + colors.prop.open + key + colors.prop.close}=${colors.value.open}${printed}${colors.value.close}`;\n  }).join(\"\");\n}\n__name(printProps, \"printProps\");\nfunction printChildren(children, config, indentation, depth, refs, printer2) {\n  return children.map((child) => config.spacingOuter + indentation + (typeof child === \"string\" ? printText(child, config) : printer2(child, config, indentation, depth, refs))).join(\"\");\n}\n__name(printChildren, \"printChildren\");\nfunction printText(text, config) {\n  const contentColor = config.colors.content;\n  return contentColor.open + escapeHTML(text) + contentColor.close;\n}\n__name(printText, \"printText\");\nfunction printComment(comment, config) {\n  const commentColor = config.colors.comment;\n  return `${commentColor.open}<!--${escapeHTML(comment)}-->${commentColor.close}`;\n}\n__name(printComment, \"printComment\");\nfunction printElement(type, printedProps, printedChildren, config, indentation) {\n  const tagColor = config.colors.tag;\n  return `${tagColor.open}<${type}${printedProps && tagColor.close + printedProps + config.spacingOuter + indentation + tagColor.open}${printedChildren ? `>${tagColor.close}${printedChildren}${config.spacingOuter}${indentation}${tagColor.open}</${type}` : `${printedProps && !config.min ? \"\" : \" \"}/`}>${tagColor.close}`;\n}\n__name(printElement, \"printElement\");\nfunction printElementAsLeaf(type, config) {\n  const tagColor = config.colors.tag;\n  return `${tagColor.open}<${type}${tagColor.close} ${tagColor.open} />${tagColor.close}`;\n}\n__name(printElementAsLeaf, \"printElementAsLeaf\");\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\nvar FRAGMENT_NODE = 11;\nvar ELEMENT_REGEXP = /^(?:(?:HTML|SVG)\\w*)?Element$/;\nfunction testHasAttribute(val) {\n  try {\n    return typeof val.hasAttribute === \"function\" && val.hasAttribute(\"is\");\n  } catch {\n    return false;\n  }\n}\n__name(testHasAttribute, \"testHasAttribute\");\nfunction testNode(val) {\n  const constructorName = val.constructor.name;\n  const { nodeType, tagName } = val;\n  const isCustomElement = typeof tagName === \"string\" && tagName.includes(\"-\") || testHasAttribute(val);\n  return nodeType === ELEMENT_NODE && (ELEMENT_REGEXP.test(constructorName) || isCustomElement) || nodeType === TEXT_NODE && constructorName === \"Text\" || nodeType === COMMENT_NODE && constructorName === \"Comment\" || nodeType === FRAGMENT_NODE && constructorName === \"DocumentFragment\";\n}\n__name(testNode, \"testNode\");\nvar test$3 = /* @__PURE__ */ __name((val) => {\n  var _val$constructor;\n  return (val === null || val === void 0 || (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) && testNode(val);\n}, \"test$3\");\nfunction nodeIsText(node) {\n  return node.nodeType === TEXT_NODE;\n}\n__name(nodeIsText, \"nodeIsText\");\nfunction nodeIsComment(node) {\n  return node.nodeType === COMMENT_NODE;\n}\n__name(nodeIsComment, \"nodeIsComment\");\nfunction nodeIsFragment(node) {\n  return node.nodeType === FRAGMENT_NODE;\n}\n__name(nodeIsFragment, \"nodeIsFragment\");\nvar serialize$3 = /* @__PURE__ */ __name((node, config, indentation, depth, refs, printer2) => {\n  if (nodeIsText(node)) {\n    return printText(node.data, config);\n  }\n  if (nodeIsComment(node)) {\n    return printComment(node.data, config);\n  }\n  const type = nodeIsFragment(node) ? \"DocumentFragment\" : node.tagName.toLowerCase();\n  if (++depth > config.maxDepth) {\n    return printElementAsLeaf(type, config);\n  }\n  return printElement(type, printProps(nodeIsFragment(node) ? [] : Array.from(node.attributes, (attr) => attr.name).sort(), nodeIsFragment(node) ? {} : [...node.attributes].reduce((props, attribute) => {\n    props[attribute.name] = attribute.value;\n    return props;\n  }, {}), config, indentation + config.indent, depth, refs, printer2), printChildren(Array.prototype.slice.call(node.childNodes || node.children), config, indentation + config.indent, depth, refs, printer2), config, indentation);\n}, \"serialize$3\");\nvar plugin$3 = {\n  serialize: serialize$3,\n  test: test$3\n};\nvar IS_ITERABLE_SENTINEL = \"@@__IMMUTABLE_ITERABLE__@@\";\nvar IS_LIST_SENTINEL = \"@@__IMMUTABLE_LIST__@@\";\nvar IS_KEYED_SENTINEL = \"@@__IMMUTABLE_KEYED__@@\";\nvar IS_MAP_SENTINEL = \"@@__IMMUTABLE_MAP__@@\";\nvar IS_ORDERED_SENTINEL = \"@@__IMMUTABLE_ORDERED__@@\";\nvar IS_RECORD_SENTINEL = \"@@__IMMUTABLE_RECORD__@@\";\nvar IS_SEQ_SENTINEL = \"@@__IMMUTABLE_SEQ__@@\";\nvar IS_SET_SENTINEL = \"@@__IMMUTABLE_SET__@@\";\nvar IS_STACK_SENTINEL = \"@@__IMMUTABLE_STACK__@@\";\nvar getImmutableName = /* @__PURE__ */ __name((name) => `Immutable.${name}`, \"getImmutableName\");\nvar printAsLeaf = /* @__PURE__ */ __name((name) => `[${name}]`, \"printAsLeaf\");\nvar SPACE = \" \";\nvar LAZY = \"\";\nfunction printImmutableEntries(val, config, indentation, depth, refs, printer2, type) {\n  return ++depth > config.maxDepth ? printAsLeaf(getImmutableName(type)) : `${getImmutableName(type) + SPACE}{${printIteratorEntries(val.entries(), config, indentation, depth, refs, printer2)}}`;\n}\n__name(printImmutableEntries, \"printImmutableEntries\");\nfunction getRecordEntries(val) {\n  let i = 0;\n  return { next() {\n    if (i < val._keys.length) {\n      const key = val._keys[i++];\n      return {\n        done: false,\n        value: [key, val.get(key)]\n      };\n    }\n    return {\n      done: true,\n      value: void 0\n    };\n  } };\n}\n__name(getRecordEntries, \"getRecordEntries\");\nfunction printImmutableRecord(val, config, indentation, depth, refs, printer2) {\n  const name = getImmutableName(val._name || \"Record\");\n  return ++depth > config.maxDepth ? printAsLeaf(name) : `${name + SPACE}{${printIteratorEntries(getRecordEntries(val), config, indentation, depth, refs, printer2)}}`;\n}\n__name(printImmutableRecord, \"printImmutableRecord\");\nfunction printImmutableSeq(val, config, indentation, depth, refs, printer2) {\n  const name = getImmutableName(\"Seq\");\n  if (++depth > config.maxDepth) {\n    return printAsLeaf(name);\n  }\n  if (val[IS_KEYED_SENTINEL]) {\n    return `${name + SPACE}{${val._iter || val._object ? printIteratorEntries(val.entries(), config, indentation, depth, refs, printer2) : LAZY}}`;\n  }\n  return `${name + SPACE}[${val._iter || val._array || val._collection || val._iterable ? printIteratorValues(val.values(), config, indentation, depth, refs, printer2) : LAZY}]`;\n}\n__name(printImmutableSeq, \"printImmutableSeq\");\nfunction printImmutableValues(val, config, indentation, depth, refs, printer2, type) {\n  return ++depth > config.maxDepth ? printAsLeaf(getImmutableName(type)) : `${getImmutableName(type) + SPACE}[${printIteratorValues(val.values(), config, indentation, depth, refs, printer2)}]`;\n}\n__name(printImmutableValues, \"printImmutableValues\");\nvar serialize$2 = /* @__PURE__ */ __name((val, config, indentation, depth, refs, printer2) => {\n  if (val[IS_MAP_SENTINEL]) {\n    return printImmutableEntries(val, config, indentation, depth, refs, printer2, val[IS_ORDERED_SENTINEL] ? \"OrderedMap\" : \"Map\");\n  }\n  if (val[IS_LIST_SENTINEL]) {\n    return printImmutableValues(val, config, indentation, depth, refs, printer2, \"List\");\n  }\n  if (val[IS_SET_SENTINEL]) {\n    return printImmutableValues(val, config, indentation, depth, refs, printer2, val[IS_ORDERED_SENTINEL] ? \"OrderedSet\" : \"Set\");\n  }\n  if (val[IS_STACK_SENTINEL]) {\n    return printImmutableValues(val, config, indentation, depth, refs, printer2, \"Stack\");\n  }\n  if (val[IS_SEQ_SENTINEL]) {\n    return printImmutableSeq(val, config, indentation, depth, refs, printer2);\n  }\n  return printImmutableRecord(val, config, indentation, depth, refs, printer2);\n}, \"serialize$2\");\nvar test$2 = /* @__PURE__ */ __name((val) => val && (val[IS_ITERABLE_SENTINEL] === true || val[IS_RECORD_SENTINEL] === true), \"test$2\");\nvar plugin$2 = {\n  serialize: serialize$2,\n  test: test$2\n};\nfunction getDefaultExportFromCjs(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\n__name(getDefaultExportFromCjs, \"getDefaultExportFromCjs\");\nvar reactIs$1 = { exports: {} };\nvar reactIs_production = {};\nvar hasRequiredReactIs_production;\nfunction requireReactIs_production() {\n  if (hasRequiredReactIs_production) return reactIs_production;\n  hasRequiredReactIs_production = 1;\n  var REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"), REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"), REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"), REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"), REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n  var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"), REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"), REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"), REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"), REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"), REACT_MEMO_TYPE = Symbol.for(\"react.memo\"), REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"), REACT_VIEW_TRANSITION_TYPE = Symbol.for(\"react.view_transition\"), REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n  function typeOf(object) {\n    if (\"object\" === typeof object && null !== object) {\n      var $$typeof = object.$$typeof;\n      switch ($$typeof) {\n        case REACT_ELEMENT_TYPE:\n          switch (object = object.type, object) {\n            case REACT_FRAGMENT_TYPE:\n            case REACT_PROFILER_TYPE:\n            case REACT_STRICT_MODE_TYPE:\n            case REACT_SUSPENSE_TYPE:\n            case REACT_SUSPENSE_LIST_TYPE:\n            case REACT_VIEW_TRANSITION_TYPE:\n              return object;\n            default:\n              switch (object = object && object.$$typeof, object) {\n                case REACT_CONTEXT_TYPE:\n                case REACT_FORWARD_REF_TYPE:\n                case REACT_LAZY_TYPE:\n                case REACT_MEMO_TYPE:\n                  return object;\n                case REACT_CONSUMER_TYPE:\n                  return object;\n                default:\n                  return $$typeof;\n              }\n          }\n        case REACT_PORTAL_TYPE:\n          return $$typeof;\n      }\n    }\n  }\n  __name(typeOf, \"typeOf\");\n  reactIs_production.ContextConsumer = REACT_CONSUMER_TYPE;\n  reactIs_production.ContextProvider = REACT_CONTEXT_TYPE;\n  reactIs_production.Element = REACT_ELEMENT_TYPE;\n  reactIs_production.ForwardRef = REACT_FORWARD_REF_TYPE;\n  reactIs_production.Fragment = REACT_FRAGMENT_TYPE;\n  reactIs_production.Lazy = REACT_LAZY_TYPE;\n  reactIs_production.Memo = REACT_MEMO_TYPE;\n  reactIs_production.Portal = REACT_PORTAL_TYPE;\n  reactIs_production.Profiler = REACT_PROFILER_TYPE;\n  reactIs_production.StrictMode = REACT_STRICT_MODE_TYPE;\n  reactIs_production.Suspense = REACT_SUSPENSE_TYPE;\n  reactIs_production.SuspenseList = REACT_SUSPENSE_LIST_TYPE;\n  reactIs_production.isContextConsumer = function(object) {\n    return typeOf(object) === REACT_CONSUMER_TYPE;\n  };\n  reactIs_production.isContextProvider = function(object) {\n    return typeOf(object) === REACT_CONTEXT_TYPE;\n  };\n  reactIs_production.isElement = function(object) {\n    return \"object\" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;\n  };\n  reactIs_production.isForwardRef = function(object) {\n    return typeOf(object) === REACT_FORWARD_REF_TYPE;\n  };\n  reactIs_production.isFragment = function(object) {\n    return typeOf(object) === REACT_FRAGMENT_TYPE;\n  };\n  reactIs_production.isLazy = function(object) {\n    return typeOf(object) === REACT_LAZY_TYPE;\n  };\n  reactIs_production.isMemo = function(object) {\n    return typeOf(object) === REACT_MEMO_TYPE;\n  };\n  reactIs_production.isPortal = function(object) {\n    return typeOf(object) === REACT_PORTAL_TYPE;\n  };\n  reactIs_production.isProfiler = function(object) {\n    return typeOf(object) === REACT_PROFILER_TYPE;\n  };\n  reactIs_production.isStrictMode = function(object) {\n    return typeOf(object) === REACT_STRICT_MODE_TYPE;\n  };\n  reactIs_production.isSuspense = function(object) {\n    return typeOf(object) === REACT_SUSPENSE_TYPE;\n  };\n  reactIs_production.isSuspenseList = function(object) {\n    return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;\n  };\n  reactIs_production.isValidElementType = function(type) {\n    return \"string\" === typeof type || \"function\" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || \"object\" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? true : false;\n  };\n  reactIs_production.typeOf = typeOf;\n  return reactIs_production;\n}\n__name(requireReactIs_production, \"requireReactIs_production\");\nvar reactIs_development$1 = {};\nvar hasRequiredReactIs_development$1;\nfunction requireReactIs_development$1() {\n  if (hasRequiredReactIs_development$1) return reactIs_development$1;\n  hasRequiredReactIs_development$1 = 1;\n  return reactIs_development$1;\n}\n__name(requireReactIs_development$1, \"requireReactIs_development$1\");\nvar hasRequiredReactIs$1;\nfunction requireReactIs$1() {\n  if (hasRequiredReactIs$1) return reactIs$1.exports;\n  hasRequiredReactIs$1 = 1;\n  if (true) {\n    reactIs$1.exports = requireReactIs_production();\n  } else {\n    reactIs$1.exports = requireReactIs_development$1();\n  }\n  return reactIs$1.exports;\n}\n__name(requireReactIs$1, \"requireReactIs$1\");\nvar reactIsExports$1 = requireReactIs$1();\nvar index$1 = getDefaultExportFromCjs(reactIsExports$1);\nvar ReactIs19 = _mergeNamespaces({\n  __proto__: null,\n  default: index$1\n}, [reactIsExports$1]);\nvar reactIs = { exports: {} };\nvar reactIs_production_min = {};\nvar hasRequiredReactIs_production_min;\nfunction requireReactIs_production_min() {\n  if (hasRequiredReactIs_production_min) return reactIs_production_min;\n  hasRequiredReactIs_production_min = 1;\n  var b = Symbol.for(\"react.element\"), c = Symbol.for(\"react.portal\"), d = Symbol.for(\"react.fragment\"), e = Symbol.for(\"react.strict_mode\"), f2 = Symbol.for(\"react.profiler\"), g = Symbol.for(\"react.provider\"), h2 = Symbol.for(\"react.context\"), k = Symbol.for(\"react.server_context\"), l = Symbol.for(\"react.forward_ref\"), m2 = Symbol.for(\"react.suspense\"), n = Symbol.for(\"react.suspense_list\"), p2 = Symbol.for(\"react.memo\"), q = Symbol.for(\"react.lazy\"), t = Symbol.for(\"react.offscreen\"), u;\n  u = Symbol.for(\"react.module.reference\");\n  function v(a2) {\n    if (\"object\" === typeof a2 && null !== a2) {\n      var r = a2.$$typeof;\n      switch (r) {\n        case b:\n          switch (a2 = a2.type, a2) {\n            case d:\n            case f2:\n            case e:\n            case m2:\n            case n:\n              return a2;\n            default:\n              switch (a2 = a2 && a2.$$typeof, a2) {\n                case k:\n                case h2:\n                case l:\n                case q:\n                case p2:\n                case g:\n                  return a2;\n                default:\n                  return r;\n              }\n          }\n        case c:\n          return r;\n      }\n    }\n  }\n  __name(v, \"v\");\n  reactIs_production_min.ContextConsumer = h2;\n  reactIs_production_min.ContextProvider = g;\n  reactIs_production_min.Element = b;\n  reactIs_production_min.ForwardRef = l;\n  reactIs_production_min.Fragment = d;\n  reactIs_production_min.Lazy = q;\n  reactIs_production_min.Memo = p2;\n  reactIs_production_min.Portal = c;\n  reactIs_production_min.Profiler = f2;\n  reactIs_production_min.StrictMode = e;\n  reactIs_production_min.Suspense = m2;\n  reactIs_production_min.SuspenseList = n;\n  reactIs_production_min.isAsyncMode = function() {\n    return false;\n  };\n  reactIs_production_min.isConcurrentMode = function() {\n    return false;\n  };\n  reactIs_production_min.isContextConsumer = function(a2) {\n    return v(a2) === h2;\n  };\n  reactIs_production_min.isContextProvider = function(a2) {\n    return v(a2) === g;\n  };\n  reactIs_production_min.isElement = function(a2) {\n    return \"object\" === typeof a2 && null !== a2 && a2.$$typeof === b;\n  };\n  reactIs_production_min.isForwardRef = function(a2) {\n    return v(a2) === l;\n  };\n  reactIs_production_min.isFragment = function(a2) {\n    return v(a2) === d;\n  };\n  reactIs_production_min.isLazy = function(a2) {\n    return v(a2) === q;\n  };\n  reactIs_production_min.isMemo = function(a2) {\n    return v(a2) === p2;\n  };\n  reactIs_production_min.isPortal = function(a2) {\n    return v(a2) === c;\n  };\n  reactIs_production_min.isProfiler = function(a2) {\n    return v(a2) === f2;\n  };\n  reactIs_production_min.isStrictMode = function(a2) {\n    return v(a2) === e;\n  };\n  reactIs_production_min.isSuspense = function(a2) {\n    return v(a2) === m2;\n  };\n  reactIs_production_min.isSuspenseList = function(a2) {\n    return v(a2) === n;\n  };\n  reactIs_production_min.isValidElementType = function(a2) {\n    return \"string\" === typeof a2 || \"function\" === typeof a2 || a2 === d || a2 === f2 || a2 === e || a2 === m2 || a2 === n || a2 === t || \"object\" === typeof a2 && null !== a2 && (a2.$$typeof === q || a2.$$typeof === p2 || a2.$$typeof === g || a2.$$typeof === h2 || a2.$$typeof === l || a2.$$typeof === u || void 0 !== a2.getModuleId) ? true : false;\n  };\n  reactIs_production_min.typeOf = v;\n  return reactIs_production_min;\n}\n__name(requireReactIs_production_min, \"requireReactIs_production_min\");\nvar reactIs_development = {};\nvar hasRequiredReactIs_development;\nfunction requireReactIs_development() {\n  if (hasRequiredReactIs_development) return reactIs_development;\n  hasRequiredReactIs_development = 1;\n  if (false) {\n    (function() {\n      var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n      var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n      var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n      var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n      var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n      var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n      var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n      var REACT_SERVER_CONTEXT_TYPE = Symbol.for(\"react.server_context\");\n      var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n      var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n      var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n      var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n      var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n      var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n      var enableScopeAPI = false;\n      var enableCacheElement = false;\n      var enableTransitionTracing = false;\n      var enableLegacyHidden = false;\n      var enableDebugTracing = false;\n      var REACT_MODULE_REFERENCE;\n      {\n        REACT_MODULE_REFERENCE = Symbol.for(\"react.module.reference\");\n      }\n      function isValidElementType(type) {\n        if (typeof type === \"string\" || typeof type === \"function\") {\n          return true;\n        }\n        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n          return true;\n        }\n        if (typeof type === \"object\" && type !== null) {\n          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n          // types supported by any Flight configuration anywhere since\n          // we don't know which Flight build this will end up being used\n          // with.\n          type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {\n            return true;\n          }\n        }\n        return false;\n      }\n      __name(isValidElementType, \"isValidElementType\");\n      function typeOf(object) {\n        if (typeof object === \"object\" && object !== null) {\n          var $$typeof = object.$$typeof;\n          switch ($$typeof) {\n            case REACT_ELEMENT_TYPE:\n              var type = object.type;\n              switch (type) {\n                case REACT_FRAGMENT_TYPE:\n                case REACT_PROFILER_TYPE:\n                case REACT_STRICT_MODE_TYPE:\n                case REACT_SUSPENSE_TYPE:\n                case REACT_SUSPENSE_LIST_TYPE:\n                  return type;\n                default:\n                  var $$typeofType = type && type.$$typeof;\n                  switch ($$typeofType) {\n                    case REACT_SERVER_CONTEXT_TYPE:\n                    case REACT_CONTEXT_TYPE:\n                    case REACT_FORWARD_REF_TYPE:\n                    case REACT_LAZY_TYPE:\n                    case REACT_MEMO_TYPE:\n                    case REACT_PROVIDER_TYPE:\n                      return $$typeofType;\n                    default:\n                      return $$typeof;\n                  }\n              }\n            case REACT_PORTAL_TYPE:\n              return $$typeof;\n          }\n        }\n        return void 0;\n      }\n      __name(typeOf, \"typeOf\");\n      var ContextConsumer = REACT_CONTEXT_TYPE;\n      var ContextProvider = REACT_PROVIDER_TYPE;\n      var Element2 = REACT_ELEMENT_TYPE;\n      var ForwardRef = REACT_FORWARD_REF_TYPE;\n      var Fragment = REACT_FRAGMENT_TYPE;\n      var Lazy = REACT_LAZY_TYPE;\n      var Memo = REACT_MEMO_TYPE;\n      var Portal = REACT_PORTAL_TYPE;\n      var Profiler = REACT_PROFILER_TYPE;\n      var StrictMode = REACT_STRICT_MODE_TYPE;\n      var Suspense = REACT_SUSPENSE_TYPE;\n      var SuspenseList = REACT_SUSPENSE_LIST_TYPE;\n      var hasWarnedAboutDeprecatedIsAsyncMode = false;\n      var hasWarnedAboutDeprecatedIsConcurrentMode = false;\n      function isAsyncMode(object) {\n        {\n          if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n            hasWarnedAboutDeprecatedIsAsyncMode = true;\n            console[\"warn\"](\"The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.\");\n          }\n        }\n        return false;\n      }\n      __name(isAsyncMode, \"isAsyncMode\");\n      function isConcurrentMode(object) {\n        {\n          if (!hasWarnedAboutDeprecatedIsConcurrentMode) {\n            hasWarnedAboutDeprecatedIsConcurrentMode = true;\n            console[\"warn\"](\"The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.\");\n          }\n        }\n        return false;\n      }\n      __name(isConcurrentMode, \"isConcurrentMode\");\n      function isContextConsumer(object) {\n        return typeOf(object) === REACT_CONTEXT_TYPE;\n      }\n      __name(isContextConsumer, \"isContextConsumer\");\n      function isContextProvider(object) {\n        return typeOf(object) === REACT_PROVIDER_TYPE;\n      }\n      __name(isContextProvider, \"isContextProvider\");\n      function isElement(object) {\n        return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n      }\n      __name(isElement, \"isElement\");\n      function isForwardRef(object) {\n        return typeOf(object) === REACT_FORWARD_REF_TYPE;\n      }\n      __name(isForwardRef, \"isForwardRef\");\n      function isFragment(object) {\n        return typeOf(object) === REACT_FRAGMENT_TYPE;\n      }\n      __name(isFragment, \"isFragment\");\n      function isLazy(object) {\n        return typeOf(object) === REACT_LAZY_TYPE;\n      }\n      __name(isLazy, \"isLazy\");\n      function isMemo(object) {\n        return typeOf(object) === REACT_MEMO_TYPE;\n      }\n      __name(isMemo, \"isMemo\");\n      function isPortal(object) {\n        return typeOf(object) === REACT_PORTAL_TYPE;\n      }\n      __name(isPortal, \"isPortal\");\n      function isProfiler(object) {\n        return typeOf(object) === REACT_PROFILER_TYPE;\n      }\n      __name(isProfiler, \"isProfiler\");\n      function isStrictMode(object) {\n        return typeOf(object) === REACT_STRICT_MODE_TYPE;\n      }\n      __name(isStrictMode, \"isStrictMode\");\n      function isSuspense(object) {\n        return typeOf(object) === REACT_SUSPENSE_TYPE;\n      }\n      __name(isSuspense, \"isSuspense\");\n      function isSuspenseList(object) {\n        return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;\n      }\n      __name(isSuspenseList, \"isSuspenseList\");\n      reactIs_development.ContextConsumer = ContextConsumer;\n      reactIs_development.ContextProvider = ContextProvider;\n      reactIs_development.Element = Element2;\n      reactIs_development.ForwardRef = ForwardRef;\n      reactIs_development.Fragment = Fragment;\n      reactIs_development.Lazy = Lazy;\n      reactIs_development.Memo = Memo;\n      reactIs_development.Portal = Portal;\n      reactIs_development.Profiler = Profiler;\n      reactIs_development.StrictMode = StrictMode;\n      reactIs_development.Suspense = Suspense;\n      reactIs_development.SuspenseList = SuspenseList;\n      reactIs_development.isAsyncMode = isAsyncMode;\n      reactIs_development.isConcurrentMode = isConcurrentMode;\n      reactIs_development.isContextConsumer = isContextConsumer;\n      reactIs_development.isContextProvider = isContextProvider;\n      reactIs_development.isElement = isElement;\n      reactIs_development.isForwardRef = isForwardRef;\n      reactIs_development.isFragment = isFragment;\n      reactIs_development.isLazy = isLazy;\n      reactIs_development.isMemo = isMemo;\n      reactIs_development.isPortal = isPortal;\n      reactIs_development.isProfiler = isProfiler;\n      reactIs_development.isStrictMode = isStrictMode;\n      reactIs_development.isSuspense = isSuspense;\n      reactIs_development.isSuspenseList = isSuspenseList;\n      reactIs_development.isValidElementType = isValidElementType;\n      reactIs_development.typeOf = typeOf;\n    })();\n  }\n  return reactIs_development;\n}\n__name(requireReactIs_development, \"requireReactIs_development\");\nvar hasRequiredReactIs;\nfunction requireReactIs() {\n  if (hasRequiredReactIs) return reactIs.exports;\n  hasRequiredReactIs = 1;\n  if (true) {\n    reactIs.exports = requireReactIs_production_min();\n  } else {\n    reactIs.exports = requireReactIs_development();\n  }\n  return reactIs.exports;\n}\n__name(requireReactIs, \"requireReactIs\");\nvar reactIsExports = requireReactIs();\nvar index = getDefaultExportFromCjs(reactIsExports);\nvar ReactIs18 = _mergeNamespaces({\n  __proto__: null,\n  default: index\n}, [reactIsExports]);\nvar reactIsMethods = [\n  \"isAsyncMode\",\n  \"isConcurrentMode\",\n  \"isContextConsumer\",\n  \"isContextProvider\",\n  \"isElement\",\n  \"isForwardRef\",\n  \"isFragment\",\n  \"isLazy\",\n  \"isMemo\",\n  \"isPortal\",\n  \"isProfiler\",\n  \"isStrictMode\",\n  \"isSuspense\",\n  \"isSuspenseList\",\n  \"isValidElementType\"\n];\nvar ReactIs = Object.fromEntries(reactIsMethods.map((m2) => [m2, (v) => ReactIs18[m2](v) || ReactIs19[m2](v)]));\nfunction getChildren(arg, children = []) {\n  if (Array.isArray(arg)) {\n    for (const item of arg) {\n      getChildren(item, children);\n    }\n  } else if (arg != null && arg !== false && arg !== \"\") {\n    children.push(arg);\n  }\n  return children;\n}\n__name(getChildren, \"getChildren\");\nfunction getType(element) {\n  const type = element.type;\n  if (typeof type === \"string\") {\n    return type;\n  }\n  if (typeof type === \"function\") {\n    return type.displayName || type.name || \"Unknown\";\n  }\n  if (ReactIs.isFragment(element)) {\n    return \"React.Fragment\";\n  }\n  if (ReactIs.isSuspense(element)) {\n    return \"React.Suspense\";\n  }\n  if (typeof type === \"object\" && type !== null) {\n    if (ReactIs.isContextProvider(element)) {\n      return \"Context.Provider\";\n    }\n    if (ReactIs.isContextConsumer(element)) {\n      return \"Context.Consumer\";\n    }\n    if (ReactIs.isForwardRef(element)) {\n      if (type.displayName) {\n        return type.displayName;\n      }\n      const functionName = type.render.displayName || type.render.name || \"\";\n      return functionName === \"\" ? \"ForwardRef\" : `ForwardRef(${functionName})`;\n    }\n    if (ReactIs.isMemo(element)) {\n      const functionName = type.displayName || type.type.displayName || type.type.name || \"\";\n      return functionName === \"\" ? \"Memo\" : `Memo(${functionName})`;\n    }\n  }\n  return \"UNDEFINED\";\n}\n__name(getType, \"getType\");\nfunction getPropKeys$1(element) {\n  const { props } = element;\n  return Object.keys(props).filter((key) => key !== \"children\" && props[key] !== void 0).sort();\n}\n__name(getPropKeys$1, \"getPropKeys$1\");\nvar serialize$1 = /* @__PURE__ */ __name((element, config, indentation, depth, refs, printer2) => ++depth > config.maxDepth ? printElementAsLeaf(getType(element), config) : printElement(getType(element), printProps(getPropKeys$1(element), element.props, config, indentation + config.indent, depth, refs, printer2), printChildren(getChildren(element.props.children), config, indentation + config.indent, depth, refs, printer2), config, indentation), \"serialize$1\");\nvar test$1 = /* @__PURE__ */ __name((val) => val != null && ReactIs.isElement(val), \"test$1\");\nvar plugin$1 = {\n  serialize: serialize$1,\n  test: test$1\n};\nvar testSymbol = typeof Symbol === \"function\" && Symbol.for ? Symbol.for(\"react.test.json\") : 245830487;\nfunction getPropKeys(object) {\n  const { props } = object;\n  return props ? Object.keys(props).filter((key) => props[key] !== void 0).sort() : [];\n}\n__name(getPropKeys, \"getPropKeys\");\nvar serialize = /* @__PURE__ */ __name((object, config, indentation, depth, refs, printer2) => ++depth > config.maxDepth ? printElementAsLeaf(object.type, config) : printElement(object.type, object.props ? printProps(getPropKeys(object), object.props, config, indentation + config.indent, depth, refs, printer2) : \"\", object.children ? printChildren(object.children, config, indentation + config.indent, depth, refs, printer2) : \"\", config, indentation), \"serialize\");\nvar test = /* @__PURE__ */ __name((val) => val && val.$$typeof === testSymbol, \"test\");\nvar plugin = {\n  serialize,\n  test\n};\nvar toString = Object.prototype.toString;\nvar toISOString = Date.prototype.toISOString;\nvar errorToString = Error.prototype.toString;\nvar regExpToString = RegExp.prototype.toString;\nfunction getConstructorName(val) {\n  return typeof val.constructor === \"function\" && val.constructor.name || \"Object\";\n}\n__name(getConstructorName, \"getConstructorName\");\nfunction isWindow(val) {\n  return typeof window !== \"undefined\" && val === window;\n}\n__name(isWindow, \"isWindow\");\nvar SYMBOL_REGEXP = /^Symbol\\((.*)\\)(.*)$/;\nvar NEWLINE_REGEXP = /\\n/g;\nvar _PrettyFormatPluginError = class _PrettyFormatPluginError2 extends Error {\n  constructor(message, stack) {\n    super(message);\n    this.stack = stack;\n    this.name = this.constructor.name;\n  }\n};\n__name(_PrettyFormatPluginError, \"PrettyFormatPluginError\");\nvar PrettyFormatPluginError = _PrettyFormatPluginError;\nfunction isToStringedArrayType(toStringed) {\n  return toStringed === \"[object Array]\" || toStringed === \"[object ArrayBuffer]\" || toStringed === \"[object DataView]\" || toStringed === \"[object Float32Array]\" || toStringed === \"[object Float64Array]\" || toStringed === \"[object Int8Array]\" || toStringed === \"[object Int16Array]\" || toStringed === \"[object Int32Array]\" || toStringed === \"[object Uint8Array]\" || toStringed === \"[object Uint8ClampedArray]\" || toStringed === \"[object Uint16Array]\" || toStringed === \"[object Uint32Array]\";\n}\n__name(isToStringedArrayType, \"isToStringedArrayType\");\nfunction printNumber(val) {\n  return Object.is(val, -0) ? \"-0\" : String(val);\n}\n__name(printNumber, \"printNumber\");\nfunction printBigInt(val) {\n  return String(`${val}n`);\n}\n__name(printBigInt, \"printBigInt\");\nfunction printFunction(val, printFunctionName) {\n  if (!printFunctionName) {\n    return \"[Function]\";\n  }\n  return `[Function ${val.name || \"anonymous\"}]`;\n}\n__name(printFunction, \"printFunction\");\nfunction printSymbol(val) {\n  return String(val).replace(SYMBOL_REGEXP, \"Symbol($1)\");\n}\n__name(printSymbol, \"printSymbol\");\nfunction printError(val) {\n  return `[${errorToString.call(val)}]`;\n}\n__name(printError, \"printError\");\nfunction printBasicValue(val, printFunctionName, escapeRegex, escapeString) {\n  if (val === true || val === false) {\n    return `${val}`;\n  }\n  if (val === void 0) {\n    return \"undefined\";\n  }\n  if (val === null) {\n    return \"null\";\n  }\n  const typeOf = typeof val;\n  if (typeOf === \"number\") {\n    return printNumber(val);\n  }\n  if (typeOf === \"bigint\") {\n    return printBigInt(val);\n  }\n  if (typeOf === \"string\") {\n    if (escapeString) {\n      return `\"${val.replaceAll(/\"|\\\\/g, \"\\\\$&\")}\"`;\n    }\n    return `\"${val}\"`;\n  }\n  if (typeOf === \"function\") {\n    return printFunction(val, printFunctionName);\n  }\n  if (typeOf === \"symbol\") {\n    return printSymbol(val);\n  }\n  const toStringed = toString.call(val);\n  if (toStringed === \"[object WeakMap]\") {\n    return \"WeakMap {}\";\n  }\n  if (toStringed === \"[object WeakSet]\") {\n    return \"WeakSet {}\";\n  }\n  if (toStringed === \"[object Function]\" || toStringed === \"[object GeneratorFunction]\") {\n    return printFunction(val, printFunctionName);\n  }\n  if (toStringed === \"[object Symbol]\") {\n    return printSymbol(val);\n  }\n  if (toStringed === \"[object Date]\") {\n    return Number.isNaN(+val) ? \"Date { NaN }\" : toISOString.call(val);\n  }\n  if (toStringed === \"[object Error]\") {\n    return printError(val);\n  }\n  if (toStringed === \"[object RegExp]\") {\n    if (escapeRegex) {\n      return regExpToString.call(val).replaceAll(/[$()*+.?[\\\\\\]^{|}]/g, \"\\\\$&\");\n    }\n    return regExpToString.call(val);\n  }\n  if (val instanceof Error) {\n    return printError(val);\n  }\n  return null;\n}\n__name(printBasicValue, \"printBasicValue\");\nfunction printComplexValue(val, config, indentation, depth, refs, hasCalledToJSON) {\n  if (refs.includes(val)) {\n    return \"[Circular]\";\n  }\n  refs = [...refs];\n  refs.push(val);\n  const hitMaxDepth = ++depth > config.maxDepth;\n  const min = config.min;\n  if (config.callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON === \"function\" && !hasCalledToJSON) {\n    return printer(val.toJSON(), config, indentation, depth, refs, true);\n  }\n  const toStringed = toString.call(val);\n  if (toStringed === \"[object Arguments]\") {\n    return hitMaxDepth ? \"[Arguments]\" : `${min ? \"\" : \"Arguments \"}[${printListItems(val, config, indentation, depth, refs, printer)}]`;\n  }\n  if (isToStringedArrayType(toStringed)) {\n    return hitMaxDepth ? `[${val.constructor.name}]` : `${min ? \"\" : !config.printBasicPrototype && val.constructor.name === \"Array\" ? \"\" : `${val.constructor.name} `}[${printListItems(val, config, indentation, depth, refs, printer)}]`;\n  }\n  if (toStringed === \"[object Map]\") {\n    return hitMaxDepth ? \"[Map]\" : `Map {${printIteratorEntries(val.entries(), config, indentation, depth, refs, printer, \" => \")}}`;\n  }\n  if (toStringed === \"[object Set]\") {\n    return hitMaxDepth ? \"[Set]\" : `Set {${printIteratorValues(val.values(), config, indentation, depth, refs, printer)}}`;\n  }\n  return hitMaxDepth || isWindow(val) ? `[${getConstructorName(val)}]` : `${min ? \"\" : !config.printBasicPrototype && getConstructorName(val) === \"Object\" ? \"\" : `${getConstructorName(val)} `}{${printObjectProperties(val, config, indentation, depth, refs, printer)}}`;\n}\n__name(printComplexValue, \"printComplexValue\");\nvar ErrorPlugin = {\n  test: /* @__PURE__ */ __name((val) => val && val instanceof Error, \"test\"),\n  serialize(val, config, indentation, depth, refs, printer2) {\n    if (refs.includes(val)) {\n      return \"[Circular]\";\n    }\n    refs = [...refs, val];\n    const hitMaxDepth = ++depth > config.maxDepth;\n    const { message, cause, ...rest } = val;\n    const entries = {\n      message,\n      ...typeof cause !== \"undefined\" ? { cause } : {},\n      ...val instanceof AggregateError ? { errors: val.errors } : {},\n      ...rest\n    };\n    const name = val.name !== \"Error\" ? val.name : getConstructorName(val);\n    return hitMaxDepth ? `[${name}]` : `${name} {${printIteratorEntries(Object.entries(entries).values(), config, indentation, depth, refs, printer2)}}`;\n  }\n};\nfunction isNewPlugin(plugin2) {\n  return plugin2.serialize != null;\n}\n__name(isNewPlugin, \"isNewPlugin\");\nfunction printPlugin(plugin2, val, config, indentation, depth, refs) {\n  let printed;\n  try {\n    printed = isNewPlugin(plugin2) ? plugin2.serialize(val, config, indentation, depth, refs, printer) : plugin2.print(val, (valChild) => printer(valChild, config, indentation, depth, refs), (str) => {\n      const indentationNext = indentation + config.indent;\n      return indentationNext + str.replaceAll(NEWLINE_REGEXP, `\n${indentationNext}`);\n    }, {\n      edgeSpacing: config.spacingOuter,\n      min: config.min,\n      spacing: config.spacingInner\n    }, config.colors);\n  } catch (error) {\n    throw new PrettyFormatPluginError(error.message, error.stack);\n  }\n  if (typeof printed !== \"string\") {\n    throw new TypeError(`pretty-format: Plugin must return type \"string\" but instead returned \"${typeof printed}\".`);\n  }\n  return printed;\n}\n__name(printPlugin, \"printPlugin\");\nfunction findPlugin(plugins2, val) {\n  for (const plugin2 of plugins2) {\n    try {\n      if (plugin2.test(val)) {\n        return plugin2;\n      }\n    } catch (error) {\n      throw new PrettyFormatPluginError(error.message, error.stack);\n    }\n  }\n  return null;\n}\n__name(findPlugin, \"findPlugin\");\nfunction printer(val, config, indentation, depth, refs, hasCalledToJSON) {\n  const plugin2 = findPlugin(config.plugins, val);\n  if (plugin2 !== null) {\n    return printPlugin(plugin2, val, config, indentation, depth, refs);\n  }\n  const basicResult = printBasicValue(val, config.printFunctionName, config.escapeRegex, config.escapeString);\n  if (basicResult !== null) {\n    return basicResult;\n  }\n  return printComplexValue(val, config, indentation, depth, refs, hasCalledToJSON);\n}\n__name(printer, \"printer\");\nvar DEFAULT_THEME = {\n  comment: \"gray\",\n  content: \"reset\",\n  prop: \"yellow\",\n  tag: \"cyan\",\n  value: \"green\"\n};\nvar DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME);\nvar DEFAULT_OPTIONS = {\n  callToJSON: true,\n  compareKeys: void 0,\n  escapeRegex: false,\n  escapeString: true,\n  highlight: false,\n  indent: 2,\n  maxDepth: Number.POSITIVE_INFINITY,\n  maxWidth: Number.POSITIVE_INFINITY,\n  min: false,\n  plugins: [],\n  printBasicPrototype: true,\n  printFunctionName: true,\n  theme: DEFAULT_THEME\n};\nfunction validateOptions(options) {\n  for (const key of Object.keys(options)) {\n    if (!Object.prototype.hasOwnProperty.call(DEFAULT_OPTIONS, key)) {\n      throw new Error(`pretty-format: Unknown option \"${key}\".`);\n    }\n  }\n  if (options.min && options.indent !== void 0 && options.indent !== 0) {\n    throw new Error('pretty-format: Options \"min\" and \"indent\" cannot be used together.');\n  }\n}\n__name(validateOptions, \"validateOptions\");\nfunction getColorsHighlight() {\n  return DEFAULT_THEME_KEYS.reduce((colors, key) => {\n    const value = DEFAULT_THEME[key];\n    const color = value && s[value];\n    if (color && typeof color.close === \"string\" && typeof color.open === \"string\") {\n      colors[key] = color;\n    } else {\n      throw new Error(`pretty-format: Option \"theme\" has a key \"${key}\" whose value \"${value}\" is undefined in ansi-styles.`);\n    }\n    return colors;\n  }, /* @__PURE__ */ Object.create(null));\n}\n__name(getColorsHighlight, \"getColorsHighlight\");\nfunction getColorsEmpty() {\n  return DEFAULT_THEME_KEYS.reduce((colors, key) => {\n    colors[key] = {\n      close: \"\",\n      open: \"\"\n    };\n    return colors;\n  }, /* @__PURE__ */ Object.create(null));\n}\n__name(getColorsEmpty, \"getColorsEmpty\");\nfunction getPrintFunctionName(options) {\n  return (options === null || options === void 0 ? void 0 : options.printFunctionName) ?? DEFAULT_OPTIONS.printFunctionName;\n}\n__name(getPrintFunctionName, \"getPrintFunctionName\");\nfunction getEscapeRegex(options) {\n  return (options === null || options === void 0 ? void 0 : options.escapeRegex) ?? DEFAULT_OPTIONS.escapeRegex;\n}\n__name(getEscapeRegex, \"getEscapeRegex\");\nfunction getEscapeString(options) {\n  return (options === null || options === void 0 ? void 0 : options.escapeString) ?? DEFAULT_OPTIONS.escapeString;\n}\n__name(getEscapeString, \"getEscapeString\");\nfunction getConfig(options) {\n  return {\n    callToJSON: (options === null || options === void 0 ? void 0 : options.callToJSON) ?? DEFAULT_OPTIONS.callToJSON,\n    colors: (options === null || options === void 0 ? void 0 : options.highlight) ? getColorsHighlight() : getColorsEmpty(),\n    compareKeys: typeof (options === null || options === void 0 ? void 0 : options.compareKeys) === \"function\" || (options === null || options === void 0 ? void 0 : options.compareKeys) === null ? options.compareKeys : DEFAULT_OPTIONS.compareKeys,\n    escapeRegex: getEscapeRegex(options),\n    escapeString: getEscapeString(options),\n    indent: (options === null || options === void 0 ? void 0 : options.min) ? \"\" : createIndent((options === null || options === void 0 ? void 0 : options.indent) ?? DEFAULT_OPTIONS.indent),\n    maxDepth: (options === null || options === void 0 ? void 0 : options.maxDepth) ?? DEFAULT_OPTIONS.maxDepth,\n    maxWidth: (options === null || options === void 0 ? void 0 : options.maxWidth) ?? DEFAULT_OPTIONS.maxWidth,\n    min: (options === null || options === void 0 ? void 0 : options.min) ?? DEFAULT_OPTIONS.min,\n    plugins: (options === null || options === void 0 ? void 0 : options.plugins) ?? DEFAULT_OPTIONS.plugins,\n    printBasicPrototype: (options === null || options === void 0 ? void 0 : options.printBasicPrototype) ?? true,\n    printFunctionName: getPrintFunctionName(options),\n    spacingInner: (options === null || options === void 0 ? void 0 : options.min) ? \" \" : \"\\n\",\n    spacingOuter: (options === null || options === void 0 ? void 0 : options.min) ? \"\" : \"\\n\"\n  };\n}\n__name(getConfig, \"getConfig\");\nfunction createIndent(indent) {\n  return Array.from({ length: indent + 1 }).join(\" \");\n}\n__name(createIndent, \"createIndent\");\nfunction format(val, options) {\n  if (options) {\n    validateOptions(options);\n    if (options.plugins) {\n      const plugin2 = findPlugin(options.plugins, val);\n      if (plugin2 !== null) {\n        return printPlugin(plugin2, val, getConfig(options), \"\", 0, []);\n      }\n    }\n  }\n  const basicResult = printBasicValue(val, getPrintFunctionName(options), getEscapeRegex(options), getEscapeString(options));\n  if (basicResult !== null) {\n    return basicResult;\n  }\n  return printComplexValue(val, getConfig(options), \"\", 0, []);\n}\n__name(format, \"format\");\nvar plugins = {\n  AsymmetricMatcher: plugin$5,\n  DOMCollection: plugin$4,\n  DOMElement: plugin$3,\n  Immutable: plugin$2,\n  ReactElement: plugin$1,\n  ReactTestComponent: plugin,\n  Error: ErrorPlugin\n};\nvar ansiColors = {\n  bold: [\"1\", \"22\"],\n  dim: [\"2\", \"22\"],\n  italic: [\"3\", \"23\"],\n  underline: [\"4\", \"24\"],\n  // 5 & 6 are blinking\n  inverse: [\"7\", \"27\"],\n  hidden: [\"8\", \"28\"],\n  strike: [\"9\", \"29\"],\n  // 10-20 are fonts\n  // 21-29 are resets for 1-9\n  black: [\"30\", \"39\"],\n  red: [\"31\", \"39\"],\n  green: [\"32\", \"39\"],\n  yellow: [\"33\", \"39\"],\n  blue: [\"34\", \"39\"],\n  magenta: [\"35\", \"39\"],\n  cyan: [\"36\", \"39\"],\n  white: [\"37\", \"39\"],\n  brightblack: [\"30;1\", \"39\"],\n  brightred: [\"31;1\", \"39\"],\n  brightgreen: [\"32;1\", \"39\"],\n  brightyellow: [\"33;1\", \"39\"],\n  brightblue: [\"34;1\", \"39\"],\n  brightmagenta: [\"35;1\", \"39\"],\n  brightcyan: [\"36;1\", \"39\"],\n  brightwhite: [\"37;1\", \"39\"],\n  grey: [\"90\", \"39\"]\n};\nvar styles = {\n  special: \"cyan\",\n  number: \"yellow\",\n  bigint: \"yellow\",\n  boolean: \"yellow\",\n  undefined: \"grey\",\n  null: \"bold\",\n  string: \"green\",\n  symbol: \"green\",\n  date: \"magenta\",\n  regexp: \"red\"\n};\nvar truncator = \"\";\nfunction colorise(value, styleType) {\n  const color = ansiColors[styles[styleType]] || ansiColors[styleType] || \"\";\n  if (!color) {\n    return String(value);\n  }\n  return `\\x1B[${color[0]}m${String(value)}\\x1B[${color[1]}m`;\n}\n__name(colorise, \"colorise\");\nfunction normaliseOptions({\n  showHidden = false,\n  depth = 2,\n  colors = false,\n  customInspect = true,\n  showProxy = false,\n  maxArrayLength = Infinity,\n  breakLength = Infinity,\n  seen = [],\n  // eslint-disable-next-line no-shadow\n  truncate: truncate2 = Infinity,\n  stylize = String\n} = {}, inspect3) {\n  const options = {\n    showHidden: Boolean(showHidden),\n    depth: Number(depth),\n    colors: Boolean(colors),\n    customInspect: Boolean(customInspect),\n    showProxy: Boolean(showProxy),\n    maxArrayLength: Number(maxArrayLength),\n    breakLength: Number(breakLength),\n    truncate: Number(truncate2),\n    seen,\n    inspect: inspect3,\n    stylize\n  };\n  if (options.colors) {\n    options.stylize = colorise;\n  }\n  return options;\n}\n__name(normaliseOptions, \"normaliseOptions\");\nfunction isHighSurrogate(char) {\n  return char >= \"\\uD800\" && char <= \"\\uDBFF\";\n}\n__name(isHighSurrogate, \"isHighSurrogate\");\nfunction truncate(string, length, tail = truncator) {\n  string = String(string);\n  const tailLength = tail.length;\n  const stringLength = string.length;\n  if (tailLength > length && stringLength > tailLength) {\n    return tail;\n  }\n  if (stringLength > length && stringLength > tailLength) {\n    let end = length - tailLength;\n    if (end > 0 && isHighSurrogate(string[end - 1])) {\n      end = end - 1;\n    }\n    return `${string.slice(0, end)}${tail}`;\n  }\n  return string;\n}\n__name(truncate, \"truncate\");\nfunction inspectList(list, options, inspectItem, separator = \", \") {\n  inspectItem = inspectItem || options.inspect;\n  const size = list.length;\n  if (size === 0)\n    return \"\";\n  const originalLength = options.truncate;\n  let output = \"\";\n  let peek = \"\";\n  let truncated = \"\";\n  for (let i = 0; i < size; i += 1) {\n    const last = i + 1 === list.length;\n    const secondToLast = i + 2 === list.length;\n    truncated = `${truncator}(${list.length - i})`;\n    const value = list[i];\n    options.truncate = originalLength - output.length - (last ? 0 : separator.length);\n    const string = peek || inspectItem(value, options) + (last ? \"\" : separator);\n    const nextLength = output.length + string.length;\n    const truncatedLength = nextLength + truncated.length;\n    if (last && nextLength > originalLength && output.length + truncated.length <= originalLength) {\n      break;\n    }\n    if (!last && !secondToLast && truncatedLength > originalLength) {\n      break;\n    }\n    peek = last ? \"\" : inspectItem(list[i + 1], options) + (secondToLast ? \"\" : separator);\n    if (!last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength) {\n      break;\n    }\n    output += string;\n    if (!last && !secondToLast && nextLength + peek.length >= originalLength) {\n      truncated = `${truncator}(${list.length - i - 1})`;\n      break;\n    }\n    truncated = \"\";\n  }\n  return `${output}${truncated}`;\n}\n__name(inspectList, \"inspectList\");\nfunction quoteComplexKey(key) {\n  if (key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)) {\n    return key;\n  }\n  return JSON.stringify(key).replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\");\n}\n__name(quoteComplexKey, \"quoteComplexKey\");\nfunction inspectProperty([key, value], options) {\n  options.truncate -= 2;\n  if (typeof key === \"string\") {\n    key = quoteComplexKey(key);\n  } else if (typeof key !== \"number\") {\n    key = `[${options.inspect(key, options)}]`;\n  }\n  options.truncate -= key.length;\n  value = options.inspect(value, options);\n  return `${key}: ${value}`;\n}\n__name(inspectProperty, \"inspectProperty\");\nfunction inspectArray(array, options) {\n  const nonIndexProperties = Object.keys(array).slice(array.length);\n  if (!array.length && !nonIndexProperties.length)\n    return \"[]\";\n  options.truncate -= 4;\n  const listContents = inspectList(array, options);\n  options.truncate -= listContents.length;\n  let propertyContents = \"\";\n  if (nonIndexProperties.length) {\n    propertyContents = inspectList(nonIndexProperties.map((key) => [key, array[key]]), options, inspectProperty);\n  }\n  return `[ ${listContents}${propertyContents ? `, ${propertyContents}` : \"\"} ]`;\n}\n__name(inspectArray, \"inspectArray\");\nvar getArrayName = /* @__PURE__ */ __name((array) => {\n  if (typeof Buffer === \"function\" && array instanceof Buffer) {\n    return \"Buffer\";\n  }\n  if (array[Symbol.toStringTag]) {\n    return array[Symbol.toStringTag];\n  }\n  return array.constructor.name;\n}, \"getArrayName\");\nfunction inspectTypedArray(array, options) {\n  const name = getArrayName(array);\n  options.truncate -= name.length + 4;\n  const nonIndexProperties = Object.keys(array).slice(array.length);\n  if (!array.length && !nonIndexProperties.length)\n    return `${name}[]`;\n  let output = \"\";\n  for (let i = 0; i < array.length; i++) {\n    const string = `${options.stylize(truncate(array[i], options.truncate), \"number\")}${i === array.length - 1 ? \"\" : \", \"}`;\n    options.truncate -= string.length;\n    if (array[i] !== array.length && options.truncate <= 3) {\n      output += `${truncator}(${array.length - array[i] + 1})`;\n      break;\n    }\n    output += string;\n  }\n  let propertyContents = \"\";\n  if (nonIndexProperties.length) {\n    propertyContents = inspectList(nonIndexProperties.map((key) => [key, array[key]]), options, inspectProperty);\n  }\n  return `${name}[ ${output}${propertyContents ? `, ${propertyContents}` : \"\"} ]`;\n}\n__name(inspectTypedArray, \"inspectTypedArray\");\nfunction inspectDate(dateObject, options) {\n  const stringRepresentation = dateObject.toJSON();\n  if (stringRepresentation === null) {\n    return \"Invalid Date\";\n  }\n  const split = stringRepresentation.split(\"T\");\n  const date = split[0];\n  return options.stylize(`${date}T${truncate(split[1], options.truncate - date.length - 1)}`, \"date\");\n}\n__name(inspectDate, \"inspectDate\");\nfunction inspectFunction(func, options) {\n  const functionType = func[Symbol.toStringTag] || \"Function\";\n  const name = func.name;\n  if (!name) {\n    return options.stylize(`[${functionType}]`, \"special\");\n  }\n  return options.stylize(`[${functionType} ${truncate(name, options.truncate - 11)}]`, \"special\");\n}\n__name(inspectFunction, \"inspectFunction\");\nfunction inspectMapEntry([key, value], options) {\n  options.truncate -= 4;\n  key = options.inspect(key, options);\n  options.truncate -= key.length;\n  value = options.inspect(value, options);\n  return `${key} => ${value}`;\n}\n__name(inspectMapEntry, \"inspectMapEntry\");\nfunction mapToEntries(map) {\n  const entries = [];\n  map.forEach((value, key) => {\n    entries.push([key, value]);\n  });\n  return entries;\n}\n__name(mapToEntries, \"mapToEntries\");\nfunction inspectMap(map, options) {\n  if (map.size === 0)\n    return \"Map{}\";\n  options.truncate -= 7;\n  return `Map{ ${inspectList(mapToEntries(map), options, inspectMapEntry)} }`;\n}\n__name(inspectMap, \"inspectMap\");\nvar isNaN = Number.isNaN || ((i) => i !== i);\nfunction inspectNumber(number, options) {\n  if (isNaN(number)) {\n    return options.stylize(\"NaN\", \"number\");\n  }\n  if (number === Infinity) {\n    return options.stylize(\"Infinity\", \"number\");\n  }\n  if (number === -Infinity) {\n    return options.stylize(\"-Infinity\", \"number\");\n  }\n  if (number === 0) {\n    return options.stylize(1 / number === Infinity ? \"+0\" : \"-0\", \"number\");\n  }\n  return options.stylize(truncate(String(number), options.truncate), \"number\");\n}\n__name(inspectNumber, \"inspectNumber\");\nfunction inspectBigInt(number, options) {\n  let nums = truncate(number.toString(), options.truncate - 1);\n  if (nums !== truncator)\n    nums += \"n\";\n  return options.stylize(nums, \"bigint\");\n}\n__name(inspectBigInt, \"inspectBigInt\");\nfunction inspectRegExp(value, options) {\n  const flags = value.toString().split(\"/\")[2];\n  const sourceLength = options.truncate - (2 + flags.length);\n  const source = value.source;\n  return options.stylize(`/${truncate(source, sourceLength)}/${flags}`, \"regexp\");\n}\n__name(inspectRegExp, \"inspectRegExp\");\nfunction arrayFromSet(set) {\n  const values = [];\n  set.forEach((value) => {\n    values.push(value);\n  });\n  return values;\n}\n__name(arrayFromSet, \"arrayFromSet\");\nfunction inspectSet(set, options) {\n  if (set.size === 0)\n    return \"Set{}\";\n  options.truncate -= 7;\n  return `Set{ ${inspectList(arrayFromSet(set), options)} }`;\n}\n__name(inspectSet, \"inspectSet\");\nvar stringEscapeChars = new RegExp(\"['\\\\u0000-\\\\u001f\\\\u007f-\\\\u009f\\\\u00ad\\\\u0600-\\\\u0604\\\\u070f\\\\u17b4\\\\u17b5\\\\u200c-\\\\u200f\\\\u2028-\\\\u202f\\\\u2060-\\\\u206f\\\\ufeff\\\\ufff0-\\\\uffff]\", \"g\");\nvar escapeCharacters = {\n  \"\\b\": \"\\\\b\",\n  \"\t\": \"\\\\t\",\n  \"\\n\": \"\\\\n\",\n  \"\\f\": \"\\\\f\",\n  \"\\r\": \"\\\\r\",\n  \"'\": \"\\\\'\",\n  \"\\\\\": \"\\\\\\\\\"\n};\nvar hex = 16;\nvar unicodeLength = 4;\nfunction escape(char) {\n  return escapeCharacters[char] || `\\\\u${`0000${char.charCodeAt(0).toString(hex)}`.slice(-unicodeLength)}`;\n}\n__name(escape, \"escape\");\nfunction inspectString(string, options) {\n  if (stringEscapeChars.test(string)) {\n    string = string.replace(stringEscapeChars, escape);\n  }\n  return options.stylize(`'${truncate(string, options.truncate - 2)}'`, \"string\");\n}\n__name(inspectString, \"inspectString\");\nfunction inspectSymbol(value) {\n  if (\"description\" in Symbol.prototype) {\n    return value.description ? `Symbol(${value.description})` : \"Symbol()\";\n  }\n  return value.toString();\n}\n__name(inspectSymbol, \"inspectSymbol\");\nvar getPromiseValue = /* @__PURE__ */ __name(() => \"Promise{}\", \"getPromiseValue\");\nvar promise_default = getPromiseValue;\nfunction inspectObject(object, options) {\n  const properties = Object.getOwnPropertyNames(object);\n  const symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : [];\n  if (properties.length === 0 && symbols.length === 0) {\n    return \"{}\";\n  }\n  options.truncate -= 4;\n  options.seen = options.seen || [];\n  if (options.seen.includes(object)) {\n    return \"[Circular]\";\n  }\n  options.seen.push(object);\n  const propertyContents = inspectList(properties.map((key) => [key, object[key]]), options, inspectProperty);\n  const symbolContents = inspectList(symbols.map((key) => [key, object[key]]), options, inspectProperty);\n  options.seen.pop();\n  let sep = \"\";\n  if (propertyContents && symbolContents) {\n    sep = \", \";\n  }\n  return `{ ${propertyContents}${sep}${symbolContents} }`;\n}\n__name(inspectObject, \"inspectObject\");\nvar toStringTag = typeof Symbol !== \"undefined\" && Symbol.toStringTag ? Symbol.toStringTag : false;\nfunction inspectClass(value, options) {\n  let name = \"\";\n  if (toStringTag && toStringTag in value) {\n    name = value[toStringTag];\n  }\n  name = name || value.constructor.name;\n  if (!name || name === \"_class\") {\n    name = \"<Anonymous Class>\";\n  }\n  options.truncate -= name.length;\n  return `${name}${inspectObject(value, options)}`;\n}\n__name(inspectClass, \"inspectClass\");\nfunction inspectArguments(args, options) {\n  if (args.length === 0)\n    return \"Arguments[]\";\n  options.truncate -= 13;\n  return `Arguments[ ${inspectList(args, options)} ]`;\n}\n__name(inspectArguments, \"inspectArguments\");\nvar errorKeys = [\n  \"stack\",\n  \"line\",\n  \"column\",\n  \"name\",\n  \"message\",\n  \"fileName\",\n  \"lineNumber\",\n  \"columnNumber\",\n  \"number\",\n  \"description\",\n  \"cause\"\n];\nfunction inspectObject2(error, options) {\n  const properties = Object.getOwnPropertyNames(error).filter((key) => errorKeys.indexOf(key) === -1);\n  const name = error.name;\n  options.truncate -= name.length;\n  let message = \"\";\n  if (typeof error.message === \"string\") {\n    message = truncate(error.message, options.truncate);\n  } else {\n    properties.unshift(\"message\");\n  }\n  message = message ? `: ${message}` : \"\";\n  options.truncate -= message.length + 5;\n  options.seen = options.seen || [];\n  if (options.seen.includes(error)) {\n    return \"[Circular]\";\n  }\n  options.seen.push(error);\n  const propertyContents = inspectList(properties.map((key) => [key, error[key]]), options, inspectProperty);\n  return `${name}${message}${propertyContents ? ` { ${propertyContents} }` : \"\"}`;\n}\n__name(inspectObject2, \"inspectObject\");\nfunction inspectAttribute([key, value], options) {\n  options.truncate -= 3;\n  if (!value) {\n    return `${options.stylize(String(key), \"yellow\")}`;\n  }\n  return `${options.stylize(String(key), \"yellow\")}=${options.stylize(`\"${value}\"`, \"string\")}`;\n}\n__name(inspectAttribute, \"inspectAttribute\");\nfunction inspectNodeCollection(collection, options) {\n  return inspectList(collection, options, inspectNode, \"\\n\");\n}\n__name(inspectNodeCollection, \"inspectNodeCollection\");\nfunction inspectNode(node, options) {\n  switch (node.nodeType) {\n    case 1:\n      return inspectHTML(node, options);\n    case 3:\n      return options.inspect(node.data, options);\n    default:\n      return options.inspect(node, options);\n  }\n}\n__name(inspectNode, \"inspectNode\");\nfunction inspectHTML(element, options) {\n  const properties = element.getAttributeNames();\n  const name = element.tagName.toLowerCase();\n  const head = options.stylize(`<${name}`, \"special\");\n  const headClose = options.stylize(`>`, \"special\");\n  const tail = options.stylize(`</${name}>`, \"special\");\n  options.truncate -= name.length * 2 + 5;\n  let propertyContents = \"\";\n  if (properties.length > 0) {\n    propertyContents += \" \";\n    propertyContents += inspectList(properties.map((key) => [key, element.getAttribute(key)]), options, inspectAttribute, \" \");\n  }\n  options.truncate -= propertyContents.length;\n  const truncate2 = options.truncate;\n  let children = inspectNodeCollection(element.children, options);\n  if (children && children.length > truncate2) {\n    children = `${truncator}(${element.children.length})`;\n  }\n  return `${head}${propertyContents}${headClose}${children}${tail}`;\n}\n__name(inspectHTML, \"inspectHTML\");\nvar symbolsSupported = typeof Symbol === \"function\" && typeof Symbol.for === \"function\";\nvar chaiInspect = symbolsSupported ? Symbol.for(\"chai/inspect\") : \"@@chai/inspect\";\nvar nodeInspect = Symbol.for(\"nodejs.util.inspect.custom\");\nvar constructorMap = /* @__PURE__ */ new WeakMap();\nvar stringTagMap = {};\nvar baseTypesMap = {\n  undefined: /* @__PURE__ */ __name((value, options) => options.stylize(\"undefined\", \"undefined\"), \"undefined\"),\n  null: /* @__PURE__ */ __name((value, options) => options.stylize(\"null\", \"null\"), \"null\"),\n  boolean: /* @__PURE__ */ __name((value, options) => options.stylize(String(value), \"boolean\"), \"boolean\"),\n  Boolean: /* @__PURE__ */ __name((value, options) => options.stylize(String(value), \"boolean\"), \"Boolean\"),\n  number: inspectNumber,\n  Number: inspectNumber,\n  bigint: inspectBigInt,\n  BigInt: inspectBigInt,\n  string: inspectString,\n  String: inspectString,\n  function: inspectFunction,\n  Function: inspectFunction,\n  symbol: inspectSymbol,\n  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect\n  Symbol: inspectSymbol,\n  Array: inspectArray,\n  Date: inspectDate,\n  Map: inspectMap,\n  Set: inspectSet,\n  RegExp: inspectRegExp,\n  Promise: promise_default,\n  // WeakSet, WeakMap are totally opaque to us\n  WeakSet: /* @__PURE__ */ __name((value, options) => options.stylize(\"WeakSet{}\", \"special\"), \"WeakSet\"),\n  WeakMap: /* @__PURE__ */ __name((value, options) => options.stylize(\"WeakMap{}\", \"special\"), \"WeakMap\"),\n  Arguments: inspectArguments,\n  Int8Array: inspectTypedArray,\n  Uint8Array: inspectTypedArray,\n  Uint8ClampedArray: inspectTypedArray,\n  Int16Array: inspectTypedArray,\n  Uint16Array: inspectTypedArray,\n  Int32Array: inspectTypedArray,\n  Uint32Array: inspectTypedArray,\n  Float32Array: inspectTypedArray,\n  Float64Array: inspectTypedArray,\n  Generator: /* @__PURE__ */ __name(() => \"\", \"Generator\"),\n  DataView: /* @__PURE__ */ __name(() => \"\", \"DataView\"),\n  ArrayBuffer: /* @__PURE__ */ __name(() => \"\", \"ArrayBuffer\"),\n  Error: inspectObject2,\n  HTMLCollection: inspectNodeCollection,\n  NodeList: inspectNodeCollection\n};\nvar inspectCustom = /* @__PURE__ */ __name((value, options, type, inspectFn) => {\n  if (chaiInspect in value && typeof value[chaiInspect] === \"function\") {\n    return value[chaiInspect](options);\n  }\n  if (nodeInspect in value && typeof value[nodeInspect] === \"function\") {\n    return value[nodeInspect](options.depth, options, inspectFn);\n  }\n  if (\"inspect\" in value && typeof value.inspect === \"function\") {\n    return value.inspect(options.depth, options);\n  }\n  if (\"constructor\" in value && constructorMap.has(value.constructor)) {\n    return constructorMap.get(value.constructor)(value, options);\n  }\n  if (stringTagMap[type]) {\n    return stringTagMap[type](value, options);\n  }\n  return \"\";\n}, \"inspectCustom\");\nvar toString2 = Object.prototype.toString;\nfunction inspect(value, opts = {}) {\n  const options = normaliseOptions(opts, inspect);\n  const { customInspect } = options;\n  let type = value === null ? \"null\" : typeof value;\n  if (type === \"object\") {\n    type = toString2.call(value).slice(8, -1);\n  }\n  if (type in baseTypesMap) {\n    return baseTypesMap[type](value, options);\n  }\n  if (customInspect && value) {\n    const output = inspectCustom(value, options, type, inspect);\n    if (output) {\n      if (typeof output === \"string\")\n        return output;\n      return inspect(output, options);\n    }\n  }\n  const proto = value ? Object.getPrototypeOf(value) : false;\n  if (proto === Object.prototype || proto === null) {\n    return inspectObject(value, options);\n  }\n  if (value && typeof HTMLElement === \"function\" && value instanceof HTMLElement) {\n    return inspectHTML(value, options);\n  }\n  if (\"constructor\" in value) {\n    if (value.constructor !== Object) {\n      return inspectClass(value, options);\n    }\n    return inspectObject(value, options);\n  }\n  if (value === Object(value)) {\n    return inspectObject(value, options);\n  }\n  return options.stylize(String(value), type);\n}\n__name(inspect, \"inspect\");\nvar { AsymmetricMatcher, DOMCollection, DOMElement, Immutable, ReactElement, ReactTestComponent } = plugins;\nvar PLUGINS = [\n  ReactTestComponent,\n  ReactElement,\n  DOMElement,\n  DOMCollection,\n  Immutable,\n  AsymmetricMatcher\n];\nfunction stringify(object, maxDepth = 10, { maxLength, ...options } = {}) {\n  const MAX_LENGTH = maxLength ?? 1e4;\n  let result;\n  try {\n    result = format(object, {\n      maxDepth,\n      escapeString: false,\n      plugins: PLUGINS,\n      ...options\n    });\n  } catch {\n    result = format(object, {\n      callToJSON: false,\n      maxDepth,\n      escapeString: false,\n      plugins: PLUGINS,\n      ...options\n    });\n  }\n  return result.length >= MAX_LENGTH && maxDepth > 1 ? stringify(object, Math.floor(Math.min(maxDepth, Number.MAX_SAFE_INTEGER) / 2), {\n    maxLength,\n    ...options\n  }) : result;\n}\n__name(stringify, \"stringify\");\nvar formatRegExp = /%[sdjifoOc%]/g;\nfunction format2(...args) {\n  if (typeof args[0] !== \"string\") {\n    const objects = [];\n    for (let i2 = 0; i2 < args.length; i2++) {\n      objects.push(inspect2(args[i2], {\n        depth: 0,\n        colors: false\n      }));\n    }\n    return objects.join(\" \");\n  }\n  const len = args.length;\n  let i = 1;\n  const template = args[0];\n  let str = String(template).replace(formatRegExp, (x) => {\n    if (x === \"%%\") {\n      return \"%\";\n    }\n    if (i >= len) {\n      return x;\n    }\n    switch (x) {\n      case \"%s\": {\n        const value = args[i++];\n        if (typeof value === \"bigint\") {\n          return `${value.toString()}n`;\n        }\n        if (typeof value === \"number\" && value === 0 && 1 / value < 0) {\n          return \"-0\";\n        }\n        if (typeof value === \"object\" && value !== null) {\n          if (typeof value.toString === \"function\" && value.toString !== Object.prototype.toString) {\n            return value.toString();\n          }\n          return inspect2(value, {\n            depth: 0,\n            colors: false\n          });\n        }\n        return String(value);\n      }\n      case \"%d\": {\n        const value = args[i++];\n        if (typeof value === \"bigint\") {\n          return `${value.toString()}n`;\n        }\n        return Number(value).toString();\n      }\n      case \"%i\": {\n        const value = args[i++];\n        if (typeof value === \"bigint\") {\n          return `${value.toString()}n`;\n        }\n        return Number.parseInt(String(value)).toString();\n      }\n      case \"%f\":\n        return Number.parseFloat(String(args[i++])).toString();\n      case \"%o\":\n        return inspect2(args[i++], {\n          showHidden: true,\n          showProxy: true\n        });\n      case \"%O\":\n        return inspect2(args[i++]);\n      case \"%c\": {\n        i++;\n        return \"\";\n      }\n      case \"%j\":\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (err) {\n          const m2 = err.message;\n          if (m2.includes(\"circular structure\") || m2.includes(\"cyclic structures\") || m2.includes(\"cyclic object\")) {\n            return \"[Circular]\";\n          }\n          throw err;\n        }\n      default:\n        return x;\n    }\n  });\n  for (let x = args[i]; i < len; x = args[++i]) {\n    if (x === null || typeof x !== \"object\") {\n      str += ` ${x}`;\n    } else {\n      str += ` ${inspect2(x)}`;\n    }\n  }\n  return str;\n}\n__name(format2, \"format\");\nfunction inspect2(obj, options = {}) {\n  if (options.truncate === 0) {\n    options.truncate = Number.POSITIVE_INFINITY;\n  }\n  return inspect(obj, options);\n}\n__name(inspect2, \"inspect\");\nfunction getDefaultExportFromCjs2(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\n__name(getDefaultExportFromCjs2, \"getDefaultExportFromCjs\");\nfunction assertTypes(value, name, types) {\n  const receivedType = typeof value;\n  const pass = types.includes(receivedType);\n  if (!pass) {\n    throw new TypeError(`${name} value must be ${types.join(\" or \")}, received \"${receivedType}\"`);\n  }\n}\n__name(assertTypes, \"assertTypes\");\nfunction isObject(item) {\n  return item != null && typeof item === \"object\" && !Array.isArray(item);\n}\n__name(isObject, \"isObject\");\nfunction isFinalObj(obj) {\n  return obj === Object.prototype || obj === Function.prototype || obj === RegExp.prototype;\n}\n__name(isFinalObj, \"isFinalObj\");\nfunction getType2(value) {\n  return Object.prototype.toString.apply(value).slice(8, -1);\n}\n__name(getType2, \"getType\");\nfunction collectOwnProperties(obj, collector) {\n  const collect = typeof collector === \"function\" ? collector : (key) => collector.add(key);\n  Object.getOwnPropertyNames(obj).forEach(collect);\n  Object.getOwnPropertySymbols(obj).forEach(collect);\n}\n__name(collectOwnProperties, \"collectOwnProperties\");\nfunction getOwnProperties(obj) {\n  const ownProps = /* @__PURE__ */ new Set();\n  if (isFinalObj(obj)) {\n    return [];\n  }\n  collectOwnProperties(obj, ownProps);\n  return Array.from(ownProps);\n}\n__name(getOwnProperties, \"getOwnProperties\");\nvar defaultCloneOptions = { forceWritable: false };\nfunction deepClone(val, options = defaultCloneOptions) {\n  const seen = /* @__PURE__ */ new WeakMap();\n  return clone(val, seen, options);\n}\n__name(deepClone, \"deepClone\");\nfunction clone(val, seen, options = defaultCloneOptions) {\n  let k, out;\n  if (seen.has(val)) {\n    return seen.get(val);\n  }\n  if (Array.isArray(val)) {\n    out = Array.from({ length: k = val.length });\n    seen.set(val, out);\n    while (k--) {\n      out[k] = clone(val[k], seen, options);\n    }\n    return out;\n  }\n  if (Object.prototype.toString.call(val) === \"[object Object]\") {\n    out = Object.create(Object.getPrototypeOf(val));\n    seen.set(val, out);\n    const props = getOwnProperties(val);\n    for (const k2 of props) {\n      const descriptor = Object.getOwnPropertyDescriptor(val, k2);\n      if (!descriptor) {\n        continue;\n      }\n      const cloned = clone(val[k2], seen, options);\n      if (options.forceWritable) {\n        Object.defineProperty(out, k2, {\n          enumerable: descriptor.enumerable,\n          configurable: true,\n          writable: true,\n          value: cloned\n        });\n      } else if (\"get\" in descriptor) {\n        Object.defineProperty(out, k2, {\n          ...descriptor,\n          get() {\n            return cloned;\n          }\n        });\n      } else {\n        Object.defineProperty(out, k2, {\n          ...descriptor,\n          value: cloned\n        });\n      }\n    }\n    return out;\n  }\n  return val;\n}\n__name(clone, \"clone\");\nfunction noop() {\n}\n__name(noop, \"noop\");\nvar DIFF_DELETE = -1;\nvar DIFF_INSERT = 1;\nvar DIFF_EQUAL = 0;\nvar _Diff = class _Diff2 {\n  0;\n  1;\n  constructor(op, text) {\n    this[0] = op;\n    this[1] = text;\n  }\n};\n__name(_Diff, \"Diff\");\nvar Diff = _Diff;\nfunction diff_commonPrefix(text1, text2) {\n  if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {\n    return 0;\n  }\n  let pointermin = 0;\n  let pointermax = Math.min(text1.length, text2.length);\n  let pointermid = pointermax;\n  let pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid)) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n}\n__name(diff_commonPrefix, \"diff_commonPrefix\");\nfunction diff_commonSuffix(text1, text2) {\n  if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1)) {\n    return 0;\n  }\n  let pointermin = 0;\n  let pointermax = Math.min(text1.length, text2.length);\n  let pointermid = pointermax;\n  let pointerend = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n}\n__name(diff_commonSuffix, \"diff_commonSuffix\");\nfunction diff_commonOverlap_(text1, text2) {\n  const text1_length = text1.length;\n  const text2_length = text2.length;\n  if (text1_length === 0 || text2_length === 0) {\n    return 0;\n  }\n  if (text1_length > text2_length) {\n    text1 = text1.substring(text1_length - text2_length);\n  } else if (text1_length < text2_length) {\n    text2 = text2.substring(0, text1_length);\n  }\n  const text_length = Math.min(text1_length, text2_length);\n  if (text1 === text2) {\n    return text_length;\n  }\n  let best = 0;\n  let length = 1;\n  while (true) {\n    const pattern = text1.substring(text_length - length);\n    const found = text2.indexOf(pattern);\n    if (found === -1) {\n      return best;\n    }\n    length += found;\n    if (found === 0 || text1.substring(text_length - length) === text2.substring(0, length)) {\n      best = length;\n      length++;\n    }\n  }\n}\n__name(diff_commonOverlap_, \"diff_commonOverlap_\");\nfunction diff_cleanupSemantic(diffs) {\n  let changes = false;\n  const equalities = [];\n  let equalitiesLength = 0;\n  let lastEquality = null;\n  let pointer = 0;\n  let length_insertions1 = 0;\n  let length_deletions1 = 0;\n  let length_insertions2 = 0;\n  let length_deletions2 = 0;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] === DIFF_EQUAL) {\n      equalities[equalitiesLength++] = pointer;\n      length_insertions1 = length_insertions2;\n      length_deletions1 = length_deletions2;\n      length_insertions2 = 0;\n      length_deletions2 = 0;\n      lastEquality = diffs[pointer][1];\n    } else {\n      if (diffs[pointer][0] === DIFF_INSERT) {\n        length_insertions2 += diffs[pointer][1].length;\n      } else {\n        length_deletions2 += diffs[pointer][1].length;\n      }\n      if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2)) {\n        diffs.splice(equalities[equalitiesLength - 1], 0, new Diff(DIFF_DELETE, lastEquality));\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        equalitiesLength--;\n        equalitiesLength--;\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n        length_insertions1 = 0;\n        length_deletions1 = 0;\n        length_insertions2 = 0;\n        length_deletions2 = 0;\n        lastEquality = null;\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  if (changes) {\n    diff_cleanupMerge(diffs);\n  }\n  diff_cleanupSemanticLossless(diffs);\n  pointer = 1;\n  while (pointer < diffs.length) {\n    if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {\n      const deletion = diffs[pointer - 1][1];\n      const insertion = diffs[pointer][1];\n      const overlap_length1 = diff_commonOverlap_(deletion, insertion);\n      const overlap_length2 = diff_commonOverlap_(insertion, deletion);\n      if (overlap_length1 >= overlap_length2) {\n        if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {\n          diffs.splice(pointer, 0, new Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1)));\n          diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\n          pointer++;\n        }\n      } else {\n        if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {\n          diffs.splice(pointer, 0, new Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2)));\n          diffs[pointer - 1][0] = DIFF_INSERT;\n          diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);\n          diffs[pointer + 1][0] = DIFF_DELETE;\n          diffs[pointer + 1][1] = deletion.substring(overlap_length2);\n          pointer++;\n        }\n      }\n      pointer++;\n    }\n    pointer++;\n  }\n}\n__name(diff_cleanupSemantic, \"diff_cleanupSemantic\");\nvar nonAlphaNumericRegex_ = /[^a-z0-9]/i;\nvar whitespaceRegex_ = /\\s/;\nvar linebreakRegex_ = /[\\r\\n]/;\nvar blanklineEndRegex_ = /\\n\\r?\\n$/;\nvar blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\nfunction diff_cleanupSemanticLossless(diffs) {\n  let pointer = 1;\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n      let equality1 = diffs[pointer - 1][1];\n      let edit = diffs[pointer][1];\n      let equality2 = diffs[pointer + 1][1];\n      const commonOffset = diff_commonSuffix(equality1, edit);\n      if (commonOffset) {\n        const commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\n        equality2 = commonString + equality2;\n      }\n      let bestEquality1 = equality1;\n      let bestEdit = edit;\n      let bestEquality2 = equality2;\n      let bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);\n      while (edit.charAt(0) === equality2.charAt(0)) {\n        equality1 += edit.charAt(0);\n        edit = edit.substring(1) + equality2.charAt(0);\n        equality2 = equality2.substring(1);\n        const score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);\n        if (score >= bestScore) {\n          bestScore = score;\n          bestEquality1 = equality1;\n          bestEdit = edit;\n          bestEquality2 = equality2;\n        }\n      }\n      if (diffs[pointer - 1][1] !== bestEquality1) {\n        if (bestEquality1) {\n          diffs[pointer - 1][1] = bestEquality1;\n        } else {\n          diffs.splice(pointer - 1, 1);\n          pointer--;\n        }\n        diffs[pointer][1] = bestEdit;\n        if (bestEquality2) {\n          diffs[pointer + 1][1] = bestEquality2;\n        } else {\n          diffs.splice(pointer + 1, 1);\n          pointer--;\n        }\n      }\n    }\n    pointer++;\n  }\n}\n__name(diff_cleanupSemanticLossless, \"diff_cleanupSemanticLossless\");\nfunction diff_cleanupMerge(diffs) {\n  diffs.push(new Diff(DIFF_EQUAL, \"\"));\n  let pointer = 0;\n  let count_delete = 0;\n  let count_insert = 0;\n  let text_delete = \"\";\n  let text_insert = \"\";\n  let commonlength;\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        if (count_delete + count_insert > 1) {\n          if (count_delete !== 0 && count_insert !== 0) {\n            commonlength = diff_commonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] === DIFF_EQUAL) {\n                diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(0, 0, new Diff(DIFF_EQUAL, text_insert.substring(0, commonlength)));\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            }\n            commonlength = diff_commonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];\n              text_insert = text_insert.substring(0, text_insert.length - commonlength);\n              text_delete = text_delete.substring(0, text_delete.length - commonlength);\n            }\n          }\n          pointer -= count_delete + count_insert;\n          diffs.splice(pointer, count_delete + count_insert);\n          if (text_delete.length) {\n            diffs.splice(pointer, 0, new Diff(DIFF_DELETE, text_delete));\n            pointer++;\n          }\n          if (text_insert.length) {\n            diffs.splice(pointer, 0, new Diff(DIFF_INSERT, text_insert));\n            pointer++;\n          }\n          pointer++;\n        } else if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = \"\";\n        text_insert = \"\";\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === \"\") {\n    diffs.pop();\n  }\n  let changes = false;\n  pointer = 1;\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n      if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {\n        diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1]) {\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  if (changes) {\n    diff_cleanupMerge(diffs);\n  }\n}\n__name(diff_cleanupMerge, \"diff_cleanupMerge\");\nfunction diff_cleanupSemanticScore_(one, two) {\n  if (!one || !two) {\n    return 6;\n  }\n  const char1 = one.charAt(one.length - 1);\n  const char2 = two.charAt(0);\n  const nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);\n  const nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);\n  const whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);\n  const whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);\n  const lineBreak1 = whitespace1 && char1.match(linebreakRegex_);\n  const lineBreak2 = whitespace2 && char2.match(linebreakRegex_);\n  const blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);\n  const blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);\n  if (blankLine1 || blankLine2) {\n    return 5;\n  } else if (lineBreak1 || lineBreak2) {\n    return 4;\n  } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n    return 3;\n  } else if (whitespace1 || whitespace2) {\n    return 2;\n  } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n    return 1;\n  }\n  return 0;\n}\n__name(diff_cleanupSemanticScore_, \"diff_cleanupSemanticScore_\");\nvar NO_DIFF_MESSAGE = \"Compared values have no visual difference.\";\nvar SIMILAR_MESSAGE = \"Compared values serialize to the same structure.\\nPrinting internal object structure without calling `toJSON` instead.\";\nvar build = {};\nvar hasRequiredBuild;\nfunction requireBuild() {\n  if (hasRequiredBuild) return build;\n  hasRequiredBuild = 1;\n  Object.defineProperty(build, \"__esModule\", {\n    value: true\n  });\n  build.default = diffSequence;\n  const pkg = \"diff-sequences\";\n  const NOT_YET_SET = 0;\n  const countCommonItemsF = /* @__PURE__ */ __name((aIndex, aEnd, bIndex, bEnd, isCommon) => {\n    let nCommon = 0;\n    while (aIndex < aEnd && bIndex < bEnd && isCommon(aIndex, bIndex)) {\n      aIndex += 1;\n      bIndex += 1;\n      nCommon += 1;\n    }\n    return nCommon;\n  }, \"countCommonItemsF\");\n  const countCommonItemsR = /* @__PURE__ */ __name((aStart, aIndex, bStart, bIndex, isCommon) => {\n    let nCommon = 0;\n    while (aStart <= aIndex && bStart <= bIndex && isCommon(aIndex, bIndex)) {\n      aIndex -= 1;\n      bIndex -= 1;\n      nCommon += 1;\n    }\n    return nCommon;\n  }, \"countCommonItemsR\");\n  const extendPathsF = /* @__PURE__ */ __name((d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF) => {\n    let iF = 0;\n    let kF = -d;\n    let aFirst = aIndexesF[iF];\n    let aIndexPrev1 = aFirst;\n    aIndexesF[iF] += countCommonItemsF(\n      aFirst + 1,\n      aEnd,\n      bF + aFirst - kF + 1,\n      bEnd,\n      isCommon\n    );\n    const nF = d < iMaxF ? d : iMaxF;\n    for (iF += 1, kF += 2; iF <= nF; iF += 1, kF += 2) {\n      if (iF !== d && aIndexPrev1 < aIndexesF[iF]) {\n        aFirst = aIndexesF[iF];\n      } else {\n        aFirst = aIndexPrev1 + 1;\n        if (aEnd <= aFirst) {\n          return iF - 1;\n        }\n      }\n      aIndexPrev1 = aIndexesF[iF];\n      aIndexesF[iF] = aFirst + countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);\n    }\n    return iMaxF;\n  }, \"extendPathsF\");\n  const extendPathsR = /* @__PURE__ */ __name((d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR) => {\n    let iR = 0;\n    let kR = d;\n    let aFirst = aIndexesR[iR];\n    let aIndexPrev1 = aFirst;\n    aIndexesR[iR] -= countCommonItemsR(\n      aStart,\n      aFirst - 1,\n      bStart,\n      bR + aFirst - kR - 1,\n      isCommon\n    );\n    const nR = d < iMaxR ? d : iMaxR;\n    for (iR += 1, kR -= 2; iR <= nR; iR += 1, kR -= 2) {\n      if (iR !== d && aIndexesR[iR] < aIndexPrev1) {\n        aFirst = aIndexesR[iR];\n      } else {\n        aFirst = aIndexPrev1 - 1;\n        if (aFirst < aStart) {\n          return iR - 1;\n        }\n      }\n      aIndexPrev1 = aIndexesR[iR];\n      aIndexesR[iR] = aFirst - countCommonItemsR(\n        aStart,\n        aFirst - 1,\n        bStart,\n        bR + aFirst - kR - 1,\n        isCommon\n      );\n    }\n    return iMaxR;\n  }, \"extendPathsR\");\n  const extendOverlappablePathsF = /* @__PURE__ */ __name((d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {\n    const bF = bStart - aStart;\n    const aLength = aEnd - aStart;\n    const bLength = bEnd - bStart;\n    const baDeltaLength = bLength - aLength;\n    const kMinOverlapF = -baDeltaLength - (d - 1);\n    const kMaxOverlapF = -baDeltaLength + (d - 1);\n    let aIndexPrev1 = NOT_YET_SET;\n    const nF = d < iMaxF ? d : iMaxF;\n    for (let iF = 0, kF = -d; iF <= nF; iF += 1, kF += 2) {\n      const insert = iF === 0 || iF !== d && aIndexPrev1 < aIndexesF[iF];\n      const aLastPrev = insert ? aIndexesF[iF] : aIndexPrev1;\n      const aFirst = insert ? aLastPrev : aLastPrev + 1;\n      const bFirst = bF + aFirst - kF;\n      const nCommonF = countCommonItemsF(\n        aFirst + 1,\n        aEnd,\n        bFirst + 1,\n        bEnd,\n        isCommon\n      );\n      const aLast = aFirst + nCommonF;\n      aIndexPrev1 = aIndexesF[iF];\n      aIndexesF[iF] = aLast;\n      if (kMinOverlapF <= kF && kF <= kMaxOverlapF) {\n        const iR = (d - 1 - (kF + baDeltaLength)) / 2;\n        if (iR <= iMaxR && aIndexesR[iR] - 1 <= aLast) {\n          const bLastPrev = bF + aLastPrev - (insert ? kF + 1 : kF - 1);\n          const nCommonR = countCommonItemsR(\n            aStart,\n            aLastPrev,\n            bStart,\n            bLastPrev,\n            isCommon\n          );\n          const aIndexPrevFirst = aLastPrev - nCommonR;\n          const bIndexPrevFirst = bLastPrev - nCommonR;\n          const aEndPreceding = aIndexPrevFirst + 1;\n          const bEndPreceding = bIndexPrevFirst + 1;\n          division.nChangePreceding = d - 1;\n          if (d - 1 === aEndPreceding + bEndPreceding - aStart - bStart) {\n            division.aEndPreceding = aStart;\n            division.bEndPreceding = bStart;\n          } else {\n            division.aEndPreceding = aEndPreceding;\n            division.bEndPreceding = bEndPreceding;\n          }\n          division.nCommonPreceding = nCommonR;\n          if (nCommonR !== 0) {\n            division.aCommonPreceding = aEndPreceding;\n            division.bCommonPreceding = bEndPreceding;\n          }\n          division.nCommonFollowing = nCommonF;\n          if (nCommonF !== 0) {\n            division.aCommonFollowing = aFirst + 1;\n            division.bCommonFollowing = bFirst + 1;\n          }\n          const aStartFollowing = aLast + 1;\n          const bStartFollowing = bFirst + nCommonF + 1;\n          division.nChangeFollowing = d - 1;\n          if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {\n            division.aStartFollowing = aEnd;\n            division.bStartFollowing = bEnd;\n          } else {\n            division.aStartFollowing = aStartFollowing;\n            division.bStartFollowing = bStartFollowing;\n          }\n          return true;\n        }\n      }\n    }\n    return false;\n  }, \"extendOverlappablePathsF\");\n  const extendOverlappablePathsR = /* @__PURE__ */ __name((d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {\n    const bR = bEnd - aEnd;\n    const aLength = aEnd - aStart;\n    const bLength = bEnd - bStart;\n    const baDeltaLength = bLength - aLength;\n    const kMinOverlapR = baDeltaLength - d;\n    const kMaxOverlapR = baDeltaLength + d;\n    let aIndexPrev1 = NOT_YET_SET;\n    const nR = d < iMaxR ? d : iMaxR;\n    for (let iR = 0, kR = d; iR <= nR; iR += 1, kR -= 2) {\n      const insert = iR === 0 || iR !== d && aIndexesR[iR] < aIndexPrev1;\n      const aLastPrev = insert ? aIndexesR[iR] : aIndexPrev1;\n      const aFirst = insert ? aLastPrev : aLastPrev - 1;\n      const bFirst = bR + aFirst - kR;\n      const nCommonR = countCommonItemsR(\n        aStart,\n        aFirst - 1,\n        bStart,\n        bFirst - 1,\n        isCommon\n      );\n      const aLast = aFirst - nCommonR;\n      aIndexPrev1 = aIndexesR[iR];\n      aIndexesR[iR] = aLast;\n      if (kMinOverlapR <= kR && kR <= kMaxOverlapR) {\n        const iF = (d + (kR - baDeltaLength)) / 2;\n        if (iF <= iMaxF && aLast - 1 <= aIndexesF[iF]) {\n          const bLast = bFirst - nCommonR;\n          division.nChangePreceding = d;\n          if (d === aLast + bLast - aStart - bStart) {\n            division.aEndPreceding = aStart;\n            division.bEndPreceding = bStart;\n          } else {\n            division.aEndPreceding = aLast;\n            division.bEndPreceding = bLast;\n          }\n          division.nCommonPreceding = nCommonR;\n          if (nCommonR !== 0) {\n            division.aCommonPreceding = aLast;\n            division.bCommonPreceding = bLast;\n          }\n          division.nChangeFollowing = d - 1;\n          if (d === 1) {\n            division.nCommonFollowing = 0;\n            division.aStartFollowing = aEnd;\n            division.bStartFollowing = bEnd;\n          } else {\n            const bLastPrev = bR + aLastPrev - (insert ? kR - 1 : kR + 1);\n            const nCommonF = countCommonItemsF(\n              aLastPrev,\n              aEnd,\n              bLastPrev,\n              bEnd,\n              isCommon\n            );\n            division.nCommonFollowing = nCommonF;\n            if (nCommonF !== 0) {\n              division.aCommonFollowing = aLastPrev;\n              division.bCommonFollowing = bLastPrev;\n            }\n            const aStartFollowing = aLastPrev + nCommonF;\n            const bStartFollowing = bLastPrev + nCommonF;\n            if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {\n              division.aStartFollowing = aEnd;\n              division.bStartFollowing = bEnd;\n            } else {\n              division.aStartFollowing = aStartFollowing;\n              division.bStartFollowing = bStartFollowing;\n            }\n          }\n          return true;\n        }\n      }\n    }\n    return false;\n  }, \"extendOverlappablePathsR\");\n  const divide = /* @__PURE__ */ __name((nChange, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, aIndexesR, division) => {\n    const bF = bStart - aStart;\n    const bR = bEnd - aEnd;\n    const aLength = aEnd - aStart;\n    const bLength = bEnd - bStart;\n    const baDeltaLength = bLength - aLength;\n    let iMaxF = aLength;\n    let iMaxR = aLength;\n    aIndexesF[0] = aStart - 1;\n    aIndexesR[0] = aEnd;\n    if (baDeltaLength % 2 === 0) {\n      const dMin = (nChange || baDeltaLength) / 2;\n      const dMax = (aLength + bLength) / 2;\n      for (let d = 1; d <= dMax; d += 1) {\n        iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n        if (d < dMin) {\n          iMaxR = extendPathsR(d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);\n        } else if (\n          // If a reverse path overlaps a forward path in the same diagonal,\n          // return a division of the index intervals at the middle change.\n          extendOverlappablePathsR(\n            d,\n            aStart,\n            aEnd,\n            bStart,\n            bEnd,\n            isCommon,\n            aIndexesF,\n            iMaxF,\n            aIndexesR,\n            iMaxR,\n            division\n          )\n        ) {\n          return;\n        }\n      }\n    } else {\n      const dMin = ((nChange || baDeltaLength) + 1) / 2;\n      const dMax = (aLength + bLength + 1) / 2;\n      let d = 1;\n      iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n      for (d += 1; d <= dMax; d += 1) {\n        iMaxR = extendPathsR(\n          d - 1,\n          aStart,\n          bStart,\n          bR,\n          isCommon,\n          aIndexesR,\n          iMaxR\n        );\n        if (d < dMin) {\n          iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n        } else if (\n          // If a forward path overlaps a reverse path in the same diagonal,\n          // return a division of the index intervals at the middle change.\n          extendOverlappablePathsF(\n            d,\n            aStart,\n            aEnd,\n            bStart,\n            bEnd,\n            isCommon,\n            aIndexesF,\n            iMaxF,\n            aIndexesR,\n            iMaxR,\n            division\n          )\n        ) {\n          return;\n        }\n      }\n    }\n    throw new Error(\n      `${pkg}: no overlap aStart=${aStart} aEnd=${aEnd} bStart=${bStart} bEnd=${bEnd}`\n    );\n  }, \"divide\");\n  const findSubsequences = /* @__PURE__ */ __name((nChange, aStart, aEnd, bStart, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division) => {\n    if (bEnd - bStart < aEnd - aStart) {\n      transposed = !transposed;\n      if (transposed && callbacks.length === 1) {\n        const { foundSubsequence: foundSubsequence2, isCommon: isCommon2 } = callbacks[0];\n        callbacks[1] = {\n          foundSubsequence: /* @__PURE__ */ __name((nCommon, bCommon, aCommon) => {\n            foundSubsequence2(nCommon, aCommon, bCommon);\n          }, \"foundSubsequence\"),\n          isCommon: /* @__PURE__ */ __name((bIndex, aIndex) => isCommon2(aIndex, bIndex), \"isCommon\")\n        };\n      }\n      const tStart = aStart;\n      const tEnd = aEnd;\n      aStart = bStart;\n      aEnd = bEnd;\n      bStart = tStart;\n      bEnd = tEnd;\n    }\n    const { foundSubsequence, isCommon } = callbacks[transposed ? 1 : 0];\n    divide(\n      nChange,\n      aStart,\n      aEnd,\n      bStart,\n      bEnd,\n      isCommon,\n      aIndexesF,\n      aIndexesR,\n      division\n    );\n    const {\n      nChangePreceding,\n      aEndPreceding,\n      bEndPreceding,\n      nCommonPreceding,\n      aCommonPreceding,\n      bCommonPreceding,\n      nCommonFollowing,\n      aCommonFollowing,\n      bCommonFollowing,\n      nChangeFollowing,\n      aStartFollowing,\n      bStartFollowing\n    } = division;\n    if (aStart < aEndPreceding && bStart < bEndPreceding) {\n      findSubsequences(\n        nChangePreceding,\n        aStart,\n        aEndPreceding,\n        bStart,\n        bEndPreceding,\n        transposed,\n        callbacks,\n        aIndexesF,\n        aIndexesR,\n        division\n      );\n    }\n    if (nCommonPreceding !== 0) {\n      foundSubsequence(nCommonPreceding, aCommonPreceding, bCommonPreceding);\n    }\n    if (nCommonFollowing !== 0) {\n      foundSubsequence(nCommonFollowing, aCommonFollowing, bCommonFollowing);\n    }\n    if (aStartFollowing < aEnd && bStartFollowing < bEnd) {\n      findSubsequences(\n        nChangeFollowing,\n        aStartFollowing,\n        aEnd,\n        bStartFollowing,\n        bEnd,\n        transposed,\n        callbacks,\n        aIndexesF,\n        aIndexesR,\n        division\n      );\n    }\n  }, \"findSubsequences\");\n  const validateLength = /* @__PURE__ */ __name((name, arg) => {\n    if (typeof arg !== \"number\") {\n      throw new TypeError(`${pkg}: ${name} typeof ${typeof arg} is not a number`);\n    }\n    if (!Number.isSafeInteger(arg)) {\n      throw new RangeError(`${pkg}: ${name} value ${arg} is not a safe integer`);\n    }\n    if (arg < 0) {\n      throw new RangeError(`${pkg}: ${name} value ${arg} is a negative integer`);\n    }\n  }, \"validateLength\");\n  const validateCallback = /* @__PURE__ */ __name((name, arg) => {\n    const type = typeof arg;\n    if (type !== \"function\") {\n      throw new TypeError(`${pkg}: ${name} typeof ${type} is not a function`);\n    }\n  }, \"validateCallback\");\n  function diffSequence(aLength, bLength, isCommon, foundSubsequence) {\n    validateLength(\"aLength\", aLength);\n    validateLength(\"bLength\", bLength);\n    validateCallback(\"isCommon\", isCommon);\n    validateCallback(\"foundSubsequence\", foundSubsequence);\n    const nCommonF = countCommonItemsF(0, aLength, 0, bLength, isCommon);\n    if (nCommonF !== 0) {\n      foundSubsequence(nCommonF, 0, 0);\n    }\n    if (aLength !== nCommonF || bLength !== nCommonF) {\n      const aStart = nCommonF;\n      const bStart = nCommonF;\n      const nCommonR = countCommonItemsR(\n        aStart,\n        aLength - 1,\n        bStart,\n        bLength - 1,\n        isCommon\n      );\n      const aEnd = aLength - nCommonR;\n      const bEnd = bLength - nCommonR;\n      const nCommonFR = nCommonF + nCommonR;\n      if (aLength !== nCommonFR && bLength !== nCommonFR) {\n        const nChange = 0;\n        const transposed = false;\n        const callbacks = [\n          {\n            foundSubsequence,\n            isCommon\n          }\n        ];\n        const aIndexesF = [NOT_YET_SET];\n        const aIndexesR = [NOT_YET_SET];\n        const division = {\n          aCommonFollowing: NOT_YET_SET,\n          aCommonPreceding: NOT_YET_SET,\n          aEndPreceding: NOT_YET_SET,\n          aStartFollowing: NOT_YET_SET,\n          bCommonFollowing: NOT_YET_SET,\n          bCommonPreceding: NOT_YET_SET,\n          bEndPreceding: NOT_YET_SET,\n          bStartFollowing: NOT_YET_SET,\n          nChangeFollowing: NOT_YET_SET,\n          nChangePreceding: NOT_YET_SET,\n          nCommonFollowing: NOT_YET_SET,\n          nCommonPreceding: NOT_YET_SET\n        };\n        findSubsequences(\n          nChange,\n          aStart,\n          aEnd,\n          bStart,\n          bEnd,\n          transposed,\n          callbacks,\n          aIndexesF,\n          aIndexesR,\n          division\n        );\n      }\n      if (nCommonR !== 0) {\n        foundSubsequence(nCommonR, aEnd, bEnd);\n      }\n    }\n  }\n  __name(diffSequence, \"diffSequence\");\n  return build;\n}\n__name(requireBuild, \"requireBuild\");\nvar buildExports = requireBuild();\nvar diffSequences = getDefaultExportFromCjs2(buildExports);\nfunction formatTrailingSpaces(line, trailingSpaceFormatter) {\n  return line.replace(/\\s+$/, (match) => trailingSpaceFormatter(match));\n}\n__name(formatTrailingSpaces, \"formatTrailingSpaces\");\nfunction printDiffLine(line, isFirstOrLast, color, indicator, trailingSpaceFormatter, emptyFirstOrLastLinePlaceholder) {\n  return line.length !== 0 ? color(`${indicator} ${formatTrailingSpaces(line, trailingSpaceFormatter)}`) : indicator !== \" \" ? color(indicator) : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0 ? color(`${indicator} ${emptyFirstOrLastLinePlaceholder}`) : \"\";\n}\n__name(printDiffLine, \"printDiffLine\");\nfunction printDeleteLine(line, isFirstOrLast, { aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {\n  return printDiffLine(line, isFirstOrLast, aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);\n}\n__name(printDeleteLine, \"printDeleteLine\");\nfunction printInsertLine(line, isFirstOrLast, { bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {\n  return printDiffLine(line, isFirstOrLast, bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);\n}\n__name(printInsertLine, \"printInsertLine\");\nfunction printCommonLine(line, isFirstOrLast, { commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {\n  return printDiffLine(line, isFirstOrLast, commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);\n}\n__name(printCommonLine, \"printCommonLine\");\nfunction createPatchMark(aStart, aEnd, bStart, bEnd, { patchColor }) {\n  return patchColor(`@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`);\n}\n__name(createPatchMark, \"createPatchMark\");\nfunction joinAlignedDiffsNoExpand(diffs, options) {\n  const iLength = diffs.length;\n  const nContextLines = options.contextLines;\n  const nContextLines2 = nContextLines + nContextLines;\n  let jLength = iLength;\n  let hasExcessAtStartOrEnd = false;\n  let nExcessesBetweenChanges = 0;\n  let i = 0;\n  while (i !== iLength) {\n    const iStart = i;\n    while (i !== iLength && diffs[i][0] === DIFF_EQUAL) {\n      i += 1;\n    }\n    if (iStart !== i) {\n      if (iStart === 0) {\n        if (i > nContextLines) {\n          jLength -= i - nContextLines;\n          hasExcessAtStartOrEnd = true;\n        }\n      } else if (i === iLength) {\n        const n = i - iStart;\n        if (n > nContextLines) {\n          jLength -= n - nContextLines;\n          hasExcessAtStartOrEnd = true;\n        }\n      } else {\n        const n = i - iStart;\n        if (n > nContextLines2) {\n          jLength -= n - nContextLines2;\n          nExcessesBetweenChanges += 1;\n        }\n      }\n    }\n    while (i !== iLength && diffs[i][0] !== DIFF_EQUAL) {\n      i += 1;\n    }\n  }\n  const hasPatch = nExcessesBetweenChanges !== 0 || hasExcessAtStartOrEnd;\n  if (nExcessesBetweenChanges !== 0) {\n    jLength += nExcessesBetweenChanges + 1;\n  } else if (hasExcessAtStartOrEnd) {\n    jLength += 1;\n  }\n  const jLast = jLength - 1;\n  const lines = [];\n  let jPatchMark = 0;\n  if (hasPatch) {\n    lines.push(\"\");\n  }\n  let aStart = 0;\n  let bStart = 0;\n  let aEnd = 0;\n  let bEnd = 0;\n  const pushCommonLine = /* @__PURE__ */ __name((line) => {\n    const j = lines.length;\n    lines.push(printCommonLine(line, j === 0 || j === jLast, options));\n    aEnd += 1;\n    bEnd += 1;\n  }, \"pushCommonLine\");\n  const pushDeleteLine = /* @__PURE__ */ __name((line) => {\n    const j = lines.length;\n    lines.push(printDeleteLine(line, j === 0 || j === jLast, options));\n    aEnd += 1;\n  }, \"pushDeleteLine\");\n  const pushInsertLine = /* @__PURE__ */ __name((line) => {\n    const j = lines.length;\n    lines.push(printInsertLine(line, j === 0 || j === jLast, options));\n    bEnd += 1;\n  }, \"pushInsertLine\");\n  i = 0;\n  while (i !== iLength) {\n    let iStart = i;\n    while (i !== iLength && diffs[i][0] === DIFF_EQUAL) {\n      i += 1;\n    }\n    if (iStart !== i) {\n      if (iStart === 0) {\n        if (i > nContextLines) {\n          iStart = i - nContextLines;\n          aStart = iStart;\n          bStart = iStart;\n          aEnd = aStart;\n          bEnd = bStart;\n        }\n        for (let iCommon = iStart; iCommon !== i; iCommon += 1) {\n          pushCommonLine(diffs[iCommon][1]);\n        }\n      } else if (i === iLength) {\n        const iEnd = i - iStart > nContextLines ? iStart + nContextLines : i;\n        for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {\n          pushCommonLine(diffs[iCommon][1]);\n        }\n      } else {\n        const nCommon = i - iStart;\n        if (nCommon > nContextLines2) {\n          const iEnd = iStart + nContextLines;\n          for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {\n            pushCommonLine(diffs[iCommon][1]);\n          }\n          lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);\n          jPatchMark = lines.length;\n          lines.push(\"\");\n          const nOmit = nCommon - nContextLines2;\n          aStart = aEnd + nOmit;\n          bStart = bEnd + nOmit;\n          aEnd = aStart;\n          bEnd = bStart;\n          for (let iCommon = i - nContextLines; iCommon !== i; iCommon += 1) {\n            pushCommonLine(diffs[iCommon][1]);\n          }\n        } else {\n          for (let iCommon = iStart; iCommon !== i; iCommon += 1) {\n            pushCommonLine(diffs[iCommon][1]);\n          }\n        }\n      }\n    }\n    while (i !== iLength && diffs[i][0] === DIFF_DELETE) {\n      pushDeleteLine(diffs[i][1]);\n      i += 1;\n    }\n    while (i !== iLength && diffs[i][0] === DIFF_INSERT) {\n      pushInsertLine(diffs[i][1]);\n      i += 1;\n    }\n  }\n  if (hasPatch) {\n    lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);\n  }\n  return lines.join(\"\\n\");\n}\n__name(joinAlignedDiffsNoExpand, \"joinAlignedDiffsNoExpand\");\nfunction joinAlignedDiffsExpand(diffs, options) {\n  return diffs.map((diff2, i, diffs2) => {\n    const line = diff2[1];\n    const isFirstOrLast = i === 0 || i === diffs2.length - 1;\n    switch (diff2[0]) {\n      case DIFF_DELETE:\n        return printDeleteLine(line, isFirstOrLast, options);\n      case DIFF_INSERT:\n        return printInsertLine(line, isFirstOrLast, options);\n      default:\n        return printCommonLine(line, isFirstOrLast, options);\n    }\n  }).join(\"\\n\");\n}\n__name(joinAlignedDiffsExpand, \"joinAlignedDiffsExpand\");\nvar noColor = /* @__PURE__ */ __name((string) => string, \"noColor\");\nvar DIFF_CONTEXT_DEFAULT = 5;\nvar DIFF_TRUNCATE_THRESHOLD_DEFAULT = 0;\nfunction getDefaultOptions() {\n  return {\n    aAnnotation: \"Expected\",\n    aColor: s.green,\n    aIndicator: \"-\",\n    bAnnotation: \"Received\",\n    bColor: s.red,\n    bIndicator: \"+\",\n    changeColor: s.inverse,\n    changeLineTrailingSpaceColor: noColor,\n    commonColor: s.dim,\n    commonIndicator: \" \",\n    commonLineTrailingSpaceColor: noColor,\n    compareKeys: void 0,\n    contextLines: DIFF_CONTEXT_DEFAULT,\n    emptyFirstOrLastLinePlaceholder: \"\",\n    expand: false,\n    includeChangeCounts: false,\n    omitAnnotationLines: false,\n    patchColor: s.yellow,\n    printBasicPrototype: false,\n    truncateThreshold: DIFF_TRUNCATE_THRESHOLD_DEFAULT,\n    truncateAnnotation: \"... Diff result is truncated\",\n    truncateAnnotationColor: noColor\n  };\n}\n__name(getDefaultOptions, \"getDefaultOptions\");\nfunction getCompareKeys(compareKeys) {\n  return compareKeys && typeof compareKeys === \"function\" ? compareKeys : void 0;\n}\n__name(getCompareKeys, \"getCompareKeys\");\nfunction getContextLines(contextLines) {\n  return typeof contextLines === \"number\" && Number.isSafeInteger(contextLines) && contextLines >= 0 ? contextLines : DIFF_CONTEXT_DEFAULT;\n}\n__name(getContextLines, \"getContextLines\");\nfunction normalizeDiffOptions(options = {}) {\n  return {\n    ...getDefaultOptions(),\n    ...options,\n    compareKeys: getCompareKeys(options.compareKeys),\n    contextLines: getContextLines(options.contextLines)\n  };\n}\n__name(normalizeDiffOptions, \"normalizeDiffOptions\");\nfunction isEmptyString(lines) {\n  return lines.length === 1 && lines[0].length === 0;\n}\n__name(isEmptyString, \"isEmptyString\");\nfunction countChanges(diffs) {\n  let a2 = 0;\n  let b = 0;\n  diffs.forEach((diff2) => {\n    switch (diff2[0]) {\n      case DIFF_DELETE:\n        a2 += 1;\n        break;\n      case DIFF_INSERT:\n        b += 1;\n        break;\n    }\n  });\n  return {\n    a: a2,\n    b\n  };\n}\n__name(countChanges, \"countChanges\");\nfunction printAnnotation({ aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator, includeChangeCounts, omitAnnotationLines }, changeCounts) {\n  if (omitAnnotationLines) {\n    return \"\";\n  }\n  let aRest = \"\";\n  let bRest = \"\";\n  if (includeChangeCounts) {\n    const aCount = String(changeCounts.a);\n    const bCount = String(changeCounts.b);\n    const baAnnotationLengthDiff = bAnnotation.length - aAnnotation.length;\n    const aAnnotationPadding = \" \".repeat(Math.max(0, baAnnotationLengthDiff));\n    const bAnnotationPadding = \" \".repeat(Math.max(0, -baAnnotationLengthDiff));\n    const baCountLengthDiff = bCount.length - aCount.length;\n    const aCountPadding = \" \".repeat(Math.max(0, baCountLengthDiff));\n    const bCountPadding = \" \".repeat(Math.max(0, -baCountLengthDiff));\n    aRest = `${aAnnotationPadding}  ${aIndicator} ${aCountPadding}${aCount}`;\n    bRest = `${bAnnotationPadding}  ${bIndicator} ${bCountPadding}${bCount}`;\n  }\n  const a2 = `${aIndicator} ${aAnnotation}${aRest}`;\n  const b = `${bIndicator} ${bAnnotation}${bRest}`;\n  return `${aColor(a2)}\n${bColor(b)}\n\n`;\n}\n__name(printAnnotation, \"printAnnotation\");\nfunction printDiffLines(diffs, truncated, options) {\n  return printAnnotation(options, countChanges(diffs)) + (options.expand ? joinAlignedDiffsExpand(diffs, options) : joinAlignedDiffsNoExpand(diffs, options)) + (truncated ? options.truncateAnnotationColor(`\n${options.truncateAnnotation}`) : \"\");\n}\n__name(printDiffLines, \"printDiffLines\");\nfunction diffLinesUnified(aLines, bLines, options) {\n  const normalizedOptions = normalizeDiffOptions(options);\n  const [diffs, truncated] = diffLinesRaw(isEmptyString(aLines) ? [] : aLines, isEmptyString(bLines) ? [] : bLines, normalizedOptions);\n  return printDiffLines(diffs, truncated, normalizedOptions);\n}\n__name(diffLinesUnified, \"diffLinesUnified\");\nfunction diffLinesUnified2(aLinesDisplay, bLinesDisplay, aLinesCompare, bLinesCompare, options) {\n  if (isEmptyString(aLinesDisplay) && isEmptyString(aLinesCompare)) {\n    aLinesDisplay = [];\n    aLinesCompare = [];\n  }\n  if (isEmptyString(bLinesDisplay) && isEmptyString(bLinesCompare)) {\n    bLinesDisplay = [];\n    bLinesCompare = [];\n  }\n  if (aLinesDisplay.length !== aLinesCompare.length || bLinesDisplay.length !== bLinesCompare.length) {\n    return diffLinesUnified(aLinesDisplay, bLinesDisplay, options);\n  }\n  const [diffs, truncated] = diffLinesRaw(aLinesCompare, bLinesCompare, options);\n  let aIndex = 0;\n  let bIndex = 0;\n  diffs.forEach((diff2) => {\n    switch (diff2[0]) {\n      case DIFF_DELETE:\n        diff2[1] = aLinesDisplay[aIndex];\n        aIndex += 1;\n        break;\n      case DIFF_INSERT:\n        diff2[1] = bLinesDisplay[bIndex];\n        bIndex += 1;\n        break;\n      default:\n        diff2[1] = bLinesDisplay[bIndex];\n        aIndex += 1;\n        bIndex += 1;\n    }\n  });\n  return printDiffLines(diffs, truncated, normalizeDiffOptions(options));\n}\n__name(diffLinesUnified2, \"diffLinesUnified2\");\nfunction diffLinesRaw(aLines, bLines, options) {\n  const truncate2 = (options === null || options === void 0 ? void 0 : options.truncateThreshold) ?? false;\n  const truncateThreshold = Math.max(Math.floor((options === null || options === void 0 ? void 0 : options.truncateThreshold) ?? 0), 0);\n  const aLength = truncate2 ? Math.min(aLines.length, truncateThreshold) : aLines.length;\n  const bLength = truncate2 ? Math.min(bLines.length, truncateThreshold) : bLines.length;\n  const truncated = aLength !== aLines.length || bLength !== bLines.length;\n  const isCommon = /* @__PURE__ */ __name((aIndex2, bIndex2) => aLines[aIndex2] === bLines[bIndex2], \"isCommon\");\n  const diffs = [];\n  let aIndex = 0;\n  let bIndex = 0;\n  const foundSubsequence = /* @__PURE__ */ __name((nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      diffs.push(new Diff(DIFF_EQUAL, bLines[bIndex]));\n    }\n  }, \"foundSubsequence\");\n  diffSequences(aLength, bLength, isCommon, foundSubsequence);\n  for (; aIndex !== aLength; aIndex += 1) {\n    diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));\n  }\n  return [diffs, truncated];\n}\n__name(diffLinesRaw, \"diffLinesRaw\");\nfunction getType3(value) {\n  if (value === void 0) {\n    return \"undefined\";\n  } else if (value === null) {\n    return \"null\";\n  } else if (Array.isArray(value)) {\n    return \"array\";\n  } else if (typeof value === \"boolean\") {\n    return \"boolean\";\n  } else if (typeof value === \"function\") {\n    return \"function\";\n  } else if (typeof value === \"number\") {\n    return \"number\";\n  } else if (typeof value === \"string\") {\n    return \"string\";\n  } else if (typeof value === \"bigint\") {\n    return \"bigint\";\n  } else if (typeof value === \"object\") {\n    if (value != null) {\n      if (value.constructor === RegExp) {\n        return \"regexp\";\n      } else if (value.constructor === Map) {\n        return \"map\";\n      } else if (value.constructor === Set) {\n        return \"set\";\n      } else if (value.constructor === Date) {\n        return \"date\";\n      }\n    }\n    return \"object\";\n  } else if (typeof value === \"symbol\") {\n    return \"symbol\";\n  }\n  throw new Error(`value of unknown type: ${value}`);\n}\n__name(getType3, \"getType\");\nfunction getNewLineSymbol(string) {\n  return string.includes(\"\\r\\n\") ? \"\\r\\n\" : \"\\n\";\n}\n__name(getNewLineSymbol, \"getNewLineSymbol\");\nfunction diffStrings(a2, b, options) {\n  const truncate2 = (options === null || options === void 0 ? void 0 : options.truncateThreshold) ?? false;\n  const truncateThreshold = Math.max(Math.floor((options === null || options === void 0 ? void 0 : options.truncateThreshold) ?? 0), 0);\n  let aLength = a2.length;\n  let bLength = b.length;\n  if (truncate2) {\n    const aMultipleLines = a2.includes(\"\\n\");\n    const bMultipleLines = b.includes(\"\\n\");\n    const aNewLineSymbol = getNewLineSymbol(a2);\n    const bNewLineSymbol = getNewLineSymbol(b);\n    const _a = aMultipleLines ? `${a2.split(aNewLineSymbol, truncateThreshold).join(aNewLineSymbol)}\n` : a2;\n    const _b = bMultipleLines ? `${b.split(bNewLineSymbol, truncateThreshold).join(bNewLineSymbol)}\n` : b;\n    aLength = _a.length;\n    bLength = _b.length;\n  }\n  const truncated = aLength !== a2.length || bLength !== b.length;\n  const isCommon = /* @__PURE__ */ __name((aIndex2, bIndex2) => a2[aIndex2] === b[bIndex2], \"isCommon\");\n  let aIndex = 0;\n  let bIndex = 0;\n  const diffs = [];\n  const foundSubsequence = /* @__PURE__ */ __name((nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      diffs.push(new Diff(DIFF_DELETE, a2.slice(aIndex, aCommon)));\n    }\n    if (bIndex !== bCommon) {\n      diffs.push(new Diff(DIFF_INSERT, b.slice(bIndex, bCommon)));\n    }\n    aIndex = aCommon + nCommon;\n    bIndex = bCommon + nCommon;\n    diffs.push(new Diff(DIFF_EQUAL, b.slice(bCommon, bIndex)));\n  }, \"foundSubsequence\");\n  diffSequences(aLength, bLength, isCommon, foundSubsequence);\n  if (aIndex !== aLength) {\n    diffs.push(new Diff(DIFF_DELETE, a2.slice(aIndex)));\n  }\n  if (bIndex !== bLength) {\n    diffs.push(new Diff(DIFF_INSERT, b.slice(bIndex)));\n  }\n  return [diffs, truncated];\n}\n__name(diffStrings, \"diffStrings\");\nfunction concatenateRelevantDiffs(op, diffs, changeColor) {\n  return diffs.reduce((reduced, diff2) => reduced + (diff2[0] === DIFF_EQUAL ? diff2[1] : diff2[0] === op && diff2[1].length !== 0 ? changeColor(diff2[1]) : \"\"), \"\");\n}\n__name(concatenateRelevantDiffs, \"concatenateRelevantDiffs\");\nvar _ChangeBuffer = class _ChangeBuffer2 {\n  op;\n  line;\n  lines;\n  changeColor;\n  constructor(op, changeColor) {\n    this.op = op;\n    this.line = [];\n    this.lines = [];\n    this.changeColor = changeColor;\n  }\n  pushSubstring(substring) {\n    this.pushDiff(new Diff(this.op, substring));\n  }\n  pushLine() {\n    this.lines.push(this.line.length !== 1 ? new Diff(this.op, concatenateRelevantDiffs(this.op, this.line, this.changeColor)) : this.line[0][0] === this.op ? this.line[0] : new Diff(this.op, this.line[0][1]));\n    this.line.length = 0;\n  }\n  isLineEmpty() {\n    return this.line.length === 0;\n  }\n  // Minor input to buffer.\n  pushDiff(diff2) {\n    this.line.push(diff2);\n  }\n  // Main input to buffer.\n  align(diff2) {\n    const string = diff2[1];\n    if (string.includes(\"\\n\")) {\n      const substrings = string.split(\"\\n\");\n      const iLast = substrings.length - 1;\n      substrings.forEach((substring, i) => {\n        if (i < iLast) {\n          this.pushSubstring(substring);\n          this.pushLine();\n        } else if (substring.length !== 0) {\n          this.pushSubstring(substring);\n        }\n      });\n    } else {\n      this.pushDiff(diff2);\n    }\n  }\n  // Output from buffer.\n  moveLinesTo(lines) {\n    if (!this.isLineEmpty()) {\n      this.pushLine();\n    }\n    lines.push(...this.lines);\n    this.lines.length = 0;\n  }\n};\n__name(_ChangeBuffer, \"ChangeBuffer\");\nvar ChangeBuffer = _ChangeBuffer;\nvar _CommonBuffer = class _CommonBuffer2 {\n  deleteBuffer;\n  insertBuffer;\n  lines;\n  constructor(deleteBuffer, insertBuffer) {\n    this.deleteBuffer = deleteBuffer;\n    this.insertBuffer = insertBuffer;\n    this.lines = [];\n  }\n  pushDiffCommonLine(diff2) {\n    this.lines.push(diff2);\n  }\n  pushDiffChangeLines(diff2) {\n    const isDiffEmpty = diff2[1].length === 0;\n    if (!isDiffEmpty || this.deleteBuffer.isLineEmpty()) {\n      this.deleteBuffer.pushDiff(diff2);\n    }\n    if (!isDiffEmpty || this.insertBuffer.isLineEmpty()) {\n      this.insertBuffer.pushDiff(diff2);\n    }\n  }\n  flushChangeLines() {\n    this.deleteBuffer.moveLinesTo(this.lines);\n    this.insertBuffer.moveLinesTo(this.lines);\n  }\n  // Input to buffer.\n  align(diff2) {\n    const op = diff2[0];\n    const string = diff2[1];\n    if (string.includes(\"\\n\")) {\n      const substrings = string.split(\"\\n\");\n      const iLast = substrings.length - 1;\n      substrings.forEach((substring, i) => {\n        if (i === 0) {\n          const subdiff = new Diff(op, substring);\n          if (this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty()) {\n            this.flushChangeLines();\n            this.pushDiffCommonLine(subdiff);\n          } else {\n            this.pushDiffChangeLines(subdiff);\n            this.flushChangeLines();\n          }\n        } else if (i < iLast) {\n          this.pushDiffCommonLine(new Diff(op, substring));\n        } else if (substring.length !== 0) {\n          this.pushDiffChangeLines(new Diff(op, substring));\n        }\n      });\n    } else {\n      this.pushDiffChangeLines(diff2);\n    }\n  }\n  // Output from buffer.\n  getLines() {\n    this.flushChangeLines();\n    return this.lines;\n  }\n};\n__name(_CommonBuffer, \"CommonBuffer\");\nvar CommonBuffer = _CommonBuffer;\nfunction getAlignedDiffs(diffs, changeColor) {\n  const deleteBuffer = new ChangeBuffer(DIFF_DELETE, changeColor);\n  const insertBuffer = new ChangeBuffer(DIFF_INSERT, changeColor);\n  const commonBuffer = new CommonBuffer(deleteBuffer, insertBuffer);\n  diffs.forEach((diff2) => {\n    switch (diff2[0]) {\n      case DIFF_DELETE:\n        deleteBuffer.align(diff2);\n        break;\n      case DIFF_INSERT:\n        insertBuffer.align(diff2);\n        break;\n      default:\n        commonBuffer.align(diff2);\n    }\n  });\n  return commonBuffer.getLines();\n}\n__name(getAlignedDiffs, \"getAlignedDiffs\");\nfunction hasCommonDiff(diffs, isMultiline) {\n  if (isMultiline) {\n    const iLast = diffs.length - 1;\n    return diffs.some((diff2, i) => diff2[0] === DIFF_EQUAL && (i !== iLast || diff2[1] !== \"\\n\"));\n  }\n  return diffs.some((diff2) => diff2[0] === DIFF_EQUAL);\n}\n__name(hasCommonDiff, \"hasCommonDiff\");\nfunction diffStringsUnified(a2, b, options) {\n  if (a2 !== b && a2.length !== 0 && b.length !== 0) {\n    const isMultiline = a2.includes(\"\\n\") || b.includes(\"\\n\");\n    const [diffs, truncated] = diffStringsRaw(isMultiline ? `${a2}\n` : a2, isMultiline ? `${b}\n` : b, true, options);\n    if (hasCommonDiff(diffs, isMultiline)) {\n      const optionsNormalized = normalizeDiffOptions(options);\n      const lines = getAlignedDiffs(diffs, optionsNormalized.changeColor);\n      return printDiffLines(lines, truncated, optionsNormalized);\n    }\n  }\n  return diffLinesUnified(a2.split(\"\\n\"), b.split(\"\\n\"), options);\n}\n__name(diffStringsUnified, \"diffStringsUnified\");\nfunction diffStringsRaw(a2, b, cleanup, options) {\n  const [diffs, truncated] = diffStrings(a2, b, options);\n  if (cleanup) {\n    diff_cleanupSemantic(diffs);\n  }\n  return [diffs, truncated];\n}\n__name(diffStringsRaw, \"diffStringsRaw\");\nfunction getCommonMessage(message, options) {\n  const { commonColor } = normalizeDiffOptions(options);\n  return commonColor(message);\n}\n__name(getCommonMessage, \"getCommonMessage\");\nvar { AsymmetricMatcher: AsymmetricMatcher2, DOMCollection: DOMCollection2, DOMElement: DOMElement2, Immutable: Immutable2, ReactElement: ReactElement2, ReactTestComponent: ReactTestComponent2 } = plugins;\nvar PLUGINS2 = [\n  ReactTestComponent2,\n  ReactElement2,\n  DOMElement2,\n  DOMCollection2,\n  Immutable2,\n  AsymmetricMatcher2,\n  plugins.Error\n];\nvar FORMAT_OPTIONS = {\n  maxDepth: 20,\n  plugins: PLUGINS2\n};\nvar FALLBACK_FORMAT_OPTIONS = {\n  callToJSON: false,\n  maxDepth: 8,\n  plugins: PLUGINS2\n};\nfunction diff(a2, b, options) {\n  if (Object.is(a2, b)) {\n    return \"\";\n  }\n  const aType = getType3(a2);\n  let expectedType = aType;\n  let omitDifference = false;\n  if (aType === \"object\" && typeof a2.asymmetricMatch === \"function\") {\n    if (a2.$$typeof !== Symbol.for(\"jest.asymmetricMatcher\")) {\n      return void 0;\n    }\n    if (typeof a2.getExpectedType !== \"function\") {\n      return void 0;\n    }\n    expectedType = a2.getExpectedType();\n    omitDifference = expectedType === \"string\";\n  }\n  if (expectedType !== getType3(b)) {\n    let truncate2 = function(s2) {\n      return s2.length <= MAX_LENGTH ? s2 : `${s2.slice(0, MAX_LENGTH)}...`;\n    };\n    __name(truncate2, \"truncate\");\n    const { aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator } = normalizeDiffOptions(options);\n    const formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options);\n    let aDisplay = format(a2, formatOptions);\n    let bDisplay = format(b, formatOptions);\n    const MAX_LENGTH = 1e5;\n    aDisplay = truncate2(aDisplay);\n    bDisplay = truncate2(bDisplay);\n    const aDiff = `${aColor(`${aIndicator} ${aAnnotation}:`)} \n${aDisplay}`;\n    const bDiff = `${bColor(`${bIndicator} ${bAnnotation}:`)} \n${bDisplay}`;\n    return `${aDiff}\n\n${bDiff}`;\n  }\n  if (omitDifference) {\n    return void 0;\n  }\n  switch (aType) {\n    case \"string\":\n      return diffLinesUnified(a2.split(\"\\n\"), b.split(\"\\n\"), options);\n    case \"boolean\":\n    case \"number\":\n      return comparePrimitive(a2, b, options);\n    case \"map\":\n      return compareObjects(sortMap(a2), sortMap(b), options);\n    case \"set\":\n      return compareObjects(sortSet(a2), sortSet(b), options);\n    default:\n      return compareObjects(a2, b, options);\n  }\n}\n__name(diff, \"diff\");\nfunction comparePrimitive(a2, b, options) {\n  const aFormat = format(a2, FORMAT_OPTIONS);\n  const bFormat = format(b, FORMAT_OPTIONS);\n  return aFormat === bFormat ? \"\" : diffLinesUnified(aFormat.split(\"\\n\"), bFormat.split(\"\\n\"), options);\n}\n__name(comparePrimitive, \"comparePrimitive\");\nfunction sortMap(map) {\n  return new Map(Array.from(map.entries()).sort());\n}\n__name(sortMap, \"sortMap\");\nfunction sortSet(set) {\n  return new Set(Array.from(set.values()).sort());\n}\n__name(sortSet, \"sortSet\");\nfunction compareObjects(a2, b, options) {\n  let difference;\n  let hasThrown = false;\n  try {\n    const formatOptions = getFormatOptions(FORMAT_OPTIONS, options);\n    difference = getObjectsDifference(a2, b, formatOptions, options);\n  } catch {\n    hasThrown = true;\n  }\n  const noDiffMessage = getCommonMessage(NO_DIFF_MESSAGE, options);\n  if (difference === void 0 || difference === noDiffMessage) {\n    const formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options);\n    difference = getObjectsDifference(a2, b, formatOptions, options);\n    if (difference !== noDiffMessage && !hasThrown) {\n      difference = `${getCommonMessage(SIMILAR_MESSAGE, options)}\n\n${difference}`;\n    }\n  }\n  return difference;\n}\n__name(compareObjects, \"compareObjects\");\nfunction getFormatOptions(formatOptions, options) {\n  const { compareKeys, printBasicPrototype, maxDepth } = normalizeDiffOptions(options);\n  return {\n    ...formatOptions,\n    compareKeys,\n    printBasicPrototype,\n    maxDepth: maxDepth ?? formatOptions.maxDepth\n  };\n}\n__name(getFormatOptions, \"getFormatOptions\");\nfunction getObjectsDifference(a2, b, formatOptions, options) {\n  const formatOptionsZeroIndent = {\n    ...formatOptions,\n    indent: 0\n  };\n  const aCompare = format(a2, formatOptionsZeroIndent);\n  const bCompare = format(b, formatOptionsZeroIndent);\n  if (aCompare === bCompare) {\n    return getCommonMessage(NO_DIFF_MESSAGE, options);\n  } else {\n    const aDisplay = format(a2, formatOptions);\n    const bDisplay = format(b, formatOptions);\n    return diffLinesUnified2(aDisplay.split(\"\\n\"), bDisplay.split(\"\\n\"), aCompare.split(\"\\n\"), bCompare.split(\"\\n\"), options);\n  }\n}\n__name(getObjectsDifference, \"getObjectsDifference\");\nvar MAX_DIFF_STRING_LENGTH = 2e4;\nfunction isAsymmetricMatcher(data) {\n  const type = getType2(data);\n  return type === \"Object\" && typeof data.asymmetricMatch === \"function\";\n}\n__name(isAsymmetricMatcher, \"isAsymmetricMatcher\");\nfunction isReplaceable(obj1, obj2) {\n  const obj1Type = getType2(obj1);\n  const obj2Type = getType2(obj2);\n  return obj1Type === obj2Type && (obj1Type === \"Object\" || obj1Type === \"Array\");\n}\n__name(isReplaceable, \"isReplaceable\");\nfunction printDiffOrStringify(received, expected, options) {\n  const { aAnnotation, bAnnotation } = normalizeDiffOptions(options);\n  if (typeof expected === \"string\" && typeof received === \"string\" && expected.length > 0 && received.length > 0 && expected.length <= MAX_DIFF_STRING_LENGTH && received.length <= MAX_DIFF_STRING_LENGTH && expected !== received) {\n    if (expected.includes(\"\\n\") || received.includes(\"\\n\")) {\n      return diffStringsUnified(expected, received, options);\n    }\n    const [diffs] = diffStringsRaw(expected, received, true);\n    const hasCommonDiff2 = diffs.some((diff2) => diff2[0] === DIFF_EQUAL);\n    const printLabel = getLabelPrinter(aAnnotation, bAnnotation);\n    const expectedLine = printLabel(aAnnotation) + printExpected(getCommonAndChangedSubstrings(diffs, DIFF_DELETE, hasCommonDiff2));\n    const receivedLine = printLabel(bAnnotation) + printReceived(getCommonAndChangedSubstrings(diffs, DIFF_INSERT, hasCommonDiff2));\n    return `${expectedLine}\n${receivedLine}`;\n  }\n  const clonedExpected = deepClone(expected, { forceWritable: true });\n  const clonedReceived = deepClone(received, { forceWritable: true });\n  const { replacedExpected, replacedActual } = replaceAsymmetricMatcher(clonedReceived, clonedExpected);\n  const difference = diff(replacedExpected, replacedActual, options);\n  return difference;\n}\n__name(printDiffOrStringify, \"printDiffOrStringify\");\nfunction replaceAsymmetricMatcher(actual, expected, actualReplaced = /* @__PURE__ */ new WeakSet(), expectedReplaced = /* @__PURE__ */ new WeakSet()) {\n  if (actual instanceof Error && expected instanceof Error && typeof actual.cause !== \"undefined\" && typeof expected.cause === \"undefined\") {\n    delete actual.cause;\n    return {\n      replacedActual: actual,\n      replacedExpected: expected\n    };\n  }\n  if (!isReplaceable(actual, expected)) {\n    return {\n      replacedActual: actual,\n      replacedExpected: expected\n    };\n  }\n  if (actualReplaced.has(actual) || expectedReplaced.has(expected)) {\n    return {\n      replacedActual: actual,\n      replacedExpected: expected\n    };\n  }\n  actualReplaced.add(actual);\n  expectedReplaced.add(expected);\n  getOwnProperties(expected).forEach((key) => {\n    const expectedValue = expected[key];\n    const actualValue = actual[key];\n    if (isAsymmetricMatcher(expectedValue)) {\n      if (expectedValue.asymmetricMatch(actualValue)) {\n        actual[key] = expectedValue;\n      }\n    } else if (isAsymmetricMatcher(actualValue)) {\n      if (actualValue.asymmetricMatch(expectedValue)) {\n        expected[key] = actualValue;\n      }\n    } else if (isReplaceable(actualValue, expectedValue)) {\n      const replaced = replaceAsymmetricMatcher(actualValue, expectedValue, actualReplaced, expectedReplaced);\n      actual[key] = replaced.replacedActual;\n      expected[key] = replaced.replacedExpected;\n    }\n  });\n  return {\n    replacedActual: actual,\n    replacedExpected: expected\n  };\n}\n__name(replaceAsymmetricMatcher, \"replaceAsymmetricMatcher\");\nfunction getLabelPrinter(...strings) {\n  const maxLength = strings.reduce((max, string) => string.length > max ? string.length : max, 0);\n  return (string) => `${string}: ${\" \".repeat(maxLength - string.length)}`;\n}\n__name(getLabelPrinter, \"getLabelPrinter\");\nvar SPACE_SYMBOL = \"\";\nfunction replaceTrailingSpaces(text) {\n  return text.replace(/\\s+$/gm, (spaces) => SPACE_SYMBOL.repeat(spaces.length));\n}\n__name(replaceTrailingSpaces, \"replaceTrailingSpaces\");\nfunction printReceived(object) {\n  return s.red(replaceTrailingSpaces(stringify(object)));\n}\n__name(printReceived, \"printReceived\");\nfunction printExpected(value) {\n  return s.green(replaceTrailingSpaces(stringify(value)));\n}\n__name(printExpected, \"printExpected\");\nfunction getCommonAndChangedSubstrings(diffs, op, hasCommonDiff2) {\n  return diffs.reduce((reduced, diff2) => reduced + (diff2[0] === DIFF_EQUAL ? diff2[1] : diff2[0] === op ? hasCommonDiff2 ? s.inverse(diff2[1]) : diff2[1] : \"\"), \"\");\n}\n__name(getCommonAndChangedSubstrings, \"getCommonAndChangedSubstrings\");\nvar IS_RECORD_SYMBOL = \"@@__IMMUTABLE_RECORD__@@\";\nvar IS_COLLECTION_SYMBOL = \"@@__IMMUTABLE_ITERABLE__@@\";\nfunction isImmutable(v) {\n  return v && (v[IS_COLLECTION_SYMBOL] || v[IS_RECORD_SYMBOL]);\n}\n__name(isImmutable, \"isImmutable\");\nvar OBJECT_PROTO = Object.getPrototypeOf({});\nfunction getUnserializableMessage(err) {\n  if (err instanceof Error) {\n    return `<unserializable>: ${err.message}`;\n  }\n  if (typeof err === \"string\") {\n    return `<unserializable>: ${err}`;\n  }\n  return \"<unserializable>\";\n}\n__name(getUnserializableMessage, \"getUnserializableMessage\");\nfunction serializeValue(val, seen = /* @__PURE__ */ new WeakMap()) {\n  if (!val || typeof val === \"string\") {\n    return val;\n  }\n  if (val instanceof Error && \"toJSON\" in val && typeof val.toJSON === \"function\") {\n    const jsonValue = val.toJSON();\n    if (jsonValue && jsonValue !== val && typeof jsonValue === \"object\") {\n      if (typeof val.message === \"string\") {\n        safe(() => jsonValue.message ?? (jsonValue.message = val.message));\n      }\n      if (typeof val.stack === \"string\") {\n        safe(() => jsonValue.stack ?? (jsonValue.stack = val.stack));\n      }\n      if (typeof val.name === \"string\") {\n        safe(() => jsonValue.name ?? (jsonValue.name = val.name));\n      }\n      if (val.cause != null) {\n        safe(() => jsonValue.cause ?? (jsonValue.cause = serializeValue(val.cause, seen)));\n      }\n    }\n    return serializeValue(jsonValue, seen);\n  }\n  if (typeof val === \"function\") {\n    return `Function<${val.name || \"anonymous\"}>`;\n  }\n  if (typeof val === \"symbol\") {\n    return val.toString();\n  }\n  if (typeof val !== \"object\") {\n    return val;\n  }\n  if (typeof Buffer !== \"undefined\" && val instanceof Buffer) {\n    return `<Buffer(${val.length}) ...>`;\n  }\n  if (typeof Uint8Array !== \"undefined\" && val instanceof Uint8Array) {\n    return `<Uint8Array(${val.length}) ...>`;\n  }\n  if (isImmutable(val)) {\n    return serializeValue(val.toJSON(), seen);\n  }\n  if (val instanceof Promise || val.constructor && val.constructor.prototype === \"AsyncFunction\") {\n    return \"Promise\";\n  }\n  if (typeof Element !== \"undefined\" && val instanceof Element) {\n    return val.tagName;\n  }\n  if (typeof val.asymmetricMatch === \"function\") {\n    return `${val.toString()} ${format2(val.sample)}`;\n  }\n  if (typeof val.toJSON === \"function\") {\n    return serializeValue(val.toJSON(), seen);\n  }\n  if (seen.has(val)) {\n    return seen.get(val);\n  }\n  if (Array.isArray(val)) {\n    const clone2 = new Array(val.length);\n    seen.set(val, clone2);\n    val.forEach((e, i) => {\n      try {\n        clone2[i] = serializeValue(e, seen);\n      } catch (err) {\n        clone2[i] = getUnserializableMessage(err);\n      }\n    });\n    return clone2;\n  } else {\n    const clone2 = /* @__PURE__ */ Object.create(null);\n    seen.set(val, clone2);\n    let obj = val;\n    while (obj && obj !== OBJECT_PROTO) {\n      Object.getOwnPropertyNames(obj).forEach((key) => {\n        if (key in clone2) {\n          return;\n        }\n        try {\n          clone2[key] = serializeValue(val[key], seen);\n        } catch (err) {\n          delete clone2[key];\n          clone2[key] = getUnserializableMessage(err);\n        }\n      });\n      obj = Object.getPrototypeOf(obj);\n    }\n    return clone2;\n  }\n}\n__name(serializeValue, \"serializeValue\");\nfunction safe(fn) {\n  try {\n    return fn();\n  } catch {\n  }\n}\n__name(safe, \"safe\");\nfunction normalizeErrorMessage(message) {\n  return message.replace(/__(vite_ssr_import|vi_import)_\\d+__\\./g, \"\");\n}\n__name(normalizeErrorMessage, \"normalizeErrorMessage\");\nfunction processError(_err, diffOptions, seen = /* @__PURE__ */ new WeakSet()) {\n  if (!_err || typeof _err !== \"object\") {\n    return { message: String(_err) };\n  }\n  const err = _err;\n  if (err.showDiff || err.showDiff === void 0 && err.expected !== void 0 && err.actual !== void 0) {\n    err.diff = printDiffOrStringify(err.actual, err.expected, {\n      ...diffOptions,\n      ...err.diffOptions\n    });\n  }\n  if (\"expected\" in err && typeof err.expected !== \"string\") {\n    err.expected = stringify(err.expected, 10);\n  }\n  if (\"actual\" in err && typeof err.actual !== \"string\") {\n    err.actual = stringify(err.actual, 10);\n  }\n  try {\n    if (typeof err.message === \"string\") {\n      err.message = normalizeErrorMessage(err.message);\n    }\n  } catch {\n  }\n  try {\n    if (!seen.has(err) && typeof err.cause === \"object\") {\n      seen.add(err);\n      err.cause = processError(err.cause, diffOptions, seen);\n    }\n  } catch {\n  }\n  try {\n    return serializeValue(err);\n  } catch (e) {\n    return serializeValue(new Error(`Failed to fully serialize error: ${e === null || e === void 0 ? void 0 : e.message}\nInner error message: ${err === null || err === void 0 ? void 0 : err.message}`));\n  }\n}\n__name(processError, \"processError\");\nexport {\n  s,\n  stringify,\n  getDefaultExportFromCjs2 as getDefaultExportFromCjs,\n  assertTypes,\n  isObject,\n  getType2 as getType,\n  noop,\n  diff,\n  printDiffOrStringify,\n  processError\n};\n",
      "start": 1762256767707,
      "end": 1762256767791,
      "order": "normal-normal",
      "sourcemaps": null
    },
    {
      "name": "vite:build-html",
      "start": 1762256767791,
      "end": 1762256767791,
      "order": "normal-normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1762256767791,
      "end": 1762256767791,
      "order": "normal-normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1762256767791,
      "end": 1762256767791,
      "order": "normal-normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1762256767796,
      "end": 1762256767796,
      "order": "normal-normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1762256767796,
      "end": 1762256767796,
      "order": "normal-normal"
    },
    {
      "name": "vite-plugin-svelte-module",
      "start": 1762256767796,
      "end": 1762256767796,
      "order": "post"
    },
    {
      "name": "storybook:inject-export-order-plugin",
      "start": 1762256767796,
      "end": 1762256767796,
      "order": "post"
    },
    {
      "name": "storybook:strip-hmr-boundary-plugin",
      "start": 1762256767796,
      "end": 1762256767796,
      "order": "post"
    },
    {
      "name": "storybook:external-globals-plugin",
      "start": 1762256767796,
      "end": 1762256767797,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1762256767797,
      "end": 1762256767797,
      "order": "normal-normal"
    },
    {
      "name": "vite:reporter",
      "start": 1762256767797,
      "end": 1762256767797,
      "order": "normal"
    }
  ]
}
