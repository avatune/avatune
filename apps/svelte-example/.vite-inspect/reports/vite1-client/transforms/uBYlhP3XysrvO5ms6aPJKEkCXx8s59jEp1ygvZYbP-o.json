{
  "resolvedId": "/Users/teimurgasanov/Projects/avatune/node_modules/storybook/dist/_browser-chunks/chunk-NVV6MIOE.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import {\n  __commonJS,\n  __name,\n  __require\n} from \"./chunk-MM7DTO55.js\";\n\n// ../node_modules/memoizerific/memoizerific.js\nvar require_memoizerific = __commonJS({\n  \"../node_modules/memoizerific/memoizerific.js\"(exports, module) {\n    (function(f) {\n      if (typeof exports === \"object\" && typeof module !== \"undefined\") {\n        module.exports = f();\n      } else if (typeof define === \"function\" && define.amd) {\n        define([], f);\n      } else {\n        var g;\n        if (typeof window !== \"undefined\") {\n          g = window;\n        } else if (typeof global !== \"undefined\") {\n          g = global;\n        } else if (typeof self !== \"undefined\") {\n          g = self;\n        } else {\n          g = this;\n        }\n        g.memoizerific = f();\n      }\n    })(function() {\n      var define2, module2, exports2;\n      return (/* @__PURE__ */ __name(function e(t, n, r) {\n        function s(o2, u) {\n          if (!n[o2]) {\n            if (!t[o2]) {\n              var a = typeof __require == \"function\" && __require;\n              if (!u && a) return a(o2, true);\n              if (i) return i(o2, true);\n              var f = new Error(\"Cannot find module '\" + o2 + \"'\");\n              throw f.code = \"MODULE_NOT_FOUND\", f;\n            }\n            var l = n[o2] = { exports: {} };\n            t[o2][0].call(l.exports, function(e2) {\n              var n2 = t[o2][1][e2];\n              return s(n2 ? n2 : e2);\n            }, l, l.exports, e, t, n, r);\n          }\n          return n[o2].exports;\n        }\n        __name(s, \"s\");\n        var i = typeof __require == \"function\" && __require;\n        for (var o = 0; o < r.length; o++) s(r[o]);\n        return s;\n      }, \"e\"))({ 1: [function(_dereq_, module3, exports3) {\n        module3.exports = function(forceSimilar) {\n          if (typeof Map !== \"function\" || forceSimilar) {\n            var Similar = _dereq_(\"./similar\");\n            return new Similar();\n          } else {\n            return /* @__PURE__ */ new Map();\n          }\n        };\n      }, { \"./similar\": 2 }], 2: [function(_dereq_, module3, exports3) {\n        function Similar() {\n          this.list = [];\n          this.lastItem = void 0;\n          this.size = 0;\n          return this;\n        }\n        __name(Similar, \"Similar\");\n        Similar.prototype.get = function(key) {\n          var index;\n          if (this.lastItem && this.isEqual(this.lastItem.key, key)) {\n            return this.lastItem.val;\n          }\n          index = this.indexOf(key);\n          if (index >= 0) {\n            this.lastItem = this.list[index];\n            return this.list[index].val;\n          }\n          return void 0;\n        };\n        Similar.prototype.set = function(key, val) {\n          var index;\n          if (this.lastItem && this.isEqual(this.lastItem.key, key)) {\n            this.lastItem.val = val;\n            return this;\n          }\n          index = this.indexOf(key);\n          if (index >= 0) {\n            this.lastItem = this.list[index];\n            this.list[index].val = val;\n            return this;\n          }\n          this.lastItem = { key, val };\n          this.list.push(this.lastItem);\n          this.size++;\n          return this;\n        };\n        Similar.prototype.delete = function(key) {\n          var index;\n          if (this.lastItem && this.isEqual(this.lastItem.key, key)) {\n            this.lastItem = void 0;\n          }\n          index = this.indexOf(key);\n          if (index >= 0) {\n            this.size--;\n            return this.list.splice(index, 1)[0];\n          }\n          return void 0;\n        };\n        Similar.prototype.has = function(key) {\n          var index;\n          if (this.lastItem && this.isEqual(this.lastItem.key, key)) {\n            return true;\n          }\n          index = this.indexOf(key);\n          if (index >= 0) {\n            this.lastItem = this.list[index];\n            return true;\n          }\n          return false;\n        };\n        Similar.prototype.forEach = function(callback, thisArg) {\n          var i;\n          for (i = 0; i < this.size; i++) {\n            callback.call(thisArg || this, this.list[i].val, this.list[i].key, this);\n          }\n        };\n        Similar.prototype.indexOf = function(key) {\n          var i;\n          for (i = 0; i < this.size; i++) {\n            if (this.isEqual(this.list[i].key, key)) {\n              return i;\n            }\n          }\n          return -1;\n        };\n        Similar.prototype.isEqual = function(val1, val2) {\n          return val1 === val2 || val1 !== val1 && val2 !== val2;\n        };\n        module3.exports = Similar;\n      }, {}], 3: [function(_dereq_, module3, exports3) {\n        var MapOrSimilar = _dereq_(\"map-or-similar\");\n        module3.exports = function(limit) {\n          var cache = new MapOrSimilar(false), lru = [];\n          return function(fn) {\n            var memoizerific = /* @__PURE__ */ __name(function() {\n              var currentCache = cache, newMap, fnResult, argsLengthMinusOne = arguments.length - 1, lruPath = Array(argsLengthMinusOne + 1), isMemoized = true, i;\n              if ((memoizerific.numArgs || memoizerific.numArgs === 0) && memoizerific.numArgs !== argsLengthMinusOne + 1) {\n                throw new Error(\"Memoizerific functions should always be called with the same number of arguments\");\n              }\n              for (i = 0; i < argsLengthMinusOne; i++) {\n                lruPath[i] = {\n                  cacheItem: currentCache,\n                  arg: arguments[i]\n                };\n                if (currentCache.has(arguments[i])) {\n                  currentCache = currentCache.get(arguments[i]);\n                  continue;\n                }\n                isMemoized = false;\n                newMap = new MapOrSimilar(false);\n                currentCache.set(arguments[i], newMap);\n                currentCache = newMap;\n              }\n              if (isMemoized) {\n                if (currentCache.has(arguments[argsLengthMinusOne])) {\n                  fnResult = currentCache.get(arguments[argsLengthMinusOne]);\n                } else {\n                  isMemoized = false;\n                }\n              }\n              if (!isMemoized) {\n                fnResult = fn.apply(null, arguments);\n                currentCache.set(arguments[argsLengthMinusOne], fnResult);\n              }\n              if (limit > 0) {\n                lruPath[argsLengthMinusOne] = {\n                  cacheItem: currentCache,\n                  arg: arguments[argsLengthMinusOne]\n                };\n                if (isMemoized) {\n                  moveToMostRecentLru(lru, lruPath);\n                } else {\n                  lru.push(lruPath);\n                }\n                if (lru.length > limit) {\n                  removeCachedResult(lru.shift());\n                }\n              }\n              memoizerific.wasMemoized = isMemoized;\n              memoizerific.numArgs = argsLengthMinusOne + 1;\n              return fnResult;\n            }, \"memoizerific\");\n            memoizerific.limit = limit;\n            memoizerific.wasMemoized = false;\n            memoizerific.cache = cache;\n            memoizerific.lru = lru;\n            return memoizerific;\n          };\n        };\n        function moveToMostRecentLru(lru, lruPath) {\n          var lruLen = lru.length, lruPathLen = lruPath.length, isMatch, i, ii;\n          for (i = 0; i < lruLen; i++) {\n            isMatch = true;\n            for (ii = 0; ii < lruPathLen; ii++) {\n              if (!isEqual(lru[i][ii].arg, lruPath[ii].arg)) {\n                isMatch = false;\n                break;\n              }\n            }\n            if (isMatch) {\n              break;\n            }\n          }\n          lru.push(lru.splice(i, 1)[0]);\n        }\n        __name(moveToMostRecentLru, \"moveToMostRecentLru\");\n        function removeCachedResult(removedLru) {\n          var removedLruLen = removedLru.length, currentLru = removedLru[removedLruLen - 1], tmp, i;\n          currentLru.cacheItem.delete(currentLru.arg);\n          for (i = removedLruLen - 2; i >= 0; i--) {\n            currentLru = removedLru[i];\n            tmp = currentLru.cacheItem.get(currentLru.arg);\n            if (!tmp || !tmp.size) {\n              currentLru.cacheItem.delete(currentLru.arg);\n            } else {\n              break;\n            }\n          }\n        }\n        __name(removeCachedResult, \"removeCachedResult\");\n        function isEqual(val1, val2) {\n          return val1 === val2 || val1 !== val1 && val2 !== val2;\n        }\n        __name(isEqual, \"isEqual\");\n      }, { \"map-or-similar\": 1 }] }, {}, [3])(3);\n    });\n  }\n});\n\nexport {\n  require_memoizerific\n};\n",
      "start": 1762256767098,
      "end": 1762256767136,
      "sourcemaps": null
    },
    {
      "name": "storybook:mock-loader",
      "start": 1762256767136,
      "end": 1762256767136,
      "order": "normal-pre"
    },
    {
      "name": "vite-plugin-svelte",
      "start": 1762256767136,
      "end": 1762256767136,
      "order": "pre"
    },
    {
      "name": "plugin-csf",
      "start": 1762256767136,
      "end": 1762256767136,
      "order": "pre"
    },
    {
      "name": "vite:esbuild",
      "start": 1762256767136,
      "end": 1762256767136,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1762256767136,
      "end": 1762256767136,
      "order": "normal-normal"
    },
    {
      "name": "storybook:mock-loader-preview",
      "start": 1762256767136,
      "end": 1762256767136,
      "order": "normal"
    },
    {
      "name": "storybook:svelte-docgen-plugin",
      "start": 1762256767136,
      "end": 1762256767136,
      "order": "normal"
    },
    {
      "name": "storybook:addon-svelte-csf",
      "start": 1762256767136,
      "end": 1762256767136,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1762256767136,
      "end": 1762256767136,
      "order": "normal-normal"
    },
    {
      "name": "vite:build-html",
      "start": 1762256767136,
      "end": 1762256767136,
      "order": "normal-normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1762256767136,
      "end": 1762256767136,
      "order": "normal-normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1762256767136,
      "end": 1762256767136,
      "order": "normal-normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1762256767137,
      "end": 1762256767137,
      "order": "normal-normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1762256767137,
      "end": 1762256767137,
      "order": "normal-normal"
    },
    {
      "name": "vite-plugin-svelte-module",
      "start": 1762256767137,
      "end": 1762256767137,
      "order": "post"
    },
    {
      "name": "storybook:inject-export-order-plugin",
      "start": 1762256767137,
      "end": 1762256767137,
      "order": "post"
    },
    {
      "name": "storybook:strip-hmr-boundary-plugin",
      "start": 1762256767137,
      "end": 1762256767137,
      "order": "post"
    },
    {
      "name": "storybook:external-globals-plugin",
      "start": 1762256767137,
      "end": 1762256767137,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1762256767137,
      "end": 1762256767137,
      "order": "normal-normal"
    },
    {
      "name": "vite:reporter",
      "start": 1762256767137,
      "end": 1762256767137,
      "order": "normal"
    }
  ]
}
